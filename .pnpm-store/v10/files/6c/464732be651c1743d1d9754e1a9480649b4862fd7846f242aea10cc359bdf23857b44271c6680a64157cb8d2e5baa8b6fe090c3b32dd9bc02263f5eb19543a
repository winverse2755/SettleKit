"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchVault = fetchVault;
exports.fetchAccrualVault = fetchAccrualVault;
const ethers_1 = require("ethers");
const ethers_types_1 = require("ethers-types");
const blue_sdk_1 = require("@morpho-org/blue-sdk");
const VaultConfig_1 = require("./VaultConfig");
const VaultMarketAllocation_1 = require("./VaultMarketAllocation");
async function fetchVault(address, runner, options = {}) {
    options.chainId ??= Number((await runner.provider.getNetwork()).chainId);
    const chainAddresses = (0, blue_sdk_1.getChainAddresses)(options.chainId);
    const mm = ethers_types_1.MetaMorpho__factory.connect(address, runner);
    const { overrides = {} } = options;
    const [config, curator, owner, guardian, timelock, pendingTimelock, pendingGuardian, pendingOwner, fee, feeRecipient, skimRecipient, totalSupply, totalAssets, lastTotalAssets, lostAssets, supplyQueueSize, withdrawQueueSize, hasPublicAllocator,] = await Promise.all([
        (0, VaultConfig_1.fetchVaultConfig)(address, runner, options),
        mm.curator(overrides),
        mm.owner(overrides),
        mm.guardian(overrides),
        mm.timelock(overrides),
        mm
            .pendingTimelock(overrides)
            .then(({ value, validAt }) => ({ value, validAt })),
        mm
            .pendingGuardian(overrides)
            .then(({ value, validAt }) => ({ value: value, validAt })),
        mm.pendingOwner(overrides),
        mm.fee(overrides),
        mm.feeRecipient(overrides),
        mm.skimRecipient(overrides),
        mm.totalSupply(overrides),
        mm.totalAssets(overrides),
        mm.lastTotalAssets(overrides),
        ethers_types_1.MetaMorphoV1_1__factory.connect(address, runner)
            .lostAssets(overrides)
            .catch(() => undefined),
        mm.supplyQueueLength(overrides).then((r) => Number(r)),
        mm.withdrawQueueLength(overrides).then((r) => Number(r)),
        chainAddresses.publicAllocator &&
            mm.isAllocator(chainAddresses.publicAllocator, overrides),
    ]);
    let publicAllocatorConfigPromise;
    if (hasPublicAllocator) {
        const publicAllocator = ethers_types_1.PublicAllocator__factory.connect(chainAddresses.publicAllocator, runner);
        publicAllocatorConfigPromise = (0, ethers_1.resolveProperties)({
            admin: publicAllocator.admin(address, overrides),
            fee: publicAllocator.fee(address, overrides),
            accruedFee: publicAllocator.accruedFee(address, overrides),
        });
    }
    const [supplyQueue, withdrawQueue, publicAllocatorConfig] = await Promise.all([
        Promise.all(new Array(supplyQueueSize)
            .fill(null)
            .map((_, i) => mm.supplyQueue(i, overrides))),
        Promise.all(new Array(withdrawQueueSize)
            .fill(null)
            .map((_, i) => mm.withdrawQueue(i, overrides))),
        publicAllocatorConfigPromise,
    ]);
    return new blue_sdk_1.Vault({
        ...config,
        owner,
        curator,
        guardian,
        feeRecipient,
        skimRecipient,
        timelock,
        fee,
        pendingOwner,
        pendingGuardian,
        pendingTimelock,
        publicAllocatorConfig,
        supplyQueue,
        withdrawQueue,
        totalSupply,
        totalAssets,
        lastTotalAssets,
        lostAssets,
    });
}
async function fetchAccrualVault(address, runner, options = {}) {
    options.chainId ??= Number((await runner.provider.getNetwork()).chainId);
    const vault = await fetchVault(address, runner, options);
    const allocations = await Promise.all(Array.from(vault.withdrawQueue, (marketId) => (0, VaultMarketAllocation_1.fetchVaultMarketAllocation)(vault.address, marketId, runner, options)));
    return new blue_sdk_1.AccrualVault(vault, allocations);
}
