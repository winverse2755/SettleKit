/**
 * Copyright (c) 2026, Circle Internet Group, Inc. All rights reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

// Buffer polyfill setup - executes before any other code
// Ensures globalThis.Buffer is available for @solana/spl-token and other Solana libraries
const { Buffer } = require('buffer');
if (typeof globalThis !== 'undefined' && typeof globalThis.Buffer === 'undefined') {
    globalThis.Buffer = Buffer;
}
if (typeof window !== 'undefined' && typeof window.Buffer === 'undefined') {
    window.Buffer = Buffer;
}


var zod = require('zod');
var bytes = require('@ethersproject/bytes');
var address = require('@ethersproject/address');
var bs58 = require('bs58');
var units = require('@ethersproject/units');

function _interopDefault (e) { return e && e.__esModule ? e.default : e; }

var bs58__default = /*#__PURE__*/_interopDefault(bs58);

// -----------------------------------------------------------------------------
// Blockchain Enum
// -----------------------------------------------------------------------------
/**
 * Enumeration of all blockchains known to this library.
 *
 * This enum contains every blockchain that has a chain definition, regardless
 * of whether bridging is currently supported. For chains that support bridging
 * via CCTPv2, see {@link BridgeChain}.
 *
 * @enum
 * @category Enums
 * @description Provides string identifiers for each blockchain with a definition.
 * @see {@link BridgeChain} for the subset of chains that support CCTPv2 bridging.
 */
var Blockchain;
(function (Blockchain) {
    Blockchain["Algorand"] = "Algorand";
    Blockchain["Algorand_Testnet"] = "Algorand_Testnet";
    Blockchain["Aptos"] = "Aptos";
    Blockchain["Aptos_Testnet"] = "Aptos_Testnet";
    Blockchain["Arc_Testnet"] = "Arc_Testnet";
    Blockchain["Arbitrum"] = "Arbitrum";
    Blockchain["Arbitrum_Sepolia"] = "Arbitrum_Sepolia";
    Blockchain["Avalanche"] = "Avalanche";
    Blockchain["Avalanche_Fuji"] = "Avalanche_Fuji";
    Blockchain["Base"] = "Base";
    Blockchain["Base_Sepolia"] = "Base_Sepolia";
    Blockchain["Celo"] = "Celo";
    Blockchain["Celo_Alfajores_Testnet"] = "Celo_Alfajores_Testnet";
    Blockchain["Codex"] = "Codex";
    Blockchain["Codex_Testnet"] = "Codex_Testnet";
    Blockchain["Ethereum"] = "Ethereum";
    Blockchain["Ethereum_Sepolia"] = "Ethereum_Sepolia";
    Blockchain["Hedera"] = "Hedera";
    Blockchain["Hedera_Testnet"] = "Hedera_Testnet";
    Blockchain["HyperEVM"] = "HyperEVM";
    Blockchain["HyperEVM_Testnet"] = "HyperEVM_Testnet";
    Blockchain["Ink"] = "Ink";
    Blockchain["Ink_Testnet"] = "Ink_Testnet";
    Blockchain["Linea"] = "Linea";
    Blockchain["Linea_Sepolia"] = "Linea_Sepolia";
    Blockchain["Monad"] = "Monad";
    Blockchain["Monad_Testnet"] = "Monad_Testnet";
    Blockchain["NEAR"] = "NEAR";
    Blockchain["NEAR_Testnet"] = "NEAR_Testnet";
    Blockchain["Noble"] = "Noble";
    Blockchain["Noble_Testnet"] = "Noble_Testnet";
    Blockchain["Optimism"] = "Optimism";
    Blockchain["Optimism_Sepolia"] = "Optimism_Sepolia";
    Blockchain["Polkadot_Asset_Hub"] = "Polkadot_Asset_Hub";
    Blockchain["Polkadot_Westmint"] = "Polkadot_Westmint";
    Blockchain["Plume"] = "Plume";
    Blockchain["Plume_Testnet"] = "Plume_Testnet";
    Blockchain["Polygon"] = "Polygon";
    Blockchain["Polygon_Amoy_Testnet"] = "Polygon_Amoy_Testnet";
    Blockchain["Sei"] = "Sei";
    Blockchain["Sei_Testnet"] = "Sei_Testnet";
    Blockchain["Solana"] = "Solana";
    Blockchain["Solana_Devnet"] = "Solana_Devnet";
    Blockchain["Sonic"] = "Sonic";
    Blockchain["Sonic_Testnet"] = "Sonic_Testnet";
    Blockchain["Stellar"] = "Stellar";
    Blockchain["Stellar_Testnet"] = "Stellar_Testnet";
    Blockchain["Sui"] = "Sui";
    Blockchain["Sui_Testnet"] = "Sui_Testnet";
    Blockchain["Unichain"] = "Unichain";
    Blockchain["Unichain_Sepolia"] = "Unichain_Sepolia";
    Blockchain["World_Chain"] = "World_Chain";
    Blockchain["World_Chain_Sepolia"] = "World_Chain_Sepolia";
    Blockchain["XDC"] = "XDC";
    Blockchain["XDC_Apothem"] = "XDC_Apothem";
    Blockchain["ZKSync_Era"] = "ZKSync_Era";
    Blockchain["ZKSync_Sepolia"] = "ZKSync_Sepolia";
})(Blockchain || (Blockchain = {}));
// -----------------------------------------------------------------------------
// Bridge Chain Enum (CCTPv2 Supported Chains)
// -----------------------------------------------------------------------------
/**
 * Enumeration of blockchains that support cross-chain bridging via CCTPv2.
 *
 * The enum is derived from the full {@link Blockchain} enum but filtered to only
 * include chains with active CCTPv2 support. When new chains gain CCTPv2 support,
 * they are added to this enum.
 *
 * @enum
 * @category Enums
 *
 * @remarks
 * - This enum is the **canonical source** of bridging-supported chains.
 * - Use this enum (or its string literals) in `kit.bridge()` calls for type safety.
 * - Attempting to use a chain not in this enum will produce a TypeScript compile error.
 *
 * @example
 * ```typescript
 * import { BridgeKit, BridgeChain } from '@circle-fin/bridge-kit'
 *
 * const kit = new BridgeKit()
 *
 * // ✅ Valid - autocomplete suggests only supported chains
 * await kit.bridge({
 *   from: { adapter, chain: BridgeChain.Ethereum },
 *   to: { adapter, chain: BridgeChain.Base },
 *   amount: '100'
 * })
 *
 * // ✅ Also valid - string literals work with autocomplete
 * await kit.bridge({
 *   from: { adapter, chain: 'Ethereum_Sepolia' },
 *   to: { adapter, chain: 'Base_Sepolia' },
 *   amount: '100'
 * })
 *
 * // ❌ Compile error - Algorand is not in BridgeChain
 * await kit.bridge({
 *   from: { adapter, chain: 'Algorand' }, // TypeScript error!
 *   to: { adapter, chain: 'Base' },
 *   amount: '100'
 * })
 * ```
 *
 * @see {@link Blockchain} for the complete list of all known blockchains.
 * @see {@link BridgeChainIdentifier} for the type that accepts these values.
 */
var BridgeChain;
(function (BridgeChain) {
    // Mainnet chains with CCTPv2 support
    BridgeChain["Arbitrum"] = "Arbitrum";
    BridgeChain["Avalanche"] = "Avalanche";
    BridgeChain["Base"] = "Base";
    BridgeChain["Codex"] = "Codex";
    BridgeChain["Ethereum"] = "Ethereum";
    BridgeChain["HyperEVM"] = "HyperEVM";
    BridgeChain["Ink"] = "Ink";
    BridgeChain["Linea"] = "Linea";
    BridgeChain["Monad"] = "Monad";
    BridgeChain["Optimism"] = "Optimism";
    BridgeChain["Plume"] = "Plume";
    BridgeChain["Polygon"] = "Polygon";
    BridgeChain["Sei"] = "Sei";
    BridgeChain["Solana"] = "Solana";
    BridgeChain["Sonic"] = "Sonic";
    BridgeChain["Unichain"] = "Unichain";
    BridgeChain["World_Chain"] = "World_Chain";
    BridgeChain["XDC"] = "XDC";
    // Testnet chains with CCTPv2 support
    BridgeChain["Arc_Testnet"] = "Arc_Testnet";
    BridgeChain["Arbitrum_Sepolia"] = "Arbitrum_Sepolia";
    BridgeChain["Avalanche_Fuji"] = "Avalanche_Fuji";
    BridgeChain["Base_Sepolia"] = "Base_Sepolia";
    BridgeChain["Codex_Testnet"] = "Codex_Testnet";
    BridgeChain["Ethereum_Sepolia"] = "Ethereum_Sepolia";
    BridgeChain["HyperEVM_Testnet"] = "HyperEVM_Testnet";
    BridgeChain["Ink_Testnet"] = "Ink_Testnet";
    BridgeChain["Linea_Sepolia"] = "Linea_Sepolia";
    BridgeChain["Monad_Testnet"] = "Monad_Testnet";
    BridgeChain["Optimism_Sepolia"] = "Optimism_Sepolia";
    BridgeChain["Plume_Testnet"] = "Plume_Testnet";
    BridgeChain["Polygon_Amoy_Testnet"] = "Polygon_Amoy_Testnet";
    BridgeChain["Sei_Testnet"] = "Sei_Testnet";
    BridgeChain["Solana_Devnet"] = "Solana_Devnet";
    BridgeChain["Sonic_Testnet"] = "Sonic_Testnet";
    BridgeChain["Unichain_Sepolia"] = "Unichain_Sepolia";
    BridgeChain["World_Chain_Sepolia"] = "World_Chain_Sepolia";
    BridgeChain["XDC_Apothem"] = "XDC_Apothem";
})(BridgeChain || (BridgeChain = {}));

/**
 * Helper function to define a chain with proper TypeScript typing.
 *
 * This utility function works with TypeScript's `as const` assertion to create
 * strongly-typed, immutable chain definition objects. It preserves literal types
 * from the input and ensures the resulting object maintains all type information.
 *
 * When used with `as const`, it allows TypeScript to infer the most specific
 * possible types for all properties, including string literals and numeric literals,
 * rather than widening them to general types like string or number.
 * @typeParam T - The specific chain definition type (must extend ChainDefinition)
 * @param chain - The chain definition object, typically with an `as const` assertion
 * @returns The same chain definition with preserved literal types
 * @example
 * ```typescript
 * // Define an EVM chain with literal types preserved
 * const Ethereum = defineChain({
 *   type: 'evm',
 *   chain: Blockchain.Ethereum,
 *   chainId: 1,
 *   name: 'Ethereum',
 *   nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
 *   isTestnet: false,
 *   usdcAddress: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
 *   eurcAddress: null,
 *   cctp: {
 *     domain: 0,
 *     contracts: {
 *       TokenMessengerV1: '0xbd3fa81b58ba92a82136038b25adec7066af3155',
 *       MessageTransmitterV1: '0x0a992d191deec32afe36203ad87d7d289a738f81'
 *     }
 *   }
 * } as const);
 * ```
 */
function defineChain(chain) {
    return chain;
}

/**
 * Algorand Mainnet chain definition
 * @remarks
 * This represents the official production network for the Algorand blockchain.
 */
const Algorand = defineChain({
    type: 'algorand',
    chain: Blockchain.Algorand,
    name: 'Algorand',
    title: 'Algorand Mainnet',
    nativeCurrency: {
        name: 'Algo',
        symbol: 'ALGO',
        decimals: 6,
    },
    isTestnet: false,
    explorerUrl: 'https://explorer.perawallet.app/tx/{hash}',
    rpcEndpoints: ['https://mainnet-api.algonode.cloud'],
    eurcAddress: null,
    usdcAddress: '31566704',
    cctp: null,
});

/**
 * Algorand Testnet chain definition
 * @remarks
 * This represents the official testnet for the Algorand blockchain.
 */
const AlgorandTestnet = defineChain({
    type: 'algorand',
    chain: Blockchain.Algorand_Testnet,
    name: 'Algorand Testnet',
    title: 'Algorand Test Network',
    nativeCurrency: {
        name: 'Algo',
        symbol: 'ALGO',
        decimals: 6,
    },
    isTestnet: true,
    explorerUrl: 'https://testnet.explorer.perawallet.app/tx/{hash}',
    rpcEndpoints: ['https://testnet-api.algonode.cloud'],
    eurcAddress: null,
    usdcAddress: '10458941',
    cctp: null,
});

/**
 * Aptos Mainnet chain definition
 * @remarks
 * This represents the official production network for the Aptos blockchain.
 */
const Aptos = defineChain({
    type: 'aptos',
    chain: Blockchain.Aptos,
    name: 'Aptos',
    title: 'Aptos Mainnet',
    nativeCurrency: {
        name: 'Aptos',
        symbol: 'APT',
        decimals: 8,
    },
    isTestnet: false,
    explorerUrl: 'https://explorer.aptoslabs.com/txn/{hash}?network=mainnet',
    rpcEndpoints: ['https://fullnode.mainnet.aptoslabs.com/v1'],
    eurcAddress: null,
    usdcAddress: '0xbae207659db88bea0cbead6da0ed00aac12edcdda169e591cd41c94180b46f3b',
    cctp: {
        domain: 9,
        contracts: {
            v1: {
                type: 'split',
                tokenMessenger: '0x9bce6734f7b63e835108e3bd8c36743d4709fe435f44791918801d0989640a9d',
                messageTransmitter: '0x177e17751820e4b4371873ca8c30279be63bdea63b88ed0f2239c2eea10f1772',
                confirmations: 1,
            },
        },
    },
});

/**
 * Aptos Testnet chain definition
 * @remarks
 * This represents the official test network for the Aptos blockchain.
 */
const AptosTestnet = defineChain({
    type: 'aptos',
    chain: Blockchain.Aptos_Testnet,
    name: 'Aptos Testnet',
    title: 'Aptos Test Network',
    nativeCurrency: {
        name: 'Aptos',
        symbol: 'APT',
        decimals: 8,
    },
    isTestnet: true,
    explorerUrl: 'https://explorer.aptoslabs.com/txn/{hash}?network=testnet',
    rpcEndpoints: ['https://fullnode.testnet.aptoslabs.com/v1'],
    eurcAddress: null,
    usdcAddress: '0x69091fbab5f7d635ee7ac5098cf0c1efbe31d68fec0f2cd565e8d168daf52832',
    cctp: {
        domain: 9,
        contracts: {
            v1: {
                type: 'split',
                tokenMessenger: '0x5f9b937419dda90aa06c1836b7847f65bbbe3f1217567758dc2488be31a477b9',
                messageTransmitter: '0x081e86cebf457a0c6004f35bd648a2794698f52e0dde09a48619dcd3d4cc23d9',
                confirmations: 1,
            },
        },
    },
});

/**
 * The bridge contract address for EVM testnet networks.
 *
 * This contract handles USDC transfers on testnet environments across
 * EVM-compatible chains. Use this address when deploying or testing
 * cross-chain USDC transfers on test networks.
 */
const BRIDGE_CONTRACT_EVM_TESTNET = '0xC5567a5E3370d4DBfB0540025078e283e36A363d';
/**
 * The bridge contract address for EVM mainnet networks.
 *
 * This contract handles USDC transfers on mainnet environments across
 * EVM-compatible chains. Use this address for production cross-chain
 * USDC transfers on live networks.
 */
const BRIDGE_CONTRACT_EVM_MAINNET = '0xB3FA262d0fB521cc93bE83d87b322b8A23DAf3F0';

/**
 * Arc Testnet chain definition
 * @remarks
 * This represents the test network for the Arc blockchain,
 * Circle's EVM-compatible Layer-1 designed for stablecoin finance
 * and asset tokenization. Arc uses USDC as the native gas token and
 * features the Malachite Byzantine Fault Tolerant (BFT) consensus
 * engine for sub-second finality.
 */
const ArcTestnet = defineChain({
    type: 'evm',
    chain: Blockchain.Arc_Testnet,
    name: 'Arc Testnet',
    title: 'ArcTestnet',
    nativeCurrency: {
        name: 'USDC',
        symbol: 'USDC',
        // Arc uses native USDC with 18 decimals for gas payments (EVM standard).
        // Note: The ERC-20 USDC contract at usdcAddress uses 6 decimals.
        // See: https://docs.arc.network/arc/references/contract-addresses
        decimals: 18,
    },
    chainId: 5042002,
    isTestnet: true,
    explorerUrl: 'https://testnet.arcscan.app/tx/{hash}',
    rpcEndpoints: ['https://rpc.testnet.arc.network/'],
    eurcAddress: '0x89B50855Aa3bE2F677cD6303Cec089B5F319D72a',
    usdcAddress: '0x3600000000000000000000000000000000000000',
    cctp: {
        domain: 26,
        contracts: {
            v2: {
                type: 'split',
                tokenMessenger: '0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA',
                messageTransmitter: '0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275',
                confirmations: 1,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_TESTNET,
    },
});

/**
 * Arbitrum Mainnet chain definition
 * @remarks
 * This represents the official production network for the Arbitrum blockchain.
 */
const Arbitrum = defineChain({
    type: 'evm',
    chain: Blockchain.Arbitrum,
    name: 'Arbitrum',
    title: 'Arbitrum Mainnet',
    nativeCurrency: {
        name: 'Ether',
        symbol: 'ETH',
        decimals: 18,
    },
    chainId: 42161,
    isTestnet: false,
    explorerUrl: 'https://arbiscan.io/tx/{hash}',
    rpcEndpoints: ['https://arb1.arbitrum.io/rpc'],
    eurcAddress: null,
    usdcAddress: '0xaf88d065e77c8cc2239327c5edb3a432268e5831',
    cctp: {
        domain: 3,
        contracts: {
            v1: {
                type: 'split',
                tokenMessenger: '0x19330d10D9Cc8751218eaf51E8885D058642E08A',
                messageTransmitter: '0xC30362313FBBA5cf9163F0bb16a0e01f01A896ca',
                confirmations: 65,
            },
            v2: {
                type: 'split',
                tokenMessenger: '0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d',
                messageTransmitter: '0x81D40F21F12A8F0E3252Bccb954D722d4c464B64',
                confirmations: 65,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_MAINNET,
    },
});

/**
 * Arbitrum Sepolia Testnet chain definition
 * @remarks
 * This represents the official test network for the Arbitrum blockchain on Sepolia.
 */
const ArbitrumSepolia = defineChain({
    type: 'evm',
    chain: Blockchain.Arbitrum_Sepolia,
    name: 'Arbitrum Sepolia',
    title: 'Arbitrum Sepolia Testnet',
    nativeCurrency: {
        name: 'Sepolia Ether',
        symbol: 'ETH',
        decimals: 18,
    },
    chainId: 421614,
    isTestnet: true,
    explorerUrl: 'https://sepolia.arbiscan.io/tx/{hash}',
    rpcEndpoints: ['https://sepolia-rollup.arbitrum.io/rpc'],
    eurcAddress: null,
    usdcAddress: '0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d',
    cctp: {
        domain: 3,
        contracts: {
            v1: {
                type: 'split',
                tokenMessenger: '0x9f3B8679c73C2Fef8b59B4f3444d4e156fb70AA5',
                messageTransmitter: '0xaCF1ceeF35caAc005e15888dDb8A3515C41B4872',
                confirmations: 65,
            },
            v2: {
                type: 'split',
                tokenMessenger: '0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA',
                messageTransmitter: '0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275',
                confirmations: 65,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_TESTNET,
    },
});

/**
 * Avalanche Mainnet chain definition
 * @remarks
 * This represents the official production network for the Avalanche blockchain.
 */
const Avalanche = defineChain({
    type: 'evm',
    chain: Blockchain.Avalanche,
    name: 'Avalanche',
    title: 'Avalanche Mainnet',
    nativeCurrency: {
        name: 'Avalanche',
        symbol: 'AVAX',
        decimals: 18,
    },
    chainId: 43114,
    isTestnet: false,
    explorerUrl: 'https://subnets.avax.network/c-chain/tx/{hash}',
    rpcEndpoints: ['https://api.avax.network/ext/bc/C/rpc'],
    eurcAddress: '0xc891eb4cbdeff6e073e859e987815ed1505c2acd',
    usdcAddress: '0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E',
    cctp: {
        domain: 1,
        contracts: {
            v1: {
                type: 'split',
                tokenMessenger: '0x6b25532e1060ce10cc3b0a99e5683b91bfde6982',
                messageTransmitter: '0x8186359af5f57fbb40c6b14a588d2a59c0c29880',
                confirmations: 1,
            },
            v2: {
                type: 'split',
                tokenMessenger: '0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d',
                messageTransmitter: '0x81D40F21F12A8F0E3252Bccb954D722d4c464B64',
                confirmations: 1,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_MAINNET,
    },
});

/**
 * Avalanche Fuji Testnet chain definition
 * @remarks
 * This represents the official test network for the Avalanche blockchain.
 */
const AvalancheFuji = defineChain({
    type: 'evm',
    chain: Blockchain.Avalanche_Fuji,
    name: 'Avalanche Fuji',
    title: 'Avalanche Fuji Testnet',
    nativeCurrency: {
        name: 'Avalanche',
        symbol: 'AVAX',
        decimals: 18,
    },
    chainId: 43113,
    isTestnet: true,
    explorerUrl: 'https://subnets-test.avax.network/c-chain/tx/{hash}',
    eurcAddress: '0x5e44db7996c682e92a960b65ac713a54ad815c6b',
    usdcAddress: '0x5425890298aed601595a70ab815c96711a31bc65',
    cctp: {
        domain: 1,
        contracts: {
            v1: {
                type: 'split',
                tokenMessenger: '0xeb08f243e5d3fcff26a9e38ae5520a669f4019d0',
                messageTransmitter: '0xa9fb1b3009dcb79e2fe346c16a604b8fa8ae0a79',
                confirmations: 1,
            },
            v2: {
                type: 'split',
                tokenMessenger: '0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa',
                messageTransmitter: '0xe737e5cebeeba77efe34d4aa090756590b1ce275',
                confirmations: 1,
                fastConfirmations: 1,
            },
        },
    },
    rpcEndpoints: ['https://api.avax-test.network/ext/bc/C/rpc'],
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_TESTNET,
    },
});

/**
 * Base chain definition
 * @remarks
 * This represents the official production network for the Base blockchain.
 */
const Base = defineChain({
    type: 'evm',
    chain: Blockchain.Base,
    name: 'Base',
    title: 'Base Mainnet',
    nativeCurrency: {
        name: 'Ether',
        symbol: 'ETH',
        decimals: 18,
    },
    chainId: 8453,
    isTestnet: false,
    explorerUrl: 'https://basescan.org/tx/{hash}',
    rpcEndpoints: ['https://mainnet.base.org', 'https://base.publicnode.com'],
    eurcAddress: '0x60a3e35cc302bfa44cb288bc5a4f316fdb1adb42',
    usdcAddress: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',
    cctp: {
        domain: 6,
        contracts: {
            v1: {
                type: 'split',
                tokenMessenger: '0x1682Ae6375C4E4A97e4B583BC394c861A46D8962',
                messageTransmitter: '0xAD09780d193884d503182aD4588450C416D6F9D4',
                confirmations: 65,
            },
            v2: {
                type: 'split',
                tokenMessenger: '0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d',
                messageTransmitter: '0x81D40F21F12A8F0E3252Bccb954D722d4c464B64',
                confirmations: 65,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_MAINNET,
    },
});

/**
 * Base Sepolia Testnet chain definition
 * @remarks
 * This represents the official test network for the Base blockchain on Sepolia.
 */
const BaseSepolia = defineChain({
    type: 'evm',
    chain: Blockchain.Base_Sepolia,
    name: 'Base Sepolia',
    title: 'Base Sepolia Testnet',
    nativeCurrency: {
        name: 'Sepolia Ether',
        symbol: 'ETH',
        decimals: 18,
    },
    chainId: 84532,
    isTestnet: true,
    explorerUrl: 'https://sepolia.basescan.org/tx/{hash}',
    rpcEndpoints: ['https://sepolia.base.org'],
    eurcAddress: '0x808456652fdb597867f38412077A9182bf77359F',
    usdcAddress: '0x036CbD53842c5426634e7929541eC2318f3dCF7e',
    cctp: {
        domain: 6,
        contracts: {
            v1: {
                type: 'split',
                tokenMessenger: '0x9f3B8679c73C2Fef8b59B4f3444d4e156fb70AA5',
                messageTransmitter: '0x7865fAfC2db2093669d92c0F33AeEF291086BEFD',
                confirmations: 65,
            },
            v2: {
                type: 'split',
                tokenMessenger: '0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa',
                messageTransmitter: '0xe737e5cebeeba77efe34d4aa090756590b1ce275',
                confirmations: 65,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_TESTNET,
    },
});

/**
 * Celo Mainnet chain definition
 * @remarks
 * This represents the official production network for the Celo blockchain.
 */
const Celo = defineChain({
    type: 'evm',
    chain: Blockchain.Celo,
    name: 'Celo',
    title: 'Celo Mainnet',
    nativeCurrency: {
        name: 'Celo',
        symbol: 'CELO',
        decimals: 18,
    },
    chainId: 42220,
    isTestnet: false,
    explorerUrl: 'https://celoscan.io/tx/{hash}',
    rpcEndpoints: ['https://forno.celo.org'],
    eurcAddress: null,
    usdcAddress: '0xcebA9300f2b948710d2653dD7B07f33A8B32118C',
    cctp: null,
});

/**
 * Celo Alfajores Testnet chain definition
 * @remarks
 * This represents the official test network for the Celo blockchain.
 */
const CeloAlfajoresTestnet = defineChain({
    type: 'evm',
    chain: Blockchain.Celo_Alfajores_Testnet,
    name: 'Celo Alfajores',
    title: 'Celo Alfajores Testnet',
    nativeCurrency: {
        name: 'Celo',
        symbol: 'CELO',
        decimals: 18,
    },
    chainId: 44787,
    isTestnet: true,
    explorerUrl: 'https://alfajores.celoscan.io/tx/{hash}',
    rpcEndpoints: ['https://alfajores-forno.celo-testnet.org'],
    eurcAddress: null,
    usdcAddress: '0x2F25deB3848C207fc8E0c34035B3Ba7fC157602B',
    cctp: null,
});

/**
 * Codex Mainnet chain definition
 * @remarks
 * This represents the main network for the Codex blockchain.
 */
const Codex = defineChain({
    type: 'evm',
    chain: Blockchain.Codex,
    name: 'Codex Mainnet',
    title: 'Codex Mainnet',
    nativeCurrency: {
        name: 'ETH',
        symbol: 'ETH',
        decimals: 18,
    },
    chainId: 81224,
    isTestnet: false,
    explorerUrl: 'https://explorer.codex.xyz/tx/{hash}',
    rpcEndpoints: ['https://rpc.codex.xyz'],
    eurcAddress: null,
    usdcAddress: '0xd996633a415985DBd7D6D12f4A4343E31f5037cf',
    cctp: {
        domain: 12,
        contracts: {
            v2: {
                type: 'split',
                tokenMessenger: '0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d',
                messageTransmitter: '0x81D40F21F12A8F0E3252Bccb954D722d4c464B64',
                confirmations: 65,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_MAINNET,
    },
});

/**
 * Codex Testnet chain definition
 * @remarks
 * This represents the test network for the Codex blockchain.
 */
const CodexTestnet = defineChain({
    type: 'evm',
    chain: Blockchain.Codex_Testnet,
    name: 'Codex Testnet',
    title: 'Codex Testnet',
    nativeCurrency: {
        name: 'ETH',
        symbol: 'ETH',
        decimals: 18,
    },
    chainId: 812242,
    isTestnet: true,
    explorerUrl: 'https://explorer.codex-stg.xyz/tx/{hash}',
    rpcEndpoints: ['https://rpc.codex-stg.xyz'],
    eurcAddress: null,
    usdcAddress: '0x6d7f141b6819C2c9CC2f818e6ad549E7Ca090F8f',
    cctp: {
        domain: 12,
        contracts: {
            v2: {
                type: 'split',
                tokenMessenger: '0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa',
                messageTransmitter: '0xe737e5cebeeba77efe34d4aa090756590b1ce275',
                confirmations: 65,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_TESTNET,
    },
});

/**
 * Ethereum Mainnet chain definition
 * @remarks
 * This represents the official production network for the Ethereum blockchain.
 */
const Ethereum = defineChain({
    type: 'evm',
    chain: Blockchain.Ethereum,
    name: 'Ethereum',
    title: 'Ethereum Mainnet',
    nativeCurrency: {
        name: 'Ether',
        symbol: 'ETH',
        decimals: 18,
    },
    chainId: 1,
    isTestnet: false,
    explorerUrl: 'https://etherscan.io/tx/{hash}',
    rpcEndpoints: ['https://eth.merkle.io', 'https://ethereum.publicnode.com'],
    eurcAddress: '0x1aBaEA1f7C830bD89Acc67eC4af516284b1bC33c',
    usdcAddress: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
    cctp: {
        domain: 0,
        contracts: {
            v1: {
                type: 'split',
                tokenMessenger: '0xbd3fa81b58ba92a82136038b25adec7066af3155',
                messageTransmitter: '0x0a992d191deec32afe36203ad87d7d289a738f81',
                confirmations: 65,
            },
            v2: {
                type: 'split',
                tokenMessenger: '0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d',
                messageTransmitter: '0x81D40F21F12A8F0E3252Bccb954D722d4c464B64',
                confirmations: 65,
                fastConfirmations: 2,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_MAINNET,
    },
});

/**
 * Ethereum Sepolia Testnet chain definition
 * @remarks
 * This represents the official test network for the Ethereum blockchain on Sepolia.
 */
const EthereumSepolia = defineChain({
    type: 'evm',
    chain: Blockchain.Ethereum_Sepolia,
    name: 'Ethereum Sepolia',
    title: 'Ethereum Sepolia Testnet',
    nativeCurrency: {
        name: 'Sepolia Ether',
        symbol: 'ETH',
        decimals: 18,
    },
    chainId: 11155111,
    isTestnet: true,
    explorerUrl: 'https://sepolia.etherscan.io/tx/{hash}',
    rpcEndpoints: ['https://sepolia.drpc.org'],
    eurcAddress: '0x08210F9170F89Ab7658F0B5E3fF39b0E03C594D4',
    usdcAddress: '0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238',
    cctp: {
        domain: 0,
        contracts: {
            v1: {
                type: 'split',
                tokenMessenger: '0x9f3B8679c73C2Fef8b59B4f3444d4e156fb70AA5',
                messageTransmitter: '0x7865fAfC2db2093669d92c0F33AeEF291086BEFD',
                confirmations: 65,
            },
            v2: {
                type: 'split',
                tokenMessenger: '0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa',
                messageTransmitter: '0xe737e5cebeeba77efe34d4aa090756590b1ce275',
                confirmations: 65,
                fastConfirmations: 2,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_TESTNET,
    },
});

/**
 * Hedera Mainnet chain definition
 * @remarks
 * This represents the official production network for the Hedera blockchain.
 */
const Hedera = defineChain({
    type: 'hedera',
    chain: Blockchain.Hedera,
    name: 'Hedera',
    title: 'Hedera Mainnet',
    nativeCurrency: {
        name: 'HBAR',
        symbol: 'HBAR',
        decimals: 18,
    },
    isTestnet: false,
    explorerUrl: 'https://hashscan.io/mainnet/transaction/{hash}', // Note: Hedera uses `transaction_id`, not hash. Format is typically `0.0.X-YYYY...`.
    rpcEndpoints: ['https://mainnet.hashio.io/api'],
    eurcAddress: null,
    usdcAddress: '0.0.456858',
    cctp: null,
});

/**
 * Hedera Testnet chain definition
 * @remarks
 * This represents the official test network for the Hedera blockchain.
 */
const HederaTestnet = defineChain({
    type: 'hedera',
    chain: Blockchain.Hedera_Testnet,
    name: 'Hedera Testnet',
    title: 'Hedera Test Network',
    nativeCurrency: {
        name: 'HBAR',
        symbol: 'HBAR',
        decimals: 18,
    },
    isTestnet: true,
    explorerUrl: 'https://hashscan.io/testnet/transaction/{hash}', // Note: Hedera uses `transaction_id`, not hash. Format is typically `0.0.X-YYYY...`.
    rpcEndpoints: ['https://testnet.hashio.io/api'],
    eurcAddress: null,
    usdcAddress: '0.0.429274',
    cctp: null,
});

/**
 * HyperEVM Mainnet chain definition
 * @remarks
 * This represents the official production network for the HyperEVM blockchain.
 * HyperEVM is a Layer 1 blockchain specialized for DeFi and trading applications
 * with native orderbook and matching engine.
 */
const HyperEVM = defineChain({
    type: 'evm',
    chain: Blockchain.HyperEVM,
    name: 'HyperEVM',
    title: 'HyperEVM Mainnet',
    nativeCurrency: {
        name: 'Hype',
        symbol: 'HYPE',
        decimals: 18,
    },
    chainId: 999,
    isTestnet: false,
    explorerUrl: 'https://hyperevmscan.io/tx/{hash}',
    rpcEndpoints: ['https://rpc.hyperliquid.xyz/evm'],
    eurcAddress: null,
    usdcAddress: '0xb88339CB7199b77E23DB6E890353E22632Ba630f',
    cctp: {
        domain: 19,
        contracts: {
            v2: {
                type: 'split',
                tokenMessenger: '0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d',
                messageTransmitter: '0x81D40F21F12A8F0E3252Bccb954D722d4c464B64',
                confirmations: 1,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_MAINNET,
    },
});

/**
 * HyperEVM Testnet chain definition
 * @remarks
 * This represents the official testnet for the HyperEVM blockchain.
 * Used for development and testing purposes before deploying to mainnet.
 */
const HyperEVMTestnet = defineChain({
    type: 'evm',
    chain: Blockchain.HyperEVM_Testnet,
    name: 'HyperEVM Testnet',
    title: 'HyperEVM Test Network',
    nativeCurrency: {
        name: 'Hype',
        symbol: 'HYPE',
        decimals: 18,
    },
    chainId: 998,
    isTestnet: true,
    explorerUrl: 'https://testnet.hyperliquid.xyz/explorer/tx/{hash}',
    rpcEndpoints: ['https://rpc.hyperliquid-testnet.xyz/evm'],
    eurcAddress: null,
    usdcAddress: '0x2B3370eE501B4a559b57D449569354196457D8Ab',
    cctp: {
        domain: 19,
        contracts: {
            v2: {
                type: 'split',
                tokenMessenger: '0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA',
                messageTransmitter: '0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275',
                confirmations: 1,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_TESTNET,
    },
});

/**
 * Ink Mainnet chain definition
 * @remarks
 * This represents the official production network for the Ink blockchain.
 * Ink is a Layer 1 blockchain specialized for DeFi and trading applications
 * with native orderbook and matching engine.
 */
const Ink = defineChain({
    type: 'evm',
    chain: Blockchain.Ink,
    name: 'Ink',
    title: 'Ink Mainnet',
    nativeCurrency: {
        name: 'Ether',
        symbol: 'ETH',
        decimals: 18,
    },
    chainId: 57073,
    isTestnet: false,
    explorerUrl: 'https://explorer.inkonchain.com/tx/{hash}',
    rpcEndpoints: [
        'https://rpc-gel.inkonchain.com',
        'https://rpc-qnd.inkonchain.com',
    ],
    eurcAddress: null,
    usdcAddress: '0x2D270e6886d130D724215A266106e6832161EAEd',
    cctp: {
        domain: 21,
        contracts: {
            v2: {
                type: 'split',
                tokenMessenger: '0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d',
                messageTransmitter: '0x81D40F21F12A8F0E3252Bccb954D722d4c464B64',
                confirmations: 65,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_MAINNET,
    },
});

/**
 * Ink Testnet chain definition
 * @remarks
 * This represents the official testnet for the Ink blockchain.
 * Used for development and testing purposes before deploying to mainnet.
 */
const InkTestnet = defineChain({
    type: 'evm',
    chain: Blockchain.Ink_Testnet,
    name: 'Ink Sepolia',
    title: 'Ink Sepolia Testnet',
    nativeCurrency: {
        name: 'Sepolia Ether',
        symbol: 'ETH',
        decimals: 18,
    },
    chainId: 763373,
    isTestnet: true,
    explorerUrl: 'https://explorer-sepolia.inkonchain.com/tx/{hash}',
    rpcEndpoints: [
        'https://rpc-gel-sepolia.inkonchain.com',
        'https://rpc-qnd-sepolia.inkonchain.com',
    ],
    eurcAddress: null,
    usdcAddress: '0xFabab97dCE620294D2B0b0e46C68964e326300Ac',
    cctp: {
        domain: 21,
        contracts: {
            v2: {
                type: 'split',
                tokenMessenger: '0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA',
                messageTransmitter: '0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275',
                confirmations: 65,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_TESTNET,
    },
});

/**
 * Linea Mainnet chain definition
 * @remarks
 * This represents the official production network for the Linea blockchain.
 */
const Linea = defineChain({
    type: 'evm',
    chain: Blockchain.Linea,
    name: 'Linea',
    title: 'Linea Mainnet',
    nativeCurrency: {
        name: 'Ether',
        symbol: 'ETH',
        decimals: 18,
    },
    chainId: 59144,
    isTestnet: false,
    explorerUrl: 'https://lineascan.build/tx/{hash}',
    rpcEndpoints: ['https://rpc.linea.build'],
    eurcAddress: null,
    usdcAddress: '0x176211869ca2b568f2a7d4ee941e073a821ee1ff',
    cctp: {
        domain: 11,
        contracts: {
            v2: {
                type: 'split',
                tokenMessenger: '0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d',
                messageTransmitter: '0x81D40F21F12A8F0E3252Bccb954D722d4c464B64',
                confirmations: 1,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_MAINNET,
    },
});

/**
 * Linea Sepolia Testnet chain definition
 * @remarks
 * This represents the official test network for the Linea blockchain on Sepolia.
 */
const LineaSepolia = defineChain({
    type: 'evm',
    chain: Blockchain.Linea_Sepolia,
    name: 'Linea Sepolia',
    title: 'Linea Sepolia Testnet',
    nativeCurrency: {
        name: 'Sepolia Ether',
        symbol: 'ETH',
        decimals: 18,
    },
    chainId: 59141,
    isTestnet: true,
    explorerUrl: 'https://sepolia.lineascan.build/tx/{hash}',
    rpcEndpoints: ['https://rpc.sepolia.linea.build'],
    eurcAddress: null,
    usdcAddress: '0xfece4462d57bd51a6a552365a011b95f0e16d9b7',
    cctp: {
        domain: 11,
        contracts: {
            v2: {
                type: 'split',
                tokenMessenger: '0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa',
                messageTransmitter: '0xe737e5cebeeba77efe34d4aa090756590b1ce275',
                confirmations: 1,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_TESTNET,
    },
});

/**
 * Monad Mainnet chain definition
 * @remarks
 * This represents the official production network for the Monad blockchain.
 * Monad is a high-performance EVM-compatible Layer-1 blockchain featuring
 * over 10,000 TPS, sub-second finality, and near-zero gas fees.
 */
const Monad = defineChain({
    type: 'evm',
    chain: Blockchain.Monad,
    name: 'Monad',
    title: 'Monad Mainnet',
    nativeCurrency: {
        name: 'Monad',
        symbol: 'MON',
        decimals: 18,
    },
    chainId: 143,
    isTestnet: false,
    explorerUrl: 'https://monadscan.com/tx/{hash}',
    rpcEndpoints: ['https://rpc.monad.xyz'],
    eurcAddress: null,
    usdcAddress: '0x754704Bc059F8C67012fEd69BC8A327a5aafb603',
    cctp: {
        domain: 15,
        contracts: {
            v2: {
                type: 'split',
                tokenMessenger: '0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d',
                messageTransmitter: '0x81D40F21F12A8F0E3252Bccb954D722d4c464B64',
                confirmations: 1,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_MAINNET,
    },
});

/**
 * Monad Testnet chain definition
 * @remarks
 * This represents the official test network for the Monad blockchain.
 * Monad is a high-performance EVM-compatible Layer-1 blockchain featuring
 * over 10,000 TPS, sub-second finality, and near-zero gas fees.
 */
const MonadTestnet = defineChain({
    type: 'evm',
    chain: Blockchain.Monad_Testnet,
    name: 'Monad Testnet',
    title: 'Monad Testnet',
    nativeCurrency: {
        name: 'Monad',
        symbol: 'MON',
        decimals: 18,
    },
    chainId: 10143,
    isTestnet: true,
    explorerUrl: 'https://testnet.monadscan.com/tx/{hash}',
    rpcEndpoints: ['https://testnet-rpc.monad.xyz'],
    eurcAddress: null,
    usdcAddress: '0x534b2f3A21130d7a60830c2Df862319e593943A3',
    cctp: {
        domain: 15,
        contracts: {
            v2: {
                type: 'split',
                tokenMessenger: '0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA',
                messageTransmitter: '0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275',
                confirmations: 1,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_TESTNET,
    },
});

/**
 * NEAR Protocol Mainnet chain definition
 * @remarks
 * This represents the official production network for the NEAR Protocol blockchain.
 */
const NEAR = defineChain({
    type: 'near',
    chain: Blockchain.NEAR,
    name: 'NEAR Protocol',
    title: 'NEAR Mainnet',
    nativeCurrency: {
        name: 'NEAR',
        symbol: 'NEAR',
        decimals: 24,
    },
    isTestnet: false,
    explorerUrl: 'https://nearblocks.io/txns/{hash}',
    rpcEndpoints: ['https://eth-rpc.mainnet.near.org'],
    eurcAddress: null,
    usdcAddress: '17208628f84f5d6ad33f0da3bbbeb27ffcb398eac501a31bd6ad2011e36133a1',
    cctp: null,
});

/**
 * NEAR Testnet chain definition
 * @remarks
 * This represents the official test network for the NEAR Protocol blockchain.
 */
const NEARTestnet = defineChain({
    type: 'near',
    chain: Blockchain.NEAR_Testnet,
    name: 'NEAR Protocol Testnet',
    title: 'NEAR Test Network',
    nativeCurrency: {
        name: 'NEAR',
        symbol: 'NEAR',
        decimals: 24,
    },
    isTestnet: true,
    explorerUrl: 'https://testnet.nearblocks.io/txns/{hash}',
    rpcEndpoints: ['https://eth-rpc.testnet.near.org'],
    eurcAddress: null,
    usdcAddress: '3e2210e1184b45b64c8a434c0a7e7b23cc04ea7eb7a6c3c32520d03d4afcb8af',
    cctp: null,
});

/**
 * Noble Mainnet chain definition
 * @remarks
 * This represents the official production network for the Noble blockchain.
 */
const Noble = defineChain({
    type: 'noble',
    chain: Blockchain.Noble,
    name: 'Noble',
    title: 'Noble Mainnet',
    nativeCurrency: {
        name: 'Noble USDC',
        symbol: 'USDC',
        decimals: 6,
    },
    isTestnet: false,
    explorerUrl: 'https://www.mintscan.io/noble/tx/{hash}',
    rpcEndpoints: ['https://noble-rpc.polkachu.com'],
    eurcAddress: null,
    usdcAddress: 'uusdc',
    cctp: {
        domain: 4,
        contracts: {
            v1: {
                type: 'merged',
                contract: 'noble12l2w4ugfz4m6dd73yysz477jszqnfughxvkss5',
                confirmations: 1,
            },
        },
    },
});

/**
 * Noble Testnet chain definition
 * @remarks
 * This represents the official test network for the Noble blockchain.
 */
const NobleTestnet = defineChain({
    type: 'noble',
    chain: Blockchain.Noble_Testnet,
    name: 'Noble Testnet',
    title: 'Noble Test Network',
    nativeCurrency: {
        name: 'Noble USDC',
        symbol: 'USDC',
        decimals: 6,
    },
    isTestnet: true,
    explorerUrl: 'https://www.mintscan.io/noble-testnet/tx/{hash}',
    rpcEndpoints: ['https://noble-testnet-rpc.polkachu.com'],
    eurcAddress: null,
    usdcAddress: 'uusdc',
    cctp: {
        domain: 4,
        contracts: {
            v1: {
                type: 'merged',
                contract: 'noble12l2w4ugfz4m6dd73yysz477jszqnfughxvkss5',
                confirmations: 1,
            },
        },
    },
});

/**
 * Optimism Mainnet chain definition
 * @remarks
 * This represents the official production network for the Optimism blockchain.
 */
const Optimism = defineChain({
    type: 'evm',
    chain: Blockchain.Optimism,
    name: 'Optimism',
    title: 'Optimism Mainnet',
    nativeCurrency: {
        name: 'Ether',
        symbol: 'ETH',
        decimals: 18,
    },
    chainId: 10,
    isTestnet: false,
    explorerUrl: 'https://optimistic.etherscan.io/tx/{hash}',
    rpcEndpoints: ['https://mainnet.optimism.io'],
    eurcAddress: null,
    usdcAddress: '0x0b2c639c533813f4aa9d7837caf62653d097ff85',
    cctp: {
        domain: 2,
        contracts: {
            v1: {
                type: 'split',
                tokenMessenger: '0x2B4069517957735bE00ceE0fadAE88a26365528f',
                messageTransmitter: '0x0a992d191deec32afe36203ad87d7d289a738f81',
                confirmations: 65,
            },
            v2: {
                type: 'split',
                tokenMessenger: '0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d',
                messageTransmitter: '0x81D40F21F12A8F0E3252Bccb954D722d4c464B64',
                confirmations: 65,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_MAINNET,
    },
});

/**
 * Optimism Sepolia Testnet chain definition
 * @remarks
 * This represents the official test network for the Optimism blockchain on Sepolia.
 */
const OptimismSepolia = defineChain({
    type: 'evm',
    chain: Blockchain.Optimism_Sepolia,
    name: 'Optimism Sepolia',
    title: 'Optimism Sepolia Testnet',
    nativeCurrency: {
        name: 'Sepolia Ether',
        symbol: 'ETH',
        decimals: 18,
    },
    chainId: 11155420,
    isTestnet: true,
    explorerUrl: 'https://sepolia-optimistic.etherscan.io/tx/{hash}',
    rpcEndpoints: ['https://sepolia.optimism.io'],
    eurcAddress: null,
    usdcAddress: '0x5fd84259d66Cd46123540766Be93DFE6D43130D7',
    cctp: {
        domain: 2,
        contracts: {
            v1: {
                type: 'split',
                tokenMessenger: '0x9f3B8679c73C2Fef8b59B4f3444d4e156fb70AA5',
                messageTransmitter: '0x7865fAfC2db2093669d92c0F33AeEF291086BEFD',
                confirmations: 65,
            },
            v2: {
                type: 'split',
                tokenMessenger: '0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa',
                messageTransmitter: '0xe737e5cebeeba77efe34d4aa090756590b1ce275',
                confirmations: 65,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_TESTNET,
    },
});

/**
 * Plume Mainnet chain definition
 * @remarks
 * This represents the official production network for the Plume blockchain.
 * Plume is a Layer 1 blockchain specialized for DeFi and trading applications
 * with native orderbook and matching engine.
 */
const Plume = defineChain({
    type: 'evm',
    chain: Blockchain.Plume,
    name: 'Plume',
    title: 'Plume Mainnet',
    nativeCurrency: {
        name: 'Plume',
        symbol: 'PLUME',
        decimals: 18,
    },
    chainId: 98866,
    isTestnet: false,
    explorerUrl: 'https://explorer.plume.org/tx/{hash}',
    rpcEndpoints: ['https://rpc.plume.org'],
    eurcAddress: null,
    usdcAddress: '0x222365EF19F7947e5484218551B56bb3965Aa7aF',
    cctp: {
        domain: 22,
        contracts: {
            v2: {
                type: 'split',
                tokenMessenger: '0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d',
                messageTransmitter: '0x81D40F21F12A8F0E3252Bccb954D722d4c464B64',
                confirmations: 65,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_MAINNET,
    },
});

/**
 * Plume Testnet chain definition
 * @remarks
 * This represents the official testnet for the Plume blockchain.
 * Used for development and testing purposes before deploying to mainnet.
 */
const PlumeTestnet = defineChain({
    type: 'evm',
    chain: Blockchain.Plume_Testnet,
    name: 'Plume Testnet',
    title: 'Plume Test Network',
    nativeCurrency: {
        name: 'Plume',
        symbol: 'PLUME',
        decimals: 18,
    },
    chainId: 98867,
    isTestnet: true,
    explorerUrl: 'https://testnet-explorer.plume.org/tx/{hash}',
    rpcEndpoints: ['https://testnet-rpc.plume.org'],
    eurcAddress: null,
    usdcAddress: '0xcB5f30e335672893c7eb944B374c196392C19D18',
    cctp: {
        domain: 22,
        contracts: {
            v2: {
                type: 'split',
                tokenMessenger: '0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA',
                messageTransmitter: '0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275',
                confirmations: 65,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_TESTNET,
    },
});

/**
 * Polkadot Asset Hub chain definition
 * @remarks
 * This represents the official asset management parachain for the Polkadot blockchain.
 */
const PolkadotAssetHub = defineChain({
    type: 'polkadot',
    chain: Blockchain.Polkadot_Asset_Hub,
    name: 'Polkadot Asset Hub',
    title: 'Polkadot Asset Hub',
    nativeCurrency: {
        name: 'Polkadot',
        symbol: 'DOT',
        decimals: 10,
    },
    isTestnet: false,
    explorerUrl: 'https://polkadot.subscan.io/extrinsic/{hash}',
    rpcEndpoints: ['https://asset-hub-polkadot-rpc.n.dwellir.com'],
    eurcAddress: null,
    usdcAddress: '1337',
    cctp: null,
});

/**
 * Polkadot Westmint chain definition
 * @remarks
 * This represents an asset management parachain in the Polkadot ecosystem.
 */
const PolkadotWestmint = defineChain({
    type: 'polkadot',
    chain: Blockchain.Polkadot_Westmint,
    name: 'Polkadot Westmint',
    title: 'Polkadot Westmint',
    nativeCurrency: {
        name: 'Polkadot',
        symbol: 'DOT',
        decimals: 10,
    },
    isTestnet: false,
    explorerUrl: 'https://assethub-polkadot.subscan.io/extrinsic/{hash}',
    rpcEndpoints: ['https://westmint-rpc.polkadot.io'],
    eurcAddress: null,
    usdcAddress: 'Asset ID 31337',
    cctp: null,
});

/**
 * Polygon Mainnet chain definition
 * @remarks
 * This represents the official production network for the Polygon blockchain.
 */
const Polygon = defineChain({
    type: 'evm',
    chain: Blockchain.Polygon,
    name: 'Polygon',
    title: 'Polygon Mainnet',
    nativeCurrency: {
        name: 'POL',
        symbol: 'POL',
        decimals: 18,
    },
    chainId: 137,
    isTestnet: false,
    explorerUrl: 'https://polygonscan.com/tx/{hash}',
    rpcEndpoints: ['https://polygon-rpc.com', 'https://polygon.publicnode.com'],
    eurcAddress: null,
    usdcAddress: '0x3c499c542cef5e3811e1192ce70d8cc03d5c3359',
    cctp: {
        domain: 7,
        contracts: {
            v1: {
                type: 'split',
                tokenMessenger: '0x9daF8c91AEFAE50b9c0E69629D3F6Ca40cA3B3FE',
                messageTransmitter: '0xF3be9355363857F3e001be68856A2f96b4C39Ba9',
                confirmations: 200,
            },
            v2: {
                type: 'split',
                tokenMessenger: '0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d',
                messageTransmitter: '0x81D40F21F12A8F0E3252Bccb954D722d4c464B64',
                confirmations: 33,
                fastConfirmations: 13,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_MAINNET,
    },
});

/**
 * Polygon Amoy Testnet chain definition
 * @remarks
 * This represents the official test network for the Polygon blockchain.
 */
const PolygonAmoy = defineChain({
    type: 'evm',
    chain: Blockchain.Polygon_Amoy_Testnet,
    name: 'Polygon Amoy',
    title: 'Polygon Amoy Testnet',
    nativeCurrency: {
        name: 'POL',
        symbol: 'POL',
        decimals: 18,
    },
    chainId: 80002,
    isTestnet: true,
    explorerUrl: 'https://amoy.polygonscan.com/tx/{hash}',
    rpcEndpoints: ['https://rpc-amoy.polygon.technology'],
    eurcAddress: null,
    usdcAddress: '0x41e94eb019c0762f9bfcf9fb1e58725bfb0e7582',
    cctp: {
        domain: 7,
        contracts: {
            v1: {
                type: 'split',
                tokenMessenger: '0x9f3B8679c73C2Fef8b59B4f3444d4e156fb70AA5',
                messageTransmitter: '0x7865fAfC2db2093669d92c0F33AeEF291086BEFD',
                confirmations: 200,
            },
            v2: {
                type: 'split',
                tokenMessenger: '0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA',
                messageTransmitter: '0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275',
                confirmations: 33,
                fastConfirmations: 13,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_TESTNET,
    },
});

/**
 * Sei Mainnet chain definition
 * @remarks
 * This represents the official production network for the Sei blockchain.
 * Sei is a Layer 1 blockchain specialized for DeFi and trading applications
 * with native orderbook and matching engine.
 */
const Sei = defineChain({
    type: 'evm',
    chain: Blockchain.Sei,
    name: 'Sei',
    title: 'Sei Mainnet',
    nativeCurrency: {
        name: 'Sei',
        symbol: 'SEI',
        decimals: 18,
    },
    chainId: 1329,
    isTestnet: false,
    explorerUrl: 'https://seitrace.com/tx/{hash}?chain=pacific-1',
    rpcEndpoints: ['https://evm-rpc.sei-apis.com'],
    eurcAddress: null,
    usdcAddress: '0xe15fC38F6D8c56aF07bbCBe3BAf5708A2Bf42392',
    cctp: {
        domain: 16,
        contracts: {
            v2: {
                type: 'split',
                tokenMessenger: '0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d',
                messageTransmitter: '0x81D40F21F12A8F0E3252Bccb954D722d4c464B64',
                confirmations: 1,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_MAINNET,
    },
});

/**
 * Sei Testnet chain definition
 * @remarks
 * This represents the official testnet for the Sei blockchain.
 * Used for development and testing purposes before deploying to mainnet.
 */
const SeiTestnet = defineChain({
    type: 'evm',
    chain: Blockchain.Sei_Testnet,
    name: 'Sei Testnet',
    title: 'Sei Test Network',
    nativeCurrency: {
        name: 'Sei',
        symbol: 'SEI',
        decimals: 18,
    },
    chainId: 1328,
    isTestnet: true,
    explorerUrl: 'https://seitrace.com/tx/{hash}?chain=atlantic-2',
    rpcEndpoints: ['https://evm-rpc-testnet.sei-apis.com'],
    eurcAddress: null,
    usdcAddress: '0x4fCF1784B31630811181f670Aea7A7bEF803eaED',
    cctp: {
        domain: 16,
        contracts: {
            v2: {
                type: 'split',
                tokenMessenger: '0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA',
                messageTransmitter: '0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275',
                confirmations: 1,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_TESTNET,
    },
});

/**
 * Sonic Mainnet chain definition
 * @remarks
 * This represents the official production network for the Sonic blockchain.
 */
const Sonic = defineChain({
    type: 'evm',
    chain: Blockchain.Sonic,
    name: 'Sonic',
    title: 'Sonic Mainnet',
    nativeCurrency: {
        name: 'Sonic',
        symbol: 'S',
        decimals: 18,
    },
    chainId: 146,
    isTestnet: false,
    explorerUrl: 'https://sonicscan.org/tx/{hash}',
    rpcEndpoints: ['https://rpc.soniclabs.com'],
    eurcAddress: null,
    usdcAddress: '0x29219dd400f2Bf60E5a23d13Be72B486D4038894',
    cctp: {
        domain: 13,
        contracts: {
            v2: {
                type: 'split',
                tokenMessenger: '0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d',
                messageTransmitter: '0x81D40F21F12A8F0E3252Bccb954D722d4c464B64',
                confirmations: 1,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_MAINNET,
    },
});

/**
 * Sonic Testnet chain definition
 * @remarks
 * This represents the official test network for the Sonic blockchain.
 */
const SonicTestnet = defineChain({
    type: 'evm',
    chain: Blockchain.Sonic_Testnet,
    name: 'Sonic Testnet',
    title: 'Sonic Testnet',
    nativeCurrency: {
        name: 'Sonic',
        symbol: 'S',
        decimals: 18,
    },
    chainId: 14601,
    isTestnet: true,
    explorerUrl: 'https://testnet.sonicscan.org/tx/{hash}',
    rpcEndpoints: ['https://rpc.testnet.soniclabs.com'],
    eurcAddress: null,
    usdcAddress: '0x0BA304580ee7c9a980CF72e55f5Ed2E9fd30Bc51',
    cctp: {
        domain: 13,
        contracts: {
            v2: {
                type: 'split',
                tokenMessenger: '0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA',
                messageTransmitter: '0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275',
                confirmations: 1,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_TESTNET,
    },
});

/**
 * Solana Mainnet chain definition
 * @remarks
 * This represents the official production network for the Solana blockchain.
 */
const Solana = defineChain({
    type: 'solana',
    chain: Blockchain.Solana,
    name: 'Solana',
    title: 'Solana Mainnet',
    nativeCurrency: {
        name: 'Solana',
        symbol: 'SOL',
        decimals: 9,
    },
    isTestnet: false,
    explorerUrl: 'https://solscan.io/tx/{hash}',
    rpcEndpoints: ['https://api.mainnet-beta.solana.com'],
    eurcAddress: 'HzwqbKZw8HxMN6bF2yFZNrht3c2iXXzpKcFu7uBEDKtr',
    usdcAddress: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    cctp: {
        domain: 5,
        contracts: {
            v1: {
                type: 'split',
                tokenMessenger: 'CCTPiPYPc6AsJuwueEnWgSgucamXDZwBd53dQ11YiKX3',
                messageTransmitter: 'CCTPmbSD7gX1bxKPAmg77w8oFzNFpaQiQUWD43TKaecd',
                confirmations: 32,
            },
            v2: {
                type: 'split',
                tokenMessenger: 'CCTPV2vPZJS2u2BBsUoscuikbYjnpFmbFsvVuJdgUMQe',
                messageTransmitter: 'CCTPV2Sm4AdWt5296sk4P66VBZ7bEhcARwFaaS9YPbeC',
                confirmations: 32,
                fastConfirmations: 3,
            },
        },
    },
    kitContracts: {
        bridge: 'DFaauJEjmiHkPs1JG89A4p95hDWi9m9SAEERY1LQJiC3',
    },
});

/**
 * Solana Devnet chain definition
 * @remarks
 * This represents the development test network for the Solana blockchain.
 */
const SolanaDevnet = defineChain({
    type: 'solana',
    chain: Blockchain.Solana_Devnet,
    name: 'Solana Devnet',
    title: 'Solana Development Network',
    nativeCurrency: {
        name: 'Solana',
        symbol: 'SOL',
        decimals: 9,
    },
    isTestnet: true,
    explorerUrl: 'https://solscan.io/tx/{hash}?cluster=devnet',
    eurcAddress: 'HzwqbKZw8HxMN6bF2yFZNrht3c2iXXzpKcFu7uBEDKtr',
    usdcAddress: '4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU',
    cctp: {
        domain: 5,
        contracts: {
            v1: {
                type: 'split',
                tokenMessenger: 'CCTPiPYPc6AsJuwueEnWgSgucamXDZwBd53dQ11YiKX3',
                messageTransmitter: 'CCTPmbSD7gX1bxKPAmg77w8oFzNFpaQiQUWD43TKaecd',
                confirmations: 32,
            },
            v2: {
                type: 'split',
                tokenMessenger: 'CCTPV2vPZJS2u2BBsUoscuikbYjnpFmbFsvVuJdgUMQe',
                messageTransmitter: 'CCTPV2Sm4AdWt5296sk4P66VBZ7bEhcARwFaaS9YPbeC',
                confirmations: 32,
                fastConfirmations: 3,
            },
        },
    },
    kitContracts: {
        bridge: 'DFaauJEjmiHkPs1JG89A4p95hDWi9m9SAEERY1LQJiC3',
    },
    rpcEndpoints: ['https://api.devnet.solana.com'],
});

/**
 * Stellar Mainnet chain definition
 * @remarks
 * This represents the official production network for the Stellar blockchain.
 */
const Stellar = defineChain({
    type: 'stellar',
    chain: Blockchain.Stellar,
    name: 'Stellar',
    title: 'Stellar Mainnet',
    nativeCurrency: {
        name: 'Stellar Lumens',
        symbol: 'XLM',
        decimals: 7,
    },
    isTestnet: false,
    explorerUrl: 'https://stellar.expert/explorer/public/tx/{hash}',
    rpcEndpoints: ['https://horizon.stellar.org'],
    eurcAddress: 'EURC-GDHU6WRG4IEQXM5NZ4BMPKOXHW76MZM4Y2IEMFDVXBSDP6SJY4ITNPP2',
    usdcAddress: 'USDC-GA5ZSEJYB37JRC5AVCIA5MOP4RHTM335X2KGX3IHOJAPP5RE34K4KZVN',
    cctp: null,
});

/**
 * Stellar Testnet chain definition
 * @remarks
 * This represents the official test network for the Stellar blockchain.
 */
const StellarTestnet = defineChain({
    type: 'stellar',
    chain: Blockchain.Stellar_Testnet,
    name: 'Stellar Testnet',
    title: 'Stellar Test Network',
    nativeCurrency: {
        name: 'Stellar Lumens',
        symbol: 'XLM',
        decimals: 7,
    },
    isTestnet: true,
    explorerUrl: 'https://stellar.expert/explorer/testnet/tx/{hash}',
    rpcEndpoints: ['https://horizon-testnet.stellar.org'],
    eurcAddress: 'EURC-GB3Q6QDZYTHWT7E5PVS3W7FUT5GVAFC5KSZFFLPU25GO7VTC3NM2ZTVO',
    usdcAddress: 'USDC-GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5',
    cctp: null,
});

/**
 * Sui Mainnet chain definition
 * @remarks
 * This represents the official production network for the Sui blockchain.
 */
const Sui = defineChain({
    type: 'sui',
    chain: Blockchain.Sui,
    name: 'Sui',
    title: 'Sui Mainnet',
    nativeCurrency: {
        name: 'Sui',
        symbol: 'SUI',
        decimals: 9,
    },
    isTestnet: false,
    explorerUrl: 'https://suiscan.xyz/mainnet/tx/{hash}',
    rpcEndpoints: ['https://fullnode.mainnet.sui.io'],
    eurcAddress: null,
    usdcAddress: '0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC',
    cctp: {
        domain: 8,
        contracts: {
            v1: {
                type: 'split',
                tokenMessenger: '0x2aa6c5d56376c371f88a6cc42e852824994993cb9bab8d3e6450cbe3cb32b94e',
                messageTransmitter: '0x08d87d37ba49e785dde270a83f8e979605b03dc552b5548f26fdf2f49bf7ed1b',
                confirmations: 1,
            },
        },
    },
});

/**
 * Sui Testnet chain definition
 * @remarks
 * This represents the official test network for the Sui blockchain.
 */
const SuiTestnet = defineChain({
    type: 'sui',
    chain: Blockchain.Sui_Testnet,
    name: 'Sui Testnet',
    title: 'Sui Test Network',
    nativeCurrency: {
        name: 'Sui',
        symbol: 'SUI',
        decimals: 9,
    },
    isTestnet: true,
    explorerUrl: 'https://suiscan.xyz/testnet/tx/{hash}',
    rpcEndpoints: ['https://fullnode.testnet.sui.io'],
    eurcAddress: null,
    usdcAddress: '0xa1ec7fc00a6f40db9693ad1415d0c193ad3906494428cf252621037bd7117e29::usdc::USDC',
    cctp: {
        domain: 8,
        contracts: {
            v1: {
                type: 'split',
                tokenMessenger: '0x31cc14d80c175ae39777c0238f20594c6d4869cfab199f40b69f3319956b8beb',
                messageTransmitter: '0x4931e06dce648b3931f890035bd196920770e913e43e45990b383f6486fdd0a5',
                confirmations: 1,
            },
        },
    },
});

/**
 * Unichain Mainnet chain definition
 * @remarks
 * This represents the official production network for the Unichain blockchain.
 */
const Unichain = defineChain({
    type: 'evm',
    chain: Blockchain.Unichain,
    name: 'Unichain',
    title: 'Unichain Mainnet',
    nativeCurrency: {
        name: 'Uni',
        symbol: 'UNI',
        decimals: 18,
    },
    chainId: 130,
    isTestnet: false,
    explorerUrl: 'https://unichain.blockscout.com/tx/{hash}',
    rpcEndpoints: ['https://rpc.unichain.org', 'https://mainnet.unichain.org'],
    eurcAddress: null,
    usdcAddress: '0x078D782b760474a361dDA0AF3839290b0EF57AD6',
    cctp: {
        domain: 10,
        contracts: {
            v1: {
                type: 'split',
                tokenMessenger: '0x4e744b28E787c3aD0e810eD65A24461D4ac5a762',
                messageTransmitter: '0x353bE9E2E38AB1D19104534e4edC21c643Df86f4',
                confirmations: 65,
            },
            v2: {
                type: 'split',
                tokenMessenger: '0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d',
                messageTransmitter: '0x81D40F21F12A8F0E3252Bccb954D722d4c464B64',
                confirmations: 65,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_MAINNET,
    },
});

/**
 * Unichain Sepolia Testnet chain definition
 * @remarks
 * This represents the official test network for the Unichain blockchain.
 */
const UnichainSepolia = defineChain({
    type: 'evm',
    chain: Blockchain.Unichain_Sepolia,
    name: 'Unichain Sepolia',
    title: 'Unichain Sepolia Testnet',
    nativeCurrency: {
        name: 'Sepolia Uni',
        symbol: 'UNI',
        decimals: 18,
    },
    chainId: 1301,
    isTestnet: true,
    explorerUrl: 'https://unichain-sepolia.blockscout.com/tx/{hash}',
    rpcEndpoints: ['https://sepolia.unichain.org'],
    eurcAddress: null,
    usdcAddress: '0x31d0220469e10c4E71834a79b1f276d740d3768F',
    cctp: {
        domain: 10,
        contracts: {
            v1: {
                type: 'split',
                tokenMessenger: '0x8ed94B8dAd2Dc5453862ea5e316A8e71AAed9782',
                messageTransmitter: '0xbc498c326533d675cf571B90A2Ced265ACb7d086',
                confirmations: 65,
            },
            v2: {
                type: 'split',
                tokenMessenger: '0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA',
                messageTransmitter: '0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275',
                confirmations: 65,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_TESTNET,
    },
});

/**
 * World Chain chain definition
 * @remarks
 * This represents the main network for the World Chain blockchain.
 */
const WorldChain = defineChain({
    type: 'evm',
    chain: Blockchain.World_Chain,
    name: 'World Chain',
    title: 'World Chain',
    nativeCurrency: {
        name: 'Ether',
        symbol: 'ETH',
        decimals: 18,
    },
    chainId: 480,
    isTestnet: false,
    explorerUrl: 'https://worldscan.org/tx/{hash}',
    rpcEndpoints: ['https://worldchain-mainnet.g.alchemy.com/public'],
    eurcAddress: null,
    usdcAddress: '0x79A02482A880bCe3F13E09da970dC34dB4cD24D1',
    cctp: {
        domain: 14,
        contracts: {
            v2: {
                type: 'split',
                tokenMessenger: '0x28b5a0e9C621a5BadaA536219b3a228C8168cF5d',
                messageTransmitter: '0x81D40F21F12A8F0E3252Bccb954D722d4c464B64',
                confirmations: 65,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_MAINNET,
    },
});

/**
 * World Chain Sepolia chain definition
 * @remarks
 * This represents the test network for the World Chain blockchain.
 */
const WorldChainSepolia = defineChain({
    type: 'evm',
    chain: Blockchain.World_Chain_Sepolia,
    name: 'World Chain Sepolia',
    title: 'World Chain Sepolia',
    nativeCurrency: {
        name: 'Ether',
        symbol: 'ETH',
        decimals: 18,
    },
    chainId: 4801,
    isTestnet: true,
    explorerUrl: 'https://sepolia.worldscan.org/tx/{hash}',
    rpcEndpoints: [
        'https://worldchain-sepolia.drpc.org',
        'https://worldchain-sepolia.g.alchemy.com/public',
    ],
    eurcAddress: null,
    usdcAddress: '0x66145f38cBAC35Ca6F1Dfb4914dF98F1614aeA88',
    cctp: {
        domain: 14,
        contracts: {
            v2: {
                type: 'split',
                tokenMessenger: '0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa',
                messageTransmitter: '0xe737e5cebeeba77efe34d4aa090756590b1ce275',
                confirmations: 65,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_TESTNET,
    },
});

/**
 * XDC Mainnet chain definition
 * @remarks
 * This represents the official production network for the XDC blockchain.
 * XDC is a Layer 1 blockchain specialized for DeFi and trading applications
 * with native orderbook and matching engine.
 */
const XDC = defineChain({
    type: 'evm',
    chain: Blockchain.XDC,
    name: 'XDC',
    title: 'XDC Mainnet',
    nativeCurrency: {
        name: 'XDC',
        symbol: 'XDC',
        decimals: 18,
    },
    chainId: 50,
    isTestnet: false,
    explorerUrl: 'https://xdcscan.io/tx/{hash}',
    rpcEndpoints: ['https://erpc.xinfin.network'],
    eurcAddress: null,
    usdcAddress: '0xfA2958CB79b0491CC627c1557F441eF849Ca8eb1',
    cctp: {
        domain: 18,
        contracts: {
            v2: {
                type: 'split',
                tokenMessenger: '0x28b5a0e9C621a5BadaA536219b3a228C8168cf5d',
                messageTransmitter: '0x81D40F21F12A8F0E3252Bccb954D722d4c464B64',
                confirmations: 3,
                fastConfirmations: 3,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_MAINNET,
    },
});

/**
 * XDC Apothem Testnet chain definition
 * @remarks
 * This represents the official test network for the XDC Network, known as Apothem.
 */
const XDCApothem = defineChain({
    type: 'evm',
    chain: Blockchain.XDC_Apothem,
    name: 'Apothem Network',
    title: 'Apothem Network',
    nativeCurrency: {
        name: 'TXDC',
        symbol: 'TXDC',
        decimals: 18,
    },
    chainId: 51,
    isTestnet: true,
    explorerUrl: 'https://testnet.xdcscan.com/tx/{hash}',
    rpcEndpoints: ['https://erpc.apothem.network'],
    eurcAddress: null,
    usdcAddress: '0xb5AB69F7bBada22B28e79C8FFAECe55eF1c771D4',
    cctp: {
        domain: 18,
        contracts: {
            v2: {
                type: 'split',
                tokenMessenger: '0x8FE6B999Dc680CcFDD5Bf7EB0974218be2542DAA',
                messageTransmitter: '0xE737e5cEBEEBa77EFE34D4aa090756590b1CE275',
                confirmations: 3,
                fastConfirmations: 1,
            },
        },
    },
    kitContracts: {
        bridge: BRIDGE_CONTRACT_EVM_TESTNET,
    },
});

/**
 * ZKSync Era Mainnet chain definition
 * @remarks
 * This represents the official production network for the ZKSync Era blockchain.
 */
const ZKSyncEra = defineChain({
    type: 'evm',
    chain: Blockchain.ZKSync_Era,
    name: 'ZKSync Era',
    title: 'ZKSync Era Mainnet',
    nativeCurrency: {
        name: 'Ether',
        symbol: 'ETH',
        decimals: 18,
    },
    chainId: 324,
    isTestnet: false,
    explorerUrl: 'https://explorer.zksync.io/tx/{hash}',
    rpcEndpoints: ['https://mainnet.era.zksync.io'],
    eurcAddress: null,
    usdcAddress: '0x1d17CBcF0D6D143135aE902365D2E5e2A16538D4',
    cctp: null,
});

/**
 * ZKSync Era Sepolia Testnet chain definition
 * @remarks
 * This represents the official test network for the ZKSync Era blockchain on Sepolia.
 */
const ZKSyncEraSepolia = defineChain({
    type: 'evm',
    chain: Blockchain.ZKSync_Sepolia,
    name: 'ZKSync Era Sepolia',
    title: 'ZKSync Era Sepolia Testnet',
    nativeCurrency: {
        name: 'Sepolia Ether',
        symbol: 'ETH',
        decimals: 18,
    },
    chainId: 300,
    isTestnet: true,
    explorerUrl: 'https://sepolia.explorer.zksync.io/tx/{hash}',
    rpcEndpoints: ['https://sepolia.era.zksync.dev'],
    eurcAddress: null,
    usdcAddress: '0xAe045DE5638162fa134807Cb558E15A3F5A7F853',
    cctp: null,
});

var Chains = {
    __proto__: null,
    Algorand: Algorand,
    AlgorandTestnet: AlgorandTestnet,
    Aptos: Aptos,
    AptosTestnet: AptosTestnet,
    Arbitrum: Arbitrum,
    ArbitrumSepolia: ArbitrumSepolia,
    ArcTestnet: ArcTestnet,
    Avalanche: Avalanche,
    AvalancheFuji: AvalancheFuji,
    Base: Base,
    BaseSepolia: BaseSepolia,
    Celo: Celo,
    CeloAlfajoresTestnet: CeloAlfajoresTestnet,
    Codex: Codex,
    CodexTestnet: CodexTestnet,
    Ethereum: Ethereum,
    EthereumSepolia: EthereumSepolia,
    Hedera: Hedera,
    HederaTestnet: HederaTestnet,
    HyperEVM: HyperEVM,
    HyperEVMTestnet: HyperEVMTestnet,
    Ink: Ink,
    InkTestnet: InkTestnet,
    Linea: Linea,
    LineaSepolia: LineaSepolia,
    Monad: Monad,
    MonadTestnet: MonadTestnet,
    NEAR: NEAR,
    NEARTestnet: NEARTestnet,
    Noble: Noble,
    NobleTestnet: NobleTestnet,
    Optimism: Optimism,
    OptimismSepolia: OptimismSepolia,
    Plume: Plume,
    PlumeTestnet: PlumeTestnet,
    PolkadotAssetHub: PolkadotAssetHub,
    PolkadotWestmint: PolkadotWestmint,
    Polygon: Polygon,
    PolygonAmoy: PolygonAmoy,
    Sei: Sei,
    SeiTestnet: SeiTestnet,
    Solana: Solana,
    SolanaDevnet: SolanaDevnet,
    Sonic: Sonic,
    SonicTestnet: SonicTestnet,
    Stellar: Stellar,
    StellarTestnet: StellarTestnet,
    Sui: Sui,
    SuiTestnet: SuiTestnet,
    Unichain: Unichain,
    UnichainSepolia: UnichainSepolia,
    WorldChain: WorldChain,
    WorldChainSepolia: WorldChainSepolia,
    XDC: XDC,
    XDCApothem: XDCApothem,
    ZKSyncEra: ZKSyncEra,
    ZKSyncEraSepolia: ZKSyncEraSepolia
};

/**
 * Checks if a given chain supports Circle's Cross-Chain Transfer Protocol (CCTP) version 2.
 *
 * This guard function examines a chain definition to determine if it has CCTP v2 contract
 * configurations. It's used to validate that both source and destination chains
 * support CCTP v2 before attempting a transfer.
 *
 * @param chain - The chain definition to check for CCTP v2 support
 * @returns `true` if the chain supports CCTP v2 (has v2 contracts configured), `false` otherwise
 *
 * @example
 * ```typescript
 * import { isCCTPV2Supported } from '@circle-fin/bridge-kit'
 *
 * const isSupported = isCCTPV2Supported(ethChainDefinition)
 * console.log(isSupported) // true
 * ```
 */
function isCCTPV2Supported(chain) {
    return chain.cctp?.contracts.v2 !== undefined;
}

/**
 * Check if a chain supports a specific type of custom smart contract logic.
 *
 * This function examines a chain definition to determine if it has a specific
 * contract type configured. When a chain has custom contract support, it can
 * use enhanced features and custom business logic in addition to the standard
 * CCTP approve/burn/mint flow.
 *
 * @param chain - The chain definition to examine for custom contract support.
 * @param contractType - The type of contract to check for (e.g., 'bridge').
 * @returns True if the chain supports the specified contract type with a valid address configured.
 *
 * @example
 * ```typescript
 * import { hasCustomContractSupport, Ethereum } from '@core/chains'
 *
 * // Check if a chain supports bridge contracts
 * if (hasCustomContractSupport(Ethereum, 'bridge')) {
 *   // Runtime validation confirmed kitContracts.bridge exists
 *   console.log('Bridge contract:', Ethereum.kitContracts?.bridge)
 *   return executeCustomFlow(Ethereum.kitContracts?.bridge!, params)
 * } else {
 *   console.log('Using standard CCTP flow')
 *   return executeStandardFlow(params)
 * }
 * ```
 *
 * @example
 * ```typescript
 * // Usage in flow determination
 * function determineBridgingFlow(chain: ChainDefinition, params: BridgeParams) {
 *   if (hasCustomContractSupport(chain, 'bridge')) {
 *     return 'custom'
 *   } else if (isCCTPV2Supported(chain)) {
 *     return 'standard'
 *   } else {
 *     throw new Error(`Chain ${chain.name} is not supported for bridging`)
 *   }
 * }
 *
 * // Future usage with other contract types (when added to KitContractType)
 * // if (hasCustomContractSupport(someChain, 'customType')) {
 * //   console.log('Custom contract:', someChain.kitContracts?.customType)
 * // }
 * ```
 */
function hasCustomContractSupport(chain, contractType) {
    const contractAddress = chain.kitContracts?.[contractType];
    return (typeof contractAddress === 'string' && contractAddress.trim().length > 0);
}

/**
 * Base schema for common chain definition properties.
 * This contains all properties shared between EVM and non-EVM chains.
 */
const baseChainDefinitionSchema = zod.z.object({
    chain: zod.z.nativeEnum(Blockchain, {
        required_error: 'Chain enum is required. Please provide a valid Blockchain enum value.',
        invalid_type_error: 'Chain must be a valid Blockchain enum value.',
    }),
    name: zod.z.string({
        required_error: 'Chain name is required. Please provide a valid chain name.',
        invalid_type_error: 'Chain name must be a string.',
    }),
    title: zod.z.string().optional(),
    nativeCurrency: zod.z.object({
        name: zod.z.string(),
        symbol: zod.z.string(),
        decimals: zod.z.number(),
    }),
    isTestnet: zod.z.boolean({
        required_error: 'isTestnet is required. Please specify whether this is a testnet.',
        invalid_type_error: 'isTestnet must be a boolean.',
    }),
    explorerUrl: zod.z.string({
        required_error: 'Explorer URL is required. Please provide a valid explorer URL.',
        invalid_type_error: 'Explorer URL must be a string.',
    }),
    rpcEndpoints: zod.z.array(zod.z.string()),
    eurcAddress: zod.z.string().nullable(),
    usdcAddress: zod.z.string().nullable(),
    cctp: zod.z.any().nullable(), // We'll accept any CCTP config structure
    kitContracts: zod.z
        .object({
        bridge: zod.z.string().optional(),
    })
        .optional(),
});
/**
 * Zod schema for validating EVM chain definitions specifically.
 * This schema extends the base schema with EVM-specific properties.
 *
 * @example
 * ```typescript
 * import { evmChainDefinitionSchema } from '@core/chains/validation'
 * import { Blockchain } from '@core/chains'
 *
 * const ethereumChain = {
 *   type: 'evm',
 *   chain: Blockchain.Ethereum,
 *   name: 'Ethereum',
 *   chainId: 1,
 *   nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
 *   isTestnet: false,
 *   explorerUrl: 'https://etherscan.io/tx/{hash}',
 *   usdcAddress: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
 *   eurcAddress: null,
 *   cctp: null
 * }
 *
 * const result = evmChainDefinitionSchema.safeParse(ethereumChain)
 * if (result.success) {
 *   console.log('EVM chain definition is valid')
 * } else {
 *   console.error('Validation failed:', result.error)
 * }
 * ```
 */
const evmChainDefinitionSchema = baseChainDefinitionSchema
    .extend({
    type: zod.z.literal('evm'),
    chainId: zod.z.number({
        required_error: 'EVM chains must have a chainId. Please provide a valid EVM chain ID.',
        invalid_type_error: 'EVM chain ID must be a number.',
    }),
})
    .strict(); //// Reject any additional properties not defined in the schema
/**
 * Zod schema for validating non-EVM chain definitions.
 * This schema extends the base schema with non-EVM specific properties.
 */
const nonEvmChainDefinitionSchema = baseChainDefinitionSchema
    .extend({
    type: zod.z.enum([
        'algorand',
        'avalanche',
        'solana',
        'aptos',
        'near',
        'stellar',
        'sui',
        'hedera',
        'noble',
        'polkadot',
    ]),
})
    .strict(); // Reject any additional properties not defined in the schema
/**
 * Discriminated union schema for all chain definitions.
 * This schema validates different chain types based on their 'type' field.
 *
 * @example
 * ```typescript
 * import { chainDefinitionSchema } from '@core/chains/validation'
 * import { Blockchain } from '@core/chains'
 *
 * // EVM chain
 * chainDefinitionSchema.parse({
 *   type: 'evm',
 *   chain: Blockchain.Ethereum,
 *   chainId: 1,
 *   // ... other properties
 * })
 *
 * // Non-EVM chain
 * chainDefinitionSchema.parse({
 *   type: 'solana',
 *   chain: Blockchain.Solana,
 *   // ... other properties (no chainId)
 * })
 * ```
 */
const chainDefinitionSchema$1 = zod.z.discriminatedUnion('type', [
    evmChainDefinitionSchema,
    nonEvmChainDefinitionSchema,
]);
/**
 * Zod schema for validating chain identifiers.
 * This schema accepts either a string blockchain identifier, a Blockchain enum value,
 * or a full ChainDefinition object.
 *
 * @example
 * ```typescript
 * import { chainIdentifierSchema } from '@core/chains/validation'
 * import { Blockchain, Ethereum } from '@core/chains'
 *
 * // All of these are valid:
 * chainIdentifierSchema.parse('Ethereum')
 * chainIdentifierSchema.parse(Blockchain.Ethereum)
 * chainIdentifierSchema.parse(Ethereum)
 * ```
 */
zod.z.union([
    zod.z
        .string()
        .refine((val) => val in Blockchain, 'Must be a valid Blockchain enum value as string'),
    zod.z.nativeEnum(Blockchain),
    chainDefinitionSchema$1,
]);
/**
 * Zod schema for validating bridge chain identifiers.
 *
 * This schema validates that the provided chain is supported for CCTPv2 bridging.
 * It accepts either a BridgeChain enum value, a string matching a BridgeChain value,
 * or a ChainDefinition for a supported chain.
 *
 * Use this schema when validating chain parameters for bridge operations to ensure
 * only CCTPv2-supported chains are accepted at runtime.
 *
 * @example
 * ```typescript
 * import { bridgeChainIdentifierSchema } from '@core/chains/validation'
 * import { BridgeChain, Chains } from '@core/chains'
 *
 * // Valid - BridgeChain enum value
 * bridgeChainIdentifierSchema.parse(BridgeChain.Ethereum)
 *
 * // Valid - string literal
 * bridgeChainIdentifierSchema.parse('Base_Sepolia')
 *
 * // Valid - ChainDefinition (validated by CCTP support)
 * bridgeChainIdentifierSchema.parse(Chains.Solana)
 *
 * // Invalid - Algorand is not in BridgeChain (throws ZodError)
 * bridgeChainIdentifierSchema.parse('Algorand')
 * ```
 *
 * @see {@link BridgeChain} for the enum of supported chains.
 */
zod.z.union([
    zod.z.string().refine((val) => val in BridgeChain, (val) => ({
        message: `Chain "${val}" is not supported for bridging. Only chains in the BridgeChain enum support CCTPv2 bridging.`,
    })),
    chainDefinitionSchema$1.refine((chainDef) => chainDef.chain in BridgeChain, (chainDef) => ({
        message: `Chain "${chainDef.name}" (${chainDef.chain}) is not supported for bridging. Only chains in the BridgeChain enum support CCTPv2 bridging.`,
    })),
]);

/**
 * Retrieve a chain definition by its blockchain enum value.
 *
 * Searches the set of known chain definitions and returns the one matching the provided
 * blockchain enum or string value. Throws an error if no matching chain is found.
 *
 * @param blockchain - The blockchain enum or its string representation to look up.
 * @returns The corresponding ChainDefinition object for the given blockchain.
 *
 * @throws Error If no chain definition is found for the provided enum value.
 *
 * @example
 * ```typescript
 * import { getChainByEnum } from '@core/chains'
 * import { Blockchain } from '@core/chains'
 *
 * const ethereum = getChainByEnum(Blockchain.Ethereum)
 * console.log(ethereum.name) // "Ethereum"
 * ```
 */
const getChainByEnum = (blockchain) => {
    const chain = Object.values(Chains).find((chain) => {
        return chain.chain === blockchain;
    });
    if (!chain) {
        throw new Error(`No chain definition found for blockchain: ${blockchain}`);
    }
    return chain;
};

/**
 * Resolves a flexible chain identifier to a ChainDefinition.
 *
 * This function handles all three supported formats:
 * - ChainDefinition objects (passed through unchanged)
 * - Blockchain enum values (resolved via getChainByEnum)
 * - String literals of blockchain values (resolved via getChainByEnum)
 *
 * @param chainIdentifier - The chain identifier to resolve
 * @returns The resolved ChainDefinition object
 * @throws Error if the chain identifier cannot be resolved
 *
 * @example
 * ```typescript
 * import { resolveChainIdentifier } from '@core/chains'
 * import { Blockchain, Ethereum } from '@core/chains'
 *
 * // All of these resolve to the same ChainDefinition:
 * const chain1 = resolveChainIdentifier(Ethereum)
 * const chain2 = resolveChainIdentifier(Blockchain.Ethereum)
 * const chain3 = resolveChainIdentifier('Ethereum')
 * ```
 */
function resolveChainIdentifier(chainIdentifier) {
    // If it's already a ChainDefinition object, return it unchanged
    if (typeof chainIdentifier === 'object') {
        return chainIdentifier;
    }
    // If it's a string or enum value, resolve it via getChainByEnum
    if (typeof chainIdentifier === 'string') {
        return getChainByEnum(chainIdentifier);
    }
    // This should never happen with proper typing, but provide a fallback
    throw new Error(`Invalid chain identifier type: ${typeof chainIdentifier}. Expected ChainDefinition object, Blockchain enum, or string literal.`);
}

/**
 * Resolves the contract address for CCTP v2 smart contracts.
 *
 * This method handles both split and merged contract configurations,
 * returning the appropriate address based on the requested contract type.
 *
 * @param chain - The chain definition to resolve the contract address for
 * @param contractType - The type of contract address to resolve ('tokenMessenger' or 'messageTransmitter')
 * @returns The contract address for the specified contract type
 * @throws Error when chain does not support CCTP v2 or has unsupported contract configuration
 */
const resolveCCTPV2ContractAddress = (chain, contractType) => {
    // Handle custom bridge contract for tokenMessenger (burn transaction)
    if (hasCustomContractSupport(chain, 'bridge') &&
        chain.kitContracts?.bridge !== undefined) {
        return chain.kitContracts.bridge;
    }
    // At this point we know CCTP v2 is supported, so contracts exist
    const cctpConfig = chain.cctp;
    const contracts = cctpConfig.contracts.v2;
    // Handle different contract types with explicit type checking
    switch (contracts.type) {
        case 'split':
            return contracts.tokenMessenger
                ;
        case 'merged':
            return contracts.contract;
        default: {
            // Runtime safety check - this should never happen with proper typing
            const unknownContract = contracts;
            throw new Error(`Unsupported CCTP v2 contract type on chain ${chain.name}. Expected "split" or "merged", but received '${unknownContract.type ?? 'unknown'}'.`);
        }
    }
};

/**
 * Extracts chain information including name, display name, and expected address format.
 *
 * This function determines the chain type by checking the explicit `type` property first,
 * then falls back to name-based matching for Solana chains. The expected address format
 * is determined based on the chain type:
 * - EVM chains: 42-character hex address starting with 0x
 * - Solana chains: 44-character base58 encoded string
 * - Other chains: Generic format message based on chain type
 *
 * @param chain - The chain identifier (ChainDefinition object, string name, or undefined/null)
 * @returns Chain information with name, display name, and expected address format
 *
 * @example
 * ```typescript
 * import { extractChainInfo } from '@core/chains'
 *
 * // EVM chain with explicit type
 * const info1 = extractChainInfo({ name: 'Ethereum', type: 'evm' })
 * console.log(info1.name) // → "Ethereum"
 * console.log(info1.displayName) // → "Ethereum"
 * console.log(info1.expectedAddressFormat)
 * // → "42-character hex address starting with 0x"
 *
 * // Solana chain (inferred from name)
 * const info2 = extractChainInfo('Solana')
 * console.log(info2.expectedAddressFormat)
 * // → "44-character base58 encoded string"
 *
 * // Non-EVM chain with explicit type
 * const info3 = extractChainInfo({ name: 'Algorand', type: 'algorand' })
 * console.log(info3.expectedAddressFormat)
 * // → "valid algorand address"
 *
 * // Unknown chain
 * const info4 = extractChainInfo(undefined)
 * console.log(info4.name) // → "unknown"
 * console.log(info4.expectedAddressFormat) // → "valid blockchain address"
 * ```
 */
function extractChainInfo(chain) {
    const name = typeof chain === 'string' ? chain : (chain?.name ?? 'unknown');
    const chainType = typeof chain === 'object' && chain !== null ? chain.type : undefined;
    // Use explicit chain type if available, fallback to name matching
    const isSolana = chainType === undefined
        ? name.toLowerCase().includes('solana')
        : chainType === 'solana';
    // Default to EVM if not Solana and no explicit non-EVM type
    const isEVM = chainType === undefined
        ? !isSolana // Default to EVM for unknown chains (unless they're Solana)
        : chainType === 'evm';
    // Determine expected address format based on chain type
    let expectedAddressFormat;
    if (isSolana) {
        expectedAddressFormat = '44-character base58 encoded string';
    }
    else if (isEVM) {
        expectedAddressFormat = '42-character hex address starting with 0x';
    }
    else {
        expectedAddressFormat = `valid ${chainType ?? 'blockchain'} address`;
    }
    return {
        name,
        displayName: name.replaceAll('_', ' '),
        expectedAddressFormat,
    };
}

/**
 * Abstract base class for bridging providers that implement cross-chain bridging protocols.
 *
 * This class defines the standard interface that all bridging providers must implement
 * to support cross-chain bridging. It provides a standardized way to check route
 * support, estimate costs, and execute bridge operations across different protocols.
 *
 * Bridging providers are responsible for:
 * - Validating bridge parameters and route support
 * - Estimating gas costs and protocol fees
 * - Executing the actual bridge operations
 * - Handling protocol-specific logic and error conditions
 *
 * @example
 * ```typescript
 * class CustomBridgingProvider extends BridgingProvider {
 *   async supportsRoute(source: Chain, destination: Chain, token: TokenType): Promise<boolean> {
 *     // Implementation specific logic
 *     return true
 *   }
 *
 *   async estimate(params: BridgeParams): Promise<BridgeEstimate> {
 *     // Cost estimation logic
 *     return { ... }
 *   }
 *
 *   async bridge(params: BridgeParams): Promise<BridgeResult> {
 *     // Bridge execution logic
 *     return { ... }
 *   }
 * }
 * ```
 */
class BridgingProvider {
    /**
     * The action dispatcher for this provider.
     *
     * This property holds a reference to an action dispatcher that can be used to
     * dispatch events or actions during the transfer process. It is optional and
     * can be null if no dispatcher is registered.
     */
    actionDispatcher = null;
    /**
     * Type-level map of action names to their payload types.
     * This property exists only at the type level and is used for TypeScript inference.
     */
    actions;
    /**
     * Get all destination chains that are supported for transfers from the given source chain.
     *
     * This method filters the provider's supported chains to return only those that are
     * compatible with the source chain. Compatibility is determined by matching testnet
     * status (mainnet chains can only transfer to mainnet chains, testnets to testnets)
     * and excluding the source chain itself.
     *
     * @param source - The source chain definition to find compatible destinations for
     * @returns Array of chain definitions that can serve as destinations for the given source
     *
     * @example
     * ```typescript
     * const provider = new BridgingProvider()
     * const destinations = provider.getSupportedDestinationsFor(Ethereum)
     * console.log('Available destinations from Ethereum:', destinations.map(d => d.name))
     * ```
     */
    getSupportedDestinationsFor(source) {
        return this.supportedChains.filter((chain) => chain.isTestnet === source.isTestnet && chain.chain !== source.chain);
    }
    /**
     * Register an event dispatcher for handling provider-specific actions and events.
     *
     *
     * @param dispatcher - The event dispatcher implementing the Actionable interface
     *
     * @example
     * ```typescript
     * const provider = new BridgingProvider()
     *
     * const actionDispatcher = new Actionable()
     *
     * provider.registerDispatcher(actionDispatcher)
     *
     * // Now provider actions will be dispatched to the action dispatcher
     * await provider.bridge(transferParams)
     * ```
     */
    registerDispatcher(dispatcher) {
        this.actionDispatcher = dispatcher;
    }
    supportsRetry() {
        return false; // Default: not supported
    }
    async retry() {
        return Promise.reject(new Error('Retry not supported by this provider'));
    }
    analyzeStepsForRetry() {
        throw new Error('Step analysis not supported by this provider');
    }
}

/**
 * Detect the runtime environment and return a shortened identifier.
 *
 * @returns Runtime string, e.g., "node/18", "browser/Chrome", or "unknown"
 */
const getRuntime = () => {
    // Node.js environment
    if (typeof process !== 'undefined' &&
        typeof process.versions === 'object' &&
        typeof process.versions.node === 'string') {
        // Shorten to major version only
        const majorVersion = process.versions.node.split('.')[0] ?? 'unknown';
        return `node/${majorVersion}`;
    }
    // Browser environment
    if (typeof window !== 'undefined' && typeof navigator !== 'undefined') {
        const userAgent = navigator.userAgent;
        const browserMatchers = {
            Edge: (ua) => ua.includes('Edg'),
            Chrome: (ua) => ua.includes('Chrome') && !ua.includes('Edg'),
            Firefox: (ua) => ua.includes('Firefox'),
            Safari: (ua) => ua.includes('Safari') && !ua.includes('Chrome'),
            Opera: (ua) => ua.includes('Opera') || ua.includes('OPR'),
        };
        for (const [browserName, matcher] of Object.entries(browserMatchers)) {
            if (matcher(userAgent))
                return `browser/${browserName}`;
        }
        return 'browser/unknown';
    }
    return 'unknown';
};
/**
 * Shorten package names by removing common prefixes.
 *
 * @param fullName - Full package name, e.g., "\@circle-fin/bridge-kit"
 * @returns Shortened name, e.g., "bridge-kit"
 */
const shortenPackageName = (fullName) => {
    return fullName.replace('@circle-fin/', '');
};
/**
 * Format a component (name/version) with length optimizations.
 *
 * @param nameWithVersion - Component identifier, e.g., "\@circle-fin/bridge-kit/1.2.3"
 * @returns Formatted component, e.g., "bridge-kit/1.2"
 */
const formatComponent = (nameWithVersion) => {
    // Find the last / to split name and version
    // This handles scoped packages like @circle-fin/bridge-kit/1.0.0 correctly
    const lastSlashIndex = nameWithVersion.lastIndexOf('/');
    if (lastSlashIndex === -1) {
        // No version, just a name
        return shortenPackageName(nameWithVersion);
    }
    const name = nameWithVersion.substring(0, lastSlashIndex);
    const version = nameWithVersion.substring(lastSlashIndex + 1);
    if (name === '')
        return '';
    if (version === '')
        return shortenPackageName(name);
    return `${shortenPackageName(name)}/${version}`;
};
/**
 * Create a new request context from global state.
 *
 * Reads the current external prefix and kit identifier from globalThis.
 * This is used internally by HTTP utilities.
 *
 * @returns A new request context
 * @internal
 */
const createRequestContext = () => {
    const context = {};
    if (typeof globalThis !== 'undefined') {
        if (globalThis.__STABLECOIN_KITS_EXTERNAL_PREFIX__ !== undefined) {
            context.externalPrefix = globalThis.__STABLECOIN_KITS_EXTERNAL_PREFIX__;
        }
        if (globalThis.__STABLECOIN_KITS_CURRENT_KIT__ !== undefined) {
            context.kit = globalThis.__STABLECOIN_KITS_CURRENT_KIT__;
        }
    }
    return context;
};
/**
 * Build a user agent string from a request context.
 *
 * Formats the context into a user agent string with automatic optimizations
 * (shortened package names and truncated versions). The current implementation
 * tracks a single kit globally.
 *
 * Format: `[external-prefix] kit (runtime)`
 *
 * @param context - Request context or undefined to use the global context
 * @returns Formatted user agent string
 *
 * @example
 * ```typescript
 * // With application prefix and kit
 * const ua = getUserAgent(context)
 * // → "my-app/1.0 bridge-kit/1.2 (node/18)"
 *
 * // Kit only (no application prefix set)
 * const ua = getUserAgent()
 * // → "bridge-kit/1.2 (node/18)"
 * ```
 */
const getUserAgent = (context) => {
    const ctx = createRequestContext();
    const runtime = getRuntime();
    // Build user agent string
    const parts = [];
    // Add external prefix if set
    if (ctx.externalPrefix !== undefined) {
        const formatted = formatComponent(ctx.externalPrefix);
        if (formatted)
            parts.push(formatted);
    }
    // Add kit if set
    if (ctx.kit !== undefined) {
        const formatted = formatComponent(ctx.kit);
        if (formatted)
            parts.push(formatted);
    }
    // Add runtime
    parts.push(`(${runtime})`);
    return parts.join(' ');
};

/**
 * Default configuration values for the API polling utility.
 * @internal
 */
const DEFAULT_CONFIG$1 = {
    timeout: 2_000,
    maxRetries: 10,
    retryDelay: 200,
    headers: {
        'Content-Type': 'application/json',
    },
};
/**
 * Helper to wait for a given number of milliseconds.
 */
const delay = async (ms) => {
    return new Promise((resolve) => setTimeout(resolve, ms));
};
/**
 * Makes a single HTTP request with timeout and validation.
 *
 * This function handles the low-level details of making an HTTP request,
 * including timeout management, response validation, and error handling.
 *
 * @remarks
 * The function uses AbortController for timeout management and includes proper cleanup
 * of timeouts in all code paths. It validates both the HTTP response status and the
 * response data format using the provided type guard before returning.
 *
 * Error handling:
 * - Throws on HTTP error responses (non-200 status codes)
 * - Throws on request timeout
 * - Throws on validation failure
 * - Ensures timeout cleanup in all cases
 *
 * @typeParam TResponseType - The expected response type after validation
 * @param url - The full URL to make the request to
 * @param method - The HTTP method to use
 * @param isValidType - Type guard function to validate the response
 * @param config - Configuration for this request
 * @param body - Optional request body (for POST/PUT/PATCH requests)
 * @returns Promise resolving to the validated response
 * @throws If the request fails, times out, or returns invalid data
 *
 * @example
 * ```typescript
 * const isUserResponse = (obj: unknown): obj is { id: number; name: string } => {
 *   return typeof obj === 'object' && obj !== null &&
 *          'id' in obj && 'name' in obj
 * }
 *
 * const user = await makeApiRequest(
 *   'https://api.example.com/users/1',
 *   'GET',
 *   isUserResponse,
 *   { timeout: 5000 }
 * )
 * ```
 */
const makeApiRequest = async (url, method, isValidType, config, body) => {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => {
        controller.abort('Request timed out');
    }, config.timeout);
    try {
        const requestInit = {
            method,
            headers: config.headers ?? {},
            signal: controller.signal,
        };
        // Add body for methods that support it
        if (body !== undefined && ['POST', 'PUT', 'PATCH'].includes(method)) {
            requestInit.body = JSON.stringify(body);
        }
        const response = await fetch(url, requestInit);
        clearTimeout(timeoutId);
        if (!response.ok) {
            throw new Error(`HTTP ${String(response.status)} - ${response.statusText}`);
        }
        const parsedJson = (await response.json());
        if (!isValidType(parsedJson)) {
            throw new Error('Invalid response format: response data failed validation');
        }
        return parsedJson;
    }
    finally {
        clearTimeout(timeoutId);
    }
};
/**
 * Determines if an error should trigger a retry attempt.
 *
 * This function implements the retry policy by analyzing error types and messages.
 * It follows these rules:
 * 1. Client errors (HTTP 4xx) are not retried, except for rate limiting (429)
 * 2. Invalid response format errors are not retried
 * 3. All other errors (network, timeout, server errors) are retried
 *
 * @remarks
 * The retry policy is designed to be conservative with retries on client errors
 * (which are unlikely to succeed) while being more lenient with potentially
 * transient failures like network issues or server errors.
 *
 * @param error - The error to analyze
 * @returns True if the error should trigger a retry, false otherwise
 *
 * @example
 * ```typescript
 * try {
 *   await makeApiRequest(...)
 * } catch (err) {
 *   const error = err instanceof Error ? err : new Error(String(err))
 *   if (isRetryableError(error)) {
 *     console.log('Will retry - temporary failure')
 *   } else {
 *     console.log('Will not retry - permanent failure')
 *   }
 * }
 * ```
 */
const isRetryableError = (error) => {
    // Don't retry client errors (4xx) except for 404 (Not Found) and 429 (Rate Limiting)
    if (/HTTP 4(?!(04|29))/.test(error.message)) {
        return false;
    }
    // Don't retry invalid response format errors
    if (error.message.includes('Invalid response format')) {
        return false;
    }
    return true;
};
/**
 * Polls an API endpoint with retry logic and type validation.
 *
 * This utility function provides a robust way to interact with APIs that may be
 * temporarily unavailable or return errors. It implements configurable retry logic
 * with exponential backoff and validates responses using provided type guards.
 *
 * @remarks
 * The function uses a conservative retry policy:
 * - Retries on server errors (5xx) and network issues
 * - Retries on rate limiting (429)
 * - Does not retry on client errors (4xx, except 429)
 * - Does not retry on validation failures
 *
 * Each HTTP request is given a configurable timeout before it is aborted.
 * The function waits between retry attempts to respect API rate limits.
 *
 * @typeParam TResponseType - The expected response type after validation
 * @param url - The API endpoint URL to poll
 * @param method - The HTTP method to use
 * @param isValidType - Type guard function to validate the response
 * @param config - Optional configuration overrides
 * @param body - Optional request body (for POST/PUT/PATCH requests)
 * @returns Promise resolving to the validated response
 * @throws If all retry attempts are exhausted or a non-retryable error occurs
 *
 * @example
 * ```typescript
 * import { pollApiWithValidation } from '@core/utils'
 *
 * // Define a type guard for the expected response
 * const isUserResponse = (obj: unknown): obj is { id: number; name: string } => {
 *   return typeof obj === 'object' && obj !== null &&
 *          'id' in obj && 'name' in obj &&
 *          typeof (obj as any).id === 'number' &&
 *          typeof (obj as any).name === 'string'
 * }
 *
 * // Poll an API with custom configuration
 * const user = await pollApiWithValidation(
 *   'https://api.example.com/users/1',
 *   'GET',
 *   isUserResponse,
 *   {
 *     timeout: 5000,
 *     maxRetries: 5,
 *     retryDelay: 1000
 *   }
 * )
 * ```
 *
 * @example
 * ```typescript
 * // POST request with body
 * const createUser = async (userData: { name: string; email: string }) => {
 *   return pollApiWithValidation(
 *     'https://api.example.com/users',
 *     'POST',
 *     isUserResponse,
 *     { maxRetries: 3 },
 *     userData
 *   )
 * }
 * ```
 */
const pollApiWithValidation = async (url, method, isValidType, config = {}, body) => {
    // Merge headers so that 'User-Agent' is always present and not overwritten
    const effectiveConfig = {
        ...DEFAULT_CONFIG$1,
        ...config,
        headers: {
            ...DEFAULT_CONFIG$1.headers,
            ...(config.headers ?? {}),
            // In browser environments, directly setting the 'User-Agent' or similar headers is restricted and may be ignored or cause errors.
            // This is why we use the 'X-User-Agent' header instead.
            ...(typeof window === 'undefined'
                ? { 'User-Agent': getUserAgent() }
                : { 'X-User-Agent': getUserAgent() }),
        },
    };
    let lastError;
    for (let attempt = 1; attempt <= effectiveConfig.maxRetries; attempt++) {
        try {
            return await makeApiRequest(url, method, isValidType, effectiveConfig, body);
        }
        catch (err) {
            const error = err instanceof Error ? err : new Error(String(err));
            if (!isRetryableError(error)) {
                throw error;
            }
            lastError = error;
            if (attempt < effectiveConfig.maxRetries) {
                await delay(effectiveConfig.retryDelay);
            }
        }
    }
    // After the loop: we're guaranteed to have a lastError
    throw new Error(`Maximum retry attempts (${String(effectiveConfig.maxRetries)}) exceeded: ${String(lastError?.message)}`);
};
/**
 * Convenience function for making GET requests with validation.
 *
 * @typeParam TResponseType - The expected response type after validation
 * @param url - The API endpoint URL
 * @param isValidType - Type guard function to validate the response
 * @param config - Optional configuration overrides
 * @returns Promise resolving to the validated response
 *
 * @example
 * ```typescript
 * const data = await pollApiGet(
 *   'https://api.example.com/data',
 *   isDataResponse,
 *   { timeout: 3000 }
 * )
 * ```
 */
const pollApiGet = async (url, isValidType, config) => {
    return pollApiWithValidation(url, 'GET', isValidType, config);
};
/**
 * Convenience function for making POST requests with validation.
 *
 * @typeParam TResponseType - The expected response type after validation
 * @typeParam TBody - The type of the request body
 * @param url - The API endpoint URL
 * @param body - The request body
 * @param isValidType - Type guard function to validate the response
 * @param config - Optional configuration overrides
 * @returns Promise resolving to the validated response
 *
 * @example
 * ```typescript
 * const result = await pollApiPost(
 *   'https://api.example.com/submit',
 *   { name: 'John', email: 'john@example.com' },
 *   isSubmissionResponse,
 *   { maxRetries: 3 }
 * )
 * ```
 */
const pollApiPost = async (url, body, isValidType, config) => {
    return pollApiWithValidation(url, 'POST', isValidType, config, body);
};

/**
 * Valid recoverability values for error handling strategies.
 *
 * - FATAL errors are thrown immediately (invalid inputs, insufficient funds)
 * - RETRYABLE errors are returned when a flow fails to start but could work later
 * - RESUMABLE errors are returned when a flow fails mid-execution but can be continued
 */
const RECOVERABILITY_VALUES = [
    'RETRYABLE',
    'RESUMABLE',
    'FATAL',
];
/**
 * Error type constants for categorizing errors by origin.
 *
 * This const object provides a reference for error types, enabling
 * IDE autocomplete and preventing typos when creating custom errors.
 *
 * @remarks
 * While internal error definitions use string literals with type annotations
 * for strict type safety, this constant is useful for developers creating
 * custom error instances or checking error types programmatically.
 *
 * @example
 * ```typescript
 * import { ERROR_TYPES, KitError } from '@core/errors'
 *
 * // Use for type checking
 * if (error.type === ERROR_TYPES.BALANCE) {
 *   console.log('This is a balance error')
 * }
 * ```
 *
 * @example
 * ```typescript
 * // Use as reference when creating custom errors
 * const error = new KitError({
 *   code: 9999,
 *   name: 'CUSTOM_ERROR',
 *   type: ERROR_TYPES.BALANCE,  // IDE autocomplete works here
 *   recoverability: 'FATAL',
 *   message: 'Custom balance error'
 * })
 * ```
 */
const ERROR_TYPES = {
    /** User input validation and parameter checking */
    INPUT: 'INPUT',
    /** Insufficient token balances and amount validation */
    BALANCE: 'BALANCE',
    /** On-chain execution: reverts, gas issues, transaction failures */
    ONCHAIN: 'ONCHAIN',
    /** Blockchain RPC provider issues and endpoint problems */
    RPC: 'RPC',
    /** Internet connectivity, DNS resolution, connection issues */
    NETWORK: 'NETWORK',
    /** Catch-all for unrecognized errors (code 0) */
    UNKNOWN: 'UNKNOWN',
};
/**
 * Array of valid error type values for validation.
 * Derived from ERROR_TYPES const object.
 */
const ERROR_TYPE_VALUES = Object.values(ERROR_TYPES);

// Create mutable arrays for Zod enum validation
const RECOVERABILITY_ARRAY = [...RECOVERABILITY_VALUES];
const ERROR_TYPE_ARRAY = [...ERROR_TYPE_VALUES];
/**
 * Error code ranges for validation.
 * Single source of truth for valid error code ranges.
 *
 * Note: Code 0 is special - it's the UNKNOWN catch-all error.
 */
const ERROR_CODE_RANGES = [
    { min: 1000, max: 1999, type: 'INPUT' },
    { min: 3000, max: 3999, type: 'NETWORK' },
    { min: 4000, max: 4999, type: 'RPC' },
    { min: 5000, max: 5999, type: 'ONCHAIN' },
    { min: 9000, max: 9999, type: 'BALANCE' },
];
/** Special code for UNKNOWN errors */
const UNKNOWN_ERROR_CODE = 0;
/**
 * Zod schema for validating ErrorDetails objects.
 *
 * This schema provides runtime validation for all ErrorDetails properties,
 * ensuring type safety and proper error handling for JavaScript consumers.
 *
 * @example
 * ```typescript
 * import { errorDetailsSchema } from '@core/errors'
 *
 * const result = errorDetailsSchema.safeParse({
 *   code: 1001,
 *   name: 'INPUT_NETWORK_MISMATCH',
 *   type: 'INPUT',
 *   recoverability: 'FATAL',
 *   message: 'Source and destination networks must be different'
 * })
 *
 * if (!result.success) {
 *   console.error('Validation failed:', result.error.issues)
 * }
 * ```
 *
 * @example
 * ```typescript
 * // Runtime error
 * const result = errorDetailsSchema.safeParse({
 *   code: 9001,
 *   name: 'BALANCE_INSUFFICIENT_TOKEN',
 *   type: 'BALANCE',
 *   recoverability: 'FATAL',
 *   message: 'Insufficient USDC balance'
 * })
 * ```
 */
const errorDetailsSchema = zod.z.object({
    /**
     * Numeric identifier following standardized ranges:
     * - 0: UNKNOWN - Catch-all for unrecognized errors
     * - 1000-1999: INPUT errors - Parameter validation
     * - 3000-3999: NETWORK errors - Connectivity issues
     * - 4000-4999: RPC errors - Provider issues, gas estimation
     * - 5000-5999: ONCHAIN errors - Transaction/simulation failures
     * - 9000-9999: BALANCE errors - Insufficient funds
     */
    code: zod.z
        .number()
        .int('Error code must be an integer')
        .refine((code) => code === UNKNOWN_ERROR_CODE ||
        ERROR_CODE_RANGES.some((range) => code >= range.min && code <= range.max), {
        message: 'Error code must be 0 (UNKNOWN) or in valid ranges: 1000-1999 (INPUT), 3000-3999 (NETWORK), 4000-4999 (RPC), 5000-5999 (ONCHAIN), 9000-9999 (BALANCE)',
    }),
    /** Human-readable ID (e.g., "INPUT_NETWORK_MISMATCH", "BALANCE_INSUFFICIENT_TOKEN") */
    name: zod.z
        .string()
        .min(1, 'Error name must be a non-empty string')
        .regex(/^[A-Z_][A-Z0-9_]*$/, 'Error name must match pattern: ^[A-Z_][A-Z0-9_]*$'),
    /** Error category indicating where the error originated */
    type: zod.z.enum(ERROR_TYPE_ARRAY, {
        errorMap: () => ({
            message: 'Error type must be one of: INPUT, BALANCE, ONCHAIN, RPC, NETWORK, UNKNOWN',
        }),
    }),
    /** Error handling strategy */
    recoverability: zod.z.enum(RECOVERABILITY_ARRAY, {
        errorMap: () => ({
            message: 'Recoverability must be one of: RETRYABLE, RESUMABLE, FATAL',
        }),
    }),
    /** User-friendly explanation with context */
    message: zod.z
        .string()
        .min(1, 'Error message must be a non-empty string')
        .max(1000, 'Error message must be 1000 characters or less'),
    /** Raw error details, context, or the original error that caused this one. */
    cause: zod.z
        .object({
        /** Free-form error payload from underlying system */
        trace: zod.z.unknown().optional(),
    })
        .optional(),
});

/**
 * Validates an ErrorDetails object using Zod schema.
 *
 * @param details - The object to validate
 * @returns The validated ErrorDetails object
 * @throws TypeError When validation fails
 *
 * @example
 * ```typescript
 * import { validateErrorDetails } from '@core/errors'
 *
 * try {
 *   const validDetails = validateErrorDetails({
 *     code: 1001,
 *     name: 'NETWORK_MISMATCH',
 *     recoverability: 'FATAL',
 *     message: 'Source and destination networks must be different'
 *   })
 * } catch (error) {
 *   console.error('Validation failed:', error.message)
 * }
 * ```
 */
function validateErrorDetails(details) {
    const result = errorDetailsSchema.safeParse(details);
    if (!result.success) {
        const issues = result.error.issues
            .map((issue) => `${issue.path.join('.')}: ${issue.message}`)
            .join(', ');
        throw new TypeError(`Invalid ErrorDetails: ${issues}`);
    }
    return result.data;
}

/**
 * Maximum length for error messages in fallback validation errors.
 *
 * KitError enforces a 1000-character limit on error messages. When creating
 * fallback validation errors that combine multiple Zod issues, we use 950
 * characters to leave a 50-character buffer for:
 * - The error message prefix ("Invalid bridge parameters: ")
 * - Potential encoding differences or formatting overhead
 * - Safety margin to prevent KitError constructor failures
 *
 * This ensures that even with concatenated issue summaries, the final message
 * stays within KitError's constraints.
 */
const MAX_MESSAGE_LENGTH = 950;
/**
 * Standard error message for invalid amount format.
 *
 * The SDK enforces strict dot-decimal notation for amount values. This constant
 * provides a consistent error message when users provide amounts with:
 * - Comma decimals (e.g., "1,5")
 * - Thousand separators (e.g., "1,000.50")
 * - Non-numeric characters
 * - Invalid format
 */
const AMOUNT_FORMAT_ERROR_MESSAGE = 'Amount must be a numeric string with dot (.) as decimal separator (e.g., "10.5", "100"), with no thousand separators or comma decimals';
/**
 * Error message for invalid maxFee format.
 *
 * Used when validating the maxFee configuration parameter. The maxFee can be zero
 * or positive and must follow strict dot-decimal notation.
 */
const MAX_FEE_FORMAT_ERROR_MESSAGE = 'maxFee must be a numeric string with dot (.) as decimal separator (e.g., "1", "0.5", ".5", "1.5"), with no thousand separators or comma decimals';

/**
 * Structured error class for Stablecoin Kit operations.
 *
 * This class extends the native Error class while implementing the ErrorDetails
 * interface, providing a consistent error format for programmatic handling
 * across the Stablecoin Kits ecosystem. All properties are immutable to ensure
 * error objects cannot be modified after creation.
 *
 * @example
 * ```typescript
 * import { KitError } from '@core/errors'
 *
 * const error = new KitError({
 *   code: 1001,
 *   name: 'INPUT_NETWORK_MISMATCH',
 *   recoverability: 'FATAL',
 *   message: 'Cannot bridge between mainnet and testnet'
 * })
 *
 * if (error instanceof KitError) {
 *   console.log(`Error ${error.code}: ${error.name}`)
 *   // → "Error 1001: INPUT_NETWORK_MISMATCH"
 * }
 * ```
 *
 * @example
 * ```typescript
 * import { KitError } from '@core/errors'
 *
 * // Error with cause information
 * const error = new KitError({
 *   code: 1002,
 *   name: 'INVALID_AMOUNT',
 *   recoverability: 'FATAL',
 *   message: 'Amount must be greater than zero',
 *   cause: {
 *     trace: { providedAmount: -100, minimumAmount: 0 }
 *   }
 * })
 *
 * throw error
 * ```
 */
class KitError extends Error {
    /** Numeric identifier following standardized ranges (1000+ for INPUT errors) */
    code;
    /** Human-readable ID (e.g., "NETWORK_MISMATCH") */
    name;
    /** Error category indicating where the error originated */
    type;
    /** Error handling strategy */
    recoverability;
    /** Raw error details, context, or the original error that caused this one. */
    cause;
    /**
     * Create a new KitError instance.
     *
     * @param details - The error details object containing all required properties.
     * @throws \{TypeError\} When details parameter is missing or invalid.
     */
    constructor(details) {
        // Truncate message if it exceeds maximum length to prevent validation errors
        let message = details.message;
        if (message.length > MAX_MESSAGE_LENGTH) {
            message = `${message.slice(0, MAX_MESSAGE_LENGTH - 3)}...`;
        }
        const truncatedDetails = { ...details, message };
        // Validate input at runtime for JavaScript consumers using Zod
        const validatedDetails = validateErrorDetails(truncatedDetails);
        super(validatedDetails.message);
        // Set properties as readonly at runtime
        Object.defineProperties(this, {
            name: {
                value: validatedDetails.name,
                writable: false,
                enumerable: true,
                configurable: false,
            },
            code: {
                value: validatedDetails.code,
                writable: false,
                enumerable: true,
                configurable: false,
            },
            type: {
                value: validatedDetails.type,
                writable: false,
                enumerable: true,
                configurable: false,
            },
            recoverability: {
                value: validatedDetails.recoverability,
                writable: false,
                enumerable: true,
                configurable: false,
            },
            ...(validatedDetails.cause && {
                cause: {
                    value: validatedDetails.cause,
                    writable: false,
                    enumerable: true,
                    configurable: false,
                },
            }),
        });
    }
}

/**
 * Standardized error code ranges for consistent categorization:
 *
 * - 0: UNKNOWN - Catch-all for unrecognized errors
 * - 1000-1999: INPUT errors - Parameter validation, input format errors
 * - 3000-3999: NETWORK errors - Internet connectivity, DNS, connection issues
 * - 4000-4999: RPC errors - Blockchain provider issues, gas estimation, nonce errors
 * - 5000-5999: ONCHAIN errors - Transaction/simulation failures, gas exhaustion, reverts
 * - 9000-9999: BALANCE errors - Insufficient funds, token balance, allowance
 */
/**
 * Standardized error definitions for INPUT type errors.
 *
 * Each entry combines the numeric error code, string name, and type
 * to ensure consistency when creating error instances.
 *
 * Error codes follow a hierarchical numbering scheme where the first digit
 * indicates the error category (1 = INPUT) and subsequent digits provide
 * specific error identification within that category.
 *
 *
 * @example
 * ```typescript
 * import { InputError } from '@core/errors'
 *
 * const error = new KitError({
 *   ...InputError.NETWORK_MISMATCH,
 *   recoverability: 'FATAL',
 *   message: 'Source and destination networks must be different'
 * })
 *
 * // Access code, name, and type individually if needed
 * console.log(InputError.NETWORK_MISMATCH.code)  // 1001
 * console.log(InputError.NETWORK_MISMATCH.name)  // 'INPUT_NETWORK_MISMATCH'
 * console.log(InputError.NETWORK_MISMATCH.type)  // 'INPUT'
 * ```
 */
const InputError = {
    /** Network type mismatch between chains (mainnet vs testnet) */
    NETWORK_MISMATCH: {
        code: 1001,
        name: 'INPUT_NETWORK_MISMATCH',
        type: 'INPUT',
    },
    /** Unsupported or invalid bridge route configuration */
    UNSUPPORTED_ROUTE: {
        code: 1003,
        name: 'INPUT_UNSUPPORTED_ROUTE',
        type: 'INPUT',
    },
    /** Invalid or unsupported chain identifier */
    INVALID_CHAIN: {
        code: 1005,
        name: 'INPUT_INVALID_CHAIN',
        type: 'INPUT',
    },
    /** General validation failure for complex validation rules */
    VALIDATION_FAILED: {
        code: 1098,
        name: 'INPUT_VALIDATION_FAILED',
        type: 'INPUT',
    },
};
/**
 * Standardized error definitions for BALANCE type errors.
 *
 * BALANCE errors indicate insufficient funds or allowance issues
 * that prevent transaction execution.
 *
 * @example
 * ```typescript
 * import { BalanceError } from '@core/errors'
 *
 * const error = new KitError({
 *   ...BalanceError.INSUFFICIENT_TOKEN,
 *   recoverability: 'FATAL',
 *   message: 'Insufficient USDC balance on Ethereum',
 *   cause: { trace: { required: '100', available: '50' } }
 * })
 * ```
 */
const BalanceError = {
    /** Insufficient token balance for transaction */
    INSUFFICIENT_TOKEN: {
        code: 9001,
        name: 'BALANCE_INSUFFICIENT_TOKEN',
        type: 'BALANCE',
    }};
/**
 * Standardized error definitions for ONCHAIN type errors.
 *
 * ONCHAIN errors occur during transaction execution, simulation,
 * or interaction with smart contracts on the blockchain.
 *
 * @example
 * ```typescript
 * import { OnchainError } from '@core/errors'
 *
 * const error = new KitError({
 *   ...OnchainError.SIMULATION_FAILED,
 *   recoverability: 'FATAL',
 *   message: 'Simulation failed: ERC20 transfer amount exceeds balance',
 *   cause: { trace: { reason: 'ERC20: transfer amount exceeds balance' } }
 * })
 * ```
 */
const OnchainError = {
    /** Pre-flight transaction simulation failed */
    SIMULATION_FAILED: {
        code: 5002,
        name: 'ONCHAIN_SIMULATION_FAILED',
        type: 'ONCHAIN',
    }};

/**
 * Creates error for network type mismatch between source and destination.
 *
 * This error is thrown when attempting to bridge between chains that have
 * different network types (e.g., mainnet to testnet), which is not supported
 * for security reasons.
 *
 * @param sourceChain - The source chain definition
 * @param destChain - The destination chain definition
 * @returns KitError with specific network mismatch details
 *
 * @example
 * ```typescript
 * import { createNetworkMismatchError } from '@core/errors'
 * import { Ethereum, BaseSepolia } from '@core/chains'
 *
 * // This will throw a detailed error
 * throw createNetworkMismatchError(Ethereum, BaseSepolia)
 * // Message: "Cannot bridge between Ethereum (mainnet) and Base Sepolia (testnet). Source and destination networks must both be testnet or both be mainnet."
 * ```
 */
function createNetworkMismatchError(sourceChain, destChain) {
    const sourceNetworkType = sourceChain.isTestnet ? 'testnet' : 'mainnet';
    const destNetworkType = destChain.isTestnet ? 'testnet' : 'mainnet';
    const errorDetails = {
        ...InputError.NETWORK_MISMATCH,
        recoverability: 'FATAL',
        message: `Cannot bridge between ${sourceChain.name} (${sourceNetworkType}) and ${destChain.name} (${destNetworkType}). Source and destination networks must both be testnet or both be mainnet.`,
        cause: {
            trace: { sourceChain: sourceChain.name, destChain: destChain.name },
        },
    };
    return new KitError(errorDetails);
}
/**
 * Creates error for unsupported bridge route.
 *
 * This error is thrown when attempting to bridge between chains that don't
 * have a supported bridge route configured.
 *
 * @param source - Source chain name
 * @param destination - Destination chain name
 * @returns KitError with specific route details
 *
 * @example
 * ```typescript
 * import { createUnsupportedRouteError } from '@core/errors'
 *
 * throw createUnsupportedRouteError('Ethereum', 'Solana')
 * // Message: "Route from Ethereum to Solana is not supported"
 * ```
 */
function createUnsupportedRouteError(source, destination) {
    const errorDetails = {
        ...InputError.UNSUPPORTED_ROUTE,
        recoverability: 'FATAL',
        message: `Route from ${source} to ${destination} is not supported.`,
        cause: {
            trace: { source, destination },
        },
    };
    return new KitError(errorDetails);
}
/**
 * Creates error for invalid chain configuration.
 *
 * This error is thrown when the provided chain doesn't meet the required
 * configuration or is not supported for the operation.
 *
 * @param chain - The invalid chain name or identifier
 * @param reason - Specific reason why chain is invalid
 * @returns KitError with chain details and validation rule
 *
 * @example
 * ```typescript
 * import { createInvalidChainError } from '@core/errors'
 *
 * throw createInvalidChainError('UnknownChain', 'Chain is not supported by this bridge')
 * // Message: "Invalid chain 'UnknownChain': Chain is not supported by this bridge"
 * ```
 */
function createInvalidChainError(chain, reason) {
    const errorDetails = {
        ...InputError.INVALID_CHAIN,
        recoverability: 'FATAL',
        message: `Invalid chain '${chain}': ${reason}`,
        cause: {
            trace: { chain, reason },
        },
    };
    return new KitError(errorDetails);
}
/**
 * Creates error for general validation failure.
 *
 * This error is thrown when input validation fails for reasons not covered
 * by more specific error types.
 *
 * @param field - The field that failed validation
 * @param value - The invalid value (can be any type)
 * @param reason - Specific reason why validation failed
 * @returns KitError with validation details
 *
 * @example
 * ```typescript
 * import { createValidationFailedError } from '@core/errors'
 *
 * throw createValidationFailedError('recipient', 'invalid@email', 'Must be a valid wallet address')
 * // Message: "Validation failed for 'recipient': 'invalid@email' - Must be a valid wallet address"
 *
 * throw createValidationFailedError('chainId', 999, 'Unsupported chain ID')
 * // Message: "Validation failed for 'chainId': 999 - Unsupported chain ID"
 *
 * throw createValidationFailedError('config', { invalid: true }, 'Missing required properties')
 * // Message: "Validation failed for 'config': [object Object] - Missing required properties"
 * ```
 */
function createValidationFailedError(field, value, reason) {
    // Convert value to string for display, handling different types appropriately
    let valueString;
    if (typeof value === 'string') {
        valueString = `'${value}'`;
    }
    else if (typeof value === 'object' && value !== null) {
        valueString = JSON.stringify(value);
    }
    else {
        valueString = String(value);
    }
    const errorDetails = {
        ...InputError.VALIDATION_FAILED,
        recoverability: 'FATAL',
        message: `Validation failed for '${field}': ${valueString} - ${reason}.`,
        cause: {
            trace: { field, value, reason },
        },
    };
    return new KitError(errorDetails);
}
/**
 * Creates a KitError from a Zod validation error with detailed error information.
 *
 * This factory function converts Zod validation failures into standardized KitError
 * instances with INPUT_VALIDATION_FAILED code (1098). It extracts all Zod issues
 * and includes them in both the error message and trace for debugging, providing
 * developers with comprehensive validation feedback.
 *
 * The error message includes all validation errors concatenated with semicolons.
 *
 * @param zodError - The Zod validation error containing one or more validation issues
 * @param context - Context string describing what was being validated (e.g., 'bridge parameters', 'user input')
 * @returns KitError with INPUT_VALIDATION_FAILED code and structured validation details
 *
 * @example
 * ```typescript
 * import { createValidationErrorFromZod } from '@core/errors'
 * import { z } from 'zod'
 *
 * const schema = z.object({
 *   name: z.string().min(3),
 *   age: z.number().positive()
 * })
 *
 * const result = schema.safeParse({ name: 'ab', age: -1 })
 * if (!result.success) {
 *   throw createValidationErrorFromZod(result.error, 'user data')
 * }
 * // Throws: KitError with message:
 * // "Invalid user data: name: String must contain at least 3 character(s); age: Number must be greater than 0"
 * // And cause.trace.validationErrors containing all validation errors as an array
 * ```
 *
 * @example
 * ```typescript
 * // Usage in validation functions
 * import { createValidationErrorFromZod } from '@core/errors'
 *
 * function validateBridgeParams(params: unknown): asserts params is BridgeParams {
 *   const result = bridgeParamsSchema.safeParse(params)
 *   if (!result.success) {
 *     throw createValidationErrorFromZod(result.error, 'bridge parameters')
 *   }
 * }
 * ```
 */
function createValidationErrorFromZod(zodError, context) {
    // Format each Zod issue as "path: message"
    const validationErrors = zodError.issues.map((issue) => {
        const path = issue.path.length > 0 ? `${issue.path.join('.')}: ` : '';
        return `${path}${issue.message}`;
    });
    // Join all errors with semicolons to show complete validation feedback
    const issueSummary = validationErrors.join('; ');
    const allErrors = issueSummary || 'Invalid Input';
    // Build full message from context and validation errors
    const fullMessage = `Invalid ${context}: ${allErrors}`;
    const errorDetails = {
        ...InputError.VALIDATION_FAILED,
        recoverability: 'FATAL',
        message: fullMessage,
        cause: {
            trace: {
                validationErrors, // Array of formatted error strings for display
                zodError: zodError.message, // Original Zod error message
                zodIssues: zodError.issues, // Full Zod issues array for debugging
            },
        },
    };
    return new KitError(errorDetails);
}

/**
 * Creates error for insufficient token balance.
 *
 * This error is thrown when a wallet does not have enough tokens to
 * complete a transaction. The error is FATAL as it requires user
 * intervention to add funds.
 *
 * @param chain - The blockchain network where the balance check failed
 * @param token - The token symbol (e.g., 'USDC', 'ETH')
 * @param trace - Optional trace context to include in error (can include rawError and additional debugging data)
 * @returns KitError with insufficient token balance details
 *
 * @example
 * ```typescript
 * import { createInsufficientTokenBalanceError } from '@core/errors'
 *
 * throw createInsufficientTokenBalanceError('Ethereum', 'USDC')
 * // Message: "Insufficient USDC balance on Ethereum"
 * ```
 *
 * @example
 * ```typescript
 * // With trace context for debugging
 * try {
 *   await transfer(...)
 * } catch (error) {
 *   throw createInsufficientTokenBalanceError('Base', 'USDC', {
 *     rawError: error,
 *     balance: '1000000',
 *     amount: '5000000',
 *   })
 * }
 * ```
 */
function createInsufficientTokenBalanceError(chain, token, trace) {
    return new KitError({
        ...BalanceError.INSUFFICIENT_TOKEN,
        recoverability: 'FATAL',
        message: `Insufficient ${token} balance on ${chain}`,
        cause: {
            trace: {
                ...trace,
                chain,
                token,
            },
        },
    });
}

/**
 * Creates error for transaction simulation failures.
 *
 * This error is thrown when a pre-flight transaction simulation fails,
 * typically due to contract logic that would revert. The error is FATAL
 * as it indicates the transaction would fail if submitted.
 *
 * @param chain - The blockchain network where the simulation failed
 * @param reason - The reason for simulation failure (e.g., revert message)
 * @param trace - Optional trace context to include in error (can include rawError and additional debugging data)
 * @returns KitError with simulation failure details
 *
 * @example
 * ```typescript
 * import { createSimulationFailedError } from '@core/errors'
 *
 * throw createSimulationFailedError('Ethereum', 'ERC20: insufficient allowance')
 * // Message: "Simulation failed on Ethereum: ERC20: insufficient allowance"
 * ```
 *
 * @example
 * ```typescript
 * // With trace context for debugging
 * throw createSimulationFailedError('Ethereum', 'ERC20: insufficient allowance', {
 *   rawError: error,
 *   txHash: '0x1234...',
 *   gasLimit: '21000',
 * })
 * ```
 */
function createSimulationFailedError(chain, reason, trace) {
    return new KitError({
        ...OnchainError.SIMULATION_FAILED,
        recoverability: 'FATAL',
        message: `Simulation failed on ${chain}: ${reason}`,
        cause: {
            trace: {
                ...trace,
                chain,
                reason,
            },
        },
    });
}

/**
 * Type guard to check if an error is a KitError instance.
 *
 * This guard enables TypeScript to narrow the type from `unknown` to
 * `KitError`, providing access to structured error properties like
 * code, name, and recoverability.
 *
 * @param error - Unknown error to check
 * @returns True if error is KitError with proper type narrowing
 *
 * @example
 * ```typescript
 * import { isKitError } from '@core/errors'
 *
 * try {
 *   await kit.bridge(params)
 * } catch (error) {
 *   if (isKitError(error)) {
 *     // TypeScript knows this is KitError
 *     console.log(`Structured error: ${error.name} (${error.code})`)
 *   } else {
 *     console.log('Regular error:', error)
 *   }
 * }
 * ```
 */
function isKitError(error) {
    return error instanceof KitError;
}
/**
 * Checks if an error is a KitError with FATAL recoverability.
 *
 * FATAL errors indicate issues that cannot be resolved through retries,
 * such as invalid inputs, configuration problems, or business rule
 * violations. These errors require user intervention to fix.
 *
 * @param error - Unknown error to check
 * @returns True if error is a KitError with FATAL recoverability
 *
 * @example
 * ```typescript
 * import { isFatalError } from '@core/errors'
 *
 * try {
 *   await kit.bridge(params)
 * } catch (error) {
 *   if (isFatalError(error)) {
 *     // Show user-friendly error message - don't retry
 *     showUserError(error.message)
 *   }
 * }
 * ```
 */
function isFatalError(error) {
    return isKitError(error) && error.recoverability === 'FATAL';
}
/**
 * Safely extracts error message from any error type.
 *
 * This utility handles different error types gracefully, extracting
 * meaningful messages from Error instances, string errors, or providing
 * a fallback for unknown error types. Never throws.
 *
 * @param error - Unknown error to extract message from
 * @returns Error message string, or fallback message
 *
 * @example
 * ```typescript
 * import { getErrorMessage } from '@core/errors'
 *
 * try {
 *   await riskyOperation()
 * } catch (error) {
 *   const message = getErrorMessage(error)
 *   console.log('Error occurred:', message)
 *   // Works with Error, KitError, string, or any other type
 * }
 * ```
 */
function getErrorMessage(error) {
    if (error instanceof Error) {
        return error.message;
    }
    if (typeof error === 'string') {
        return error;
    }
    return 'An unknown error occurred';
}

/**
 * Validates data against a Zod schema with enhanced error reporting.
 *
 * This function performs validation using Zod schemas and provides detailed error
 * messages that include the validation context. It's designed to give developers
 * clear feedback about what went wrong during validation.
 *
 * @param value - The value to validate
 * @param schema - The Zod schema to validate against
 * @param context - Context string to include in error messages (e.g., 'bridge parameters')
 * @returns Asserts that value is of type T (type narrowing)
 * @throws {KitError} If validation fails with INPUT_VALIDATION_FAILED code (1098)
 *
 * @example
 * ```typescript
 * validate(params, BridgeParamsSchema, 'bridge parameters')
 * // After this call, TypeScript knows params is of type BridgeParams
 * ```
 */
function validate(value, schema, context) {
    const result = schema.safeParse(value);
    if (!result.success) {
        throw createValidationErrorFromZod(result.error, context);
    }
}

/**
 * Symbol used to track validation state on objects.
 * This allows us to attach metadata to objects without interfering with their structure,
 * enabling optimized validation by skipping already validated objects.
 * @internal
 */
const VALIDATION_STATE = Symbol('validationState');
/**
 * Validates data against a Zod schema with state tracking and enhanced error reporting.
 *
 * This function performs validation using Zod schemas while tracking validation state
 * and providing detailed error messages. It's designed for use in scenarios where
 * validation state needs to be monitored and reported.
 *
 * @param value - The value to validate
 * @param schema - The Zod schema to validate against
 * @param context - Context string to include in error messages (e.g., 'bridge parameters')
 * @param validatorName - Symbol identifying the validator for state tracking
 * @returns Asserts that value is of type T (type narrowing)
 * @throws {KitError} If validation fails with INPUT_VALIDATION_FAILED code (1098)
 *
 * @example
 * ```typescript
 * const result = validateWithStateTracking(BridgeParamsSchema, params, 'bridge parameters')
 * ```
 */
function validateWithStateTracking(value, schema, context, validatorName) {
    // Skip validation for null or undefined values
    if (value === null) {
        throw new KitError({
            ...InputError.VALIDATION_FAILED,
            recoverability: 'FATAL',
            message: `Invalid ${context}: Value is null`,
            cause: {
                trace: {
                    validationErrors: ['Value is null'],
                },
            },
        });
    }
    if (value === undefined) {
        throw new KitError({
            ...InputError.VALIDATION_FAILED,
            recoverability: 'FATAL',
            message: `Invalid ${context}: Value is undefined`,
            cause: {
                trace: {
                    validationErrors: ['Value is undefined'],
                },
            },
        });
    }
    // Ensure value is an object that can hold validation state
    if (typeof value !== 'object') {
        throw new KitError({
            ...InputError.VALIDATION_FAILED,
            recoverability: 'FATAL',
            message: `Invalid ${context}: Value must be an object`,
            cause: {
                trace: {
                    validationErrors: [`Value must be an object, got ${typeof value}`],
                },
            },
        });
    }
    // Get or initialize validation state
    const valueWithState = value;
    const state = valueWithState[VALIDATION_STATE] ?? { validatedBy: [] };
    // Skip validation if already validated by this validator
    if (state.validatedBy.includes(validatorName)) {
        return;
    }
    // Delegate to the validate function for actual validation (now throws KitError)
    validate(value, schema, context);
    // Update validation state
    state.validatedBy.push(validatorName);
    valueWithState[VALIDATION_STATE] = state;
}

/**
 * Zod schema for validating chain definition objects used in buildExplorerUrl.
 * This schema ensures the chain definition has the required properties for URL generation.
 */
const chainDefinitionSchema = zod.z.object({
    name: zod.z
        .string({
        required_error: 'Chain name is required',
        invalid_type_error: 'Chain name must be a string',
    })
        .min(1, 'Chain name cannot be empty'),
    explorerUrl: zod.z
        .string({
        required_error: 'Explorer URL template is required',
        invalid_type_error: 'Explorer URL template must be a string',
    })
        .min(1, 'Explorer URL template cannot be empty')
        .refine((url) => url.includes('{hash}'), 'Explorer URL template must contain a {hash} placeholder'),
});
/**
 * Zod schema for validating transaction hash strings used in buildExplorerUrl.
 * This schema ensures the transaction hash is a non-empty string.
 */
const transactionHashSchema = zod.z
    .string({
    required_error: 'Transaction hash is required',
    invalid_type_error: 'Transaction hash must be a string',
})
    .min(1, 'Transaction hash cannot be empty')
    .transform((hash) => hash.trim()) // Automatically trim whitespace
    .refine((hash) => hash.length > 0, 'Transaction hash must not be empty or whitespace-only');
/**
 * Zod schema for validating buildExplorerUrl function parameters.
 * This schema validates both the chain definition and transaction hash together.
 */
const buildExplorerUrlParamsSchema = zod.z.object({
    chainDef: chainDefinitionSchema,
    txHash: transactionHashSchema,
});
/**
 * Zod schema for validating the generated explorer URL.
 * This schema ensures the generated URL is valid.
 */
const explorerUrlSchema = zod.z
    .string()
    .url('Generated explorer URL is invalid');

/**
 * Validates data against a Zod schema and throws a KitError on failure.
 *
 * This utility function provides consistent validation and error formatting across the codebase.
 * It performs the validation and formats error messages with contextual information while
 * preserving all individual validation errors in a structured format.
 *
 * @param value - The value to validate
 * @param schema - The Zod schema to validate against
 * @param message - Error message (e.g., 'Invalid EVM address', 'Configuration error')
 * @returns Asserts that value is of type T (type narrowing)
 * @throws {KitError} If validation fails with INPUT_VALIDATION_FAILED code (1098) and detailed error information
 *
 * @example
 * ```typescript
 * import { validateOrThrow } from '@core/utils'
 * import { z } from 'zod'
 *
 * const userSchema = z.object({
 *   name: z.string().min(3),
 *   age: z.number().positive()
 * })
 *
 * // This will throw KitError if validation fails
 * validateOrThrow({ name: 'Jo', age: -1 }, userSchema, 'Invalid user data')
 * // Throws: KitError with code 1098 and message "Invalid user data: name: String must contain at least 3 character(s)"
 * ```
 *
 * @example
 * ```typescript
 * // Usage in assertion functions with flexible messaging
 * validateOrThrow(address, evmAddressSchema, 'Invalid EVM address')
 * validateOrThrow(config, configSchema, 'Configuration error')
 * validateOrThrow(params, paramSchema, 'Bad parameters')
 * ```
 *
 * @example
 * ```typescript
 * // Usage in validation functions
 * function validateUserParams(params: unknown): void {
 *   validateOrThrow(params, userSchema, 'Invalid user parameters')
 *   // If we reach here, params is guaranteed to be valid
 * }
 * ```
 */
function validateOrThrow(value, schema, message) {
    const result = schema.safeParse(value);
    if (!result.success) {
        throw createValidationErrorFromZod(result.error, message);
    }
}

/**
 * Detect the format of the provided address string.
 *
 * Analyzes the address format and returns the corresponding chain type or bytes32
 * format. Supports EVM addresses (0x-prefixed 40-char hex), bytes32 addresses
 * (0x-prefixed 64-char hex), and Solana addresses (base58 encoded 32-byte keys).
 *
 * @param address - The address string to analyze.
 * @returns The detected format: 'evm', 'solana', or 'bytes32'.
 * @throws Error if the address format is unrecognized.
 *
 * @example
 * ```typescript
 * import { detectFormat } from '@core/utils'
 *
 * // EVM address
 * const evmFormat = detectFormat('0x1234567890abcdef1234567890abcdef12345678')
 * console.log(evmFormat) // 'evm'
 *
 * // Solana address
 * const solanaFormat = detectFormat('11111111111111111111111111111112')
 * console.log(solanaFormat) // 'solana'
 *
 * // Bytes32 address
 * const bytes32Format = detectFormat('0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef')
 * console.log(bytes32Format) // 'bytes32'
 * ```
 */
const detectFormat = (address) => {
    if (/^0x[0-9a-fA-F]{40}$/.test(address)) {
        return 'evm';
    }
    if (/^0x[0-9a-fA-F]{64}$/.test(address)) {
        return 'bytes32';
    }
    const decoded = bs58__default.decode(address);
    if (decoded.length === 32)
        return 'solana';
    throw new Error(`Unsupported address format: ${address}`);
};
/**
 * Convert an EVM address or Solana base58 key into a 32-byte hex string.
 *
 * This function normalizes addresses from different blockchain formats into a
 * standardized 32-byte hex representation. EVM addresses are zero-padded to
 * 32 bytes, while Solana addresses are decoded from base58 format.
 *
 * @param address - The address string to convert.
 * @returns A 32-byte hex string (0x-prefixed).
 * @throws Error if the address format is unsupported.
 *
 * @example
 * ```typescript
 * import { toBytes32 } from '@core/utils'
 *
 * // Convert EVM address
 * const evmBytes32 = toBytes32('0x1234567890abcdef1234567890abcdef12345678')
 * console.log(evmBytes32) // '0x0000000000000000000000001234567890abcdef1234567890abcdef12345678'
 *
 * // Convert Solana address
 * const solanaBytes32 = toBytes32('11111111111111111111111111111112')
 * console.log(solanaBytes32) // '0x...' (32-byte hex representation)
 * ```
 */
const toBytes32 = (address) => {
    const fmt = detectFormat(address);
    switch (fmt) {
        case 'evm':
            // pad 20-byte address → 32 bytes
            return bytes.hexZeroPad(address, 32);
        case 'bytes32':
            return address;
        case 'solana':
            // base58 decode → raw 32 bytes → hex
            return bytes.hexlify(bs58__default.decode(address));
    }
    throw new Error(`Unsupported address format: ${address}`);
};
/**
 * Convert a bytes32 hex string to a checksummed EVM address.
 *
 * This function extracts the last 20 bytes from a 32-byte hex string and
 * converts it to a valid EVM address with EIP-55 checksum formatting.
 *
 * @param bytes32 - The 32-byte hex string (with or without 0x prefix).
 * @returns A checksummed EVM address (0x-prefixed).
 * @throws Error if the input is not a valid hex string.
 *
 * @example
 * ```typescript
 * import { bytes32ToEvm } from '@core/utils'
 *
 * // Convert bytes32 to EVM address
 * const evmAddress = bytes32ToEvm('0x0000000000000000000000001234567890abcdef1234567890abcdef12345678')
 * console.log(evmAddress) // '0x1234567890AbcdEF1234567890aBcdeF12345678' (checksummed)
 *
 * // Works without 0x prefix too
 * const evmAddress2 = bytes32ToEvm('0000000000000000000000001234567890abcdef1234567890abcdef12345678')
 * console.log(evmAddress2) // '0x1234567890AbcdEF1234567890aBcdeF12345678'
 * ```
 */
const bytes32ToEvm = (bytes32) => {
    // remove 0x prefix
    const hex = bytes32.startsWith('0x') ? bytes32.slice(2) : bytes32;
    // take last 20 bytes (40 hex chars)
    const ethHex = '0x' + hex.slice(-40);
    // apply EIP-55 checksum
    return address.getAddress(ethHex);
};
/**
 * Convert a bytes32 hex string to a Solana base58 address.
 *
 * This function takes a 32-byte hex string and converts it to a Solana
 * public key address using base58 encoding.
 *
 * @param bytes32 - The 32-byte hex string (with or without 0x prefix).
 * @returns A Solana address in base58 format.
 * @throws Error if the input is not a valid hex string.
 *
 * @example
 * ```typescript
 * import { bytes32ToSolana } from '@core/utils'
 *
 * // Convert bytes32 to Solana address
 * const solanaAddress = bytes32ToSolana('0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef')
 * console.log(solanaAddress) // Base58 encoded address
 *
 * // Works without 0x prefix too
 * const solanaAddress2 = bytes32ToSolana('1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef')
 * console.log(solanaAddress2) // Base58 encoded address
 * ```
 */
function bytes32ToSolana(bytes32) {
    const hex = bytes32.startsWith('0x') ? bytes32.slice(2) : bytes32;
    const buffer = Buffer.from(hex, 'hex');
    return bs58__default.encode(new Uint8Array(buffer));
}
/**
 * Convert any supported address format into the target format.
 * @param address - input address (auto-detected)
 * @param targetFormat - one of 'evm', 'solana', or 'bytes32'
 * @returns converted address string
 */
const convertAddress = (address, targetFormat) => {
    const current = detectFormat(address);
    if (current === targetFormat)
        return address;
    // first normalize to bytes32
    const asBytes32 = toBytes32(address);
    // then to target
    switch (targetFormat) {
        case 'bytes32':
            return asBytes32;
        case 'evm':
            return bytes32ToEvm(asBytes32);
        case 'solana':
            return bytes32ToSolana(asBytes32);
    }
    throw new Error(`Unsupported address format: ${address}`);
};

/**
 * Convert a value from its smallest unit representation to a human-readable decimal string.
 *
 * This function normalizes token values from their blockchain representation (where
 * everything is stored as integers in the smallest denomination) to human-readable
 * decimal format. Uses the battle-tested implementation from @ethersproject/units.
 *
 * @param value - The value in smallest units (e.g., "1000000" for 1 USDC with 6 decimals)
 * @param decimals - The number of decimal places for the unit conversion
 * @returns A human-readable decimal string (e.g., "1.0")
 * @throws Error if the value is not a valid numeric string
 *
 * @example
 * ```typescript
 * import { formatUnits } from '@core/utils'
 *
 * // Format USDC (6 decimals)
 * const usdcFormatted = formatUnits('1000000', 6)
 * console.log(usdcFormatted) // "1.0"
 *
 * // Format ETH (18 decimals)
 * const ethFormatted = formatUnits('1000000000000000000', 18)
 * console.log(ethFormatted) // "1.0"
 *
 * // Format with fractional part
 * const fractionalFormatted = formatUnits('1500000', 6)
 * console.log(fractionalFormatted) // "1.5"
 * ```
 */
const formatUnits = (value, decimals) => {
    return units.formatUnits(value, decimals);
};

/**
 * Build a complete explorer URL from a chain definition and transaction hash.
 *
 * This function takes a chain definition containing an explorer URL template
 * and replaces the `{hash}` placeholder with the provided transaction hash
 * to create a complete, valid explorer URL.
 *
 * @param chainDef - The chain definition containing the explorer URL template.
 * @param txHash - The transaction hash to insert into the URL template.
 * @returns A complete explorer URL with the transaction hash inserted.
 * @throws Error if the chain definition is null/undefined.
 * @throws Error if the transaction hash is null/undefined/empty.
 * @throws Error if the explorer URL template is missing or empty.
 * @throws Error if the explorer URL template doesn't contain the {hash} placeholder.
 * @throws Error if the resulting URL is invalid.
 *
 * @example
 * ```typescript
 * import { buildExplorerUrl } from '@core/utils'
 * import { Ethereum } from '@core/chains'
 *
 * // Build URL for Ethereum transaction
 * const url = buildExplorerUrl(Ethereum, '0x1234567890abcdef...')
 * console.log(url) // 'https://etherscan.io/tx/0x1234567890abcdef...'
 * ```
 *
 * @example
 * ```typescript
 * import { buildExplorerUrl } from '@core/utils'
 * import { Solana } from '@core/chains'
 *
 * // Build URL for Solana transaction
 * const url = buildExplorerUrl(Solana, 'abc123def456...')
 * console.log(url) // 'https://solscan.io/tx/abc123def456...'
 * ```
 *
 * @example
 * ```typescript
 * import { buildExplorerUrl } from '@core/utils'
 * import { Aptos } from '@core/chains'
 *
 * // Build URL for Aptos transaction with query parameters
 * const url = buildExplorerUrl(Aptos, '0xabc123...')
 * console.log(url) // 'https://explorer.aptoslabs.com/txn/0xabc123...?network=mainnet'
 * ```
 */
function buildExplorerUrl(chainDef, txHash) {
    // Validate input parameters using our standard validation pattern
    validateOrThrow({ chainDef, txHash }, buildExplorerUrlParamsSchema, 'Invalid buildExplorerUrl parameters');
    // Parse and transform input parameters (e.g., trim whitespace from txHash)
    const { chainDef: validChainDef, txHash: validTxHash } = buildExplorerUrlParamsSchema.parse({ chainDef, txHash });
    // Replace all occurrences of the placeholder with the transaction hash
    const explorerUrl = validChainDef.explorerUrl.replace(/{hash}/g, validTxHash);
    // Validate the resulting URL
    validate(explorerUrl, explorerUrlSchema, 'explorer URL');
    return explorerUrl;
}

/**
 * Transfer speed options for cross-chain operations.
 *
 * Defines the available speed modes for CCTPv2 transfers, affecting
 * both transfer time and potential fee implications.
 */
var TransferSpeed;
(function (TransferSpeed) {
    /** Fast burn mode - reduces transfer time but may have different fee implications */
    TransferSpeed["FAST"] = "FAST";
    /** Standard burn mode - normal transfer time with standard fees */
    TransferSpeed["SLOW"] = "SLOW";
})(TransferSpeed || (TransferSpeed = {}));

/**
 * Factory to validate a numeric string with strict dot-decimal notation.
 * Only accepts dot (.) as the decimal separator. Thousand separators are not allowed.
 *
 * This enforces an unambiguous format for SDK inputs. Internationalization concerns
 * (comma vs dot decimal separators) should be handled in the UI layer before passing
 * values to the SDK.
 *
 * Accepts the following formats:
 * - Whole numbers: "1", "100", "1000"
 * - Leading zero decimals: "0.1", "0.5", "0.001"
 * - Shorthand decimals: ".1", ".5", ".001"
 * - Standard decimals: "1.23", "100.50"
 *
 * Does NOT accept:
 * - Comma decimal separator: "1,5" (use "1.5" instead)
 * - Thousand separators: "1,000.50" or "1.000,50" (use "1000.50" instead)
 * - Multiple decimal points: "1.2.3"
 * - Negative numbers: "-100"
 * - Non-numeric characters: "abc", "100a"
 *
 * Behavior differences controlled by options:
 * - allowZero: when false, value must be strictly greater than 0; when true, non-negative.
 * - regexMessage: error message when the basic numeric format fails.
 * - maxDecimals: maximum number of decimal places allowed (e.g., 6 for USDC).
 */
const createDecimalStringValidator = (options) => (schema) => {
    // Capitalize first letter of attribute name for error messages
    const capitalizedAttributeName = options.attributeName.charAt(0).toUpperCase() +
        options.attributeName.slice(1);
    return schema
        .regex(/^-?(?:\d+(?:\.\d+)?|\.\d+)$/, options.regexMessage)
        .superRefine((val, ctx) => {
        const amount = Number.parseFloat(val);
        if (Number.isNaN(amount)) {
            ctx.addIssue({
                code: zod.z.ZodIssueCode.custom,
                message: options.regexMessage,
            });
            return;
        }
        // Check decimal precision if maxDecimals is specified
        if (options.maxDecimals !== undefined) {
            const decimalPart = val.split('.')[1];
            if (decimalPart && decimalPart.length > options.maxDecimals) {
                ctx.addIssue({
                    code: zod.z.ZodIssueCode.custom,
                    message: `Maximum supported decimal places: ${options.maxDecimals.toString()}`,
                });
                return;
            }
        }
        if (options.allowZero && amount < 0) {
            ctx.addIssue({
                code: zod.z.ZodIssueCode.custom,
                message: `${capitalizedAttributeName} must be non-negative`,
            });
        }
        else if (!options.allowZero && amount <= 0) {
            ctx.addIssue({
                code: zod.z.ZodIssueCode.custom,
                message: `${capitalizedAttributeName} must be greater than 0`,
            });
        }
    });
};
/**
 * Schema for validating chain definitions.
 * This ensures the basic structure of a chain definition is valid.
 * A chain definition must include at minimum a name and type.
 *
 * @throws KitError if validation fails
 *
 * @example
 * ```typescript
 * import { chainDefinitionSchema } from '@core/provider'
 *
 * const validChain = {
 *   name: 'Ethereum',
 *   type: 'evm'
 * }
 *
 * const result = chainDefinitionSchema.safeParse(validChain)
 * console.log(result.success) // true
 * ```
 */
zod.z.object({
    name: zod.z.string().min(1, 'Chain name is required'),
    type: zod.z.string().min(1, 'Chain type is required'),
});
/**
 * Schema for validating wallet contexts.
 * This ensures all required fields are present and properly typed.
 * A wallet context must include:
 * - A valid adapter with prepare and execute methods
 * - A valid Ethereum address
 * - A valid chain definition with required properties
 *
 * @throws KitError if validation fails
 *
 * @example
 * ```typescript
 * import { walletContextSchema } from '@core/provider'
 *
 * const validContext = {
 *   adapter: {
 *     prepare: () => Promise.resolve({}),
 *     waitForTransaction: () => Promise.resolve({})
 *   },
 *   address: '0x1234567890123456789012345678901234567890',
 *   chain: {
 *     name: 'Ethereum',
 *     type: 'evm',
 *     isTestnet: false
 *   }
 * }
 *
 * const result = walletContextSchema.safeParse(validContext)
 * console.log(result.success) // true
 * ```
 */
const walletContextSchema = zod.z.object({
    adapter: zod.z.object({
        prepare: zod.z.function().returns(zod.z.any()),
        waitForTransaction: zod.z.function().returns(zod.z.any()),
    }),
    address: zod.z.string().min(1),
    chain: zod.z.object({
        name: zod.z.string(),
        type: zod.z.string(),
        isTestnet: zod.z.boolean(),
    }),
});
/**
 * Schema for validating a custom fee configuration.
 * Validates the simplified CustomFee interface which includes:
 * - An optional fee amount as string
 * - An optional fee recipient as string address
 *
 * @throws KitError if validation fails
 *
 * @example
 * ```typescript
 * import { customFeeSchema } from '@core/provider'
 *
 * const validConfig = {
 *   value: '1000000',
 *   recipientAddress: '0x1234567890123456789012345678901234567890'
 * }
 *
 * const result = customFeeSchema.safeParse(validConfig)
 * console.log(result.success) // true
 * ```
 */
const customFeeSchema = zod.z
    .object({
    /**
     * The fee to charge for the transfer as string.
     * Must be a non-negative value using dot (.) as decimal separator,
     * with no thousand separators or comma decimals.
     */
    value: createDecimalStringValidator({
        allowZero: true,
        regexMessage: 'Value must be a non-negative numeric string with dot (.) as decimal separator, with no thousand separators or comma decimals.',
        attributeName: 'value',
    })(zod.z.string()).optional(),
    /**
     * The fee recipient address.
     * Must be a valid address string.
     */
    recipientAddress: zod.z
        .string()
        .trim()
        .min(1, 'Fee recipient must be a non-empty string')
        .optional(),
})
    .strict();
/**
 * Schema for validating bridge parameters.
 * This ensures all required fields are present and properly typed.
 * A bridge must include:
 * - A valid amount (non-empty numeric string \> 0)
 * - Valid source and destination wallet contexts
 * - USDC as the token
 * - Optional config with transfer speed and max fee settings
 *
 * @throws KitError if validation fails
 *
 * @example
 * ```typescript
 * import { bridgeParamsSchema } from '@core/provider'
 *
 * const validBridge = {
 *   amount: '100.50',
 *   source: {
 *     adapter: sourceAdapter,
 *     address: '0xSourceAddress',
 *     chain: sourceChain
 *   },
 *   destination: {
 *     adapter: destAdapter,
 *     address: '0xDestAddress',
 *     chain: destChain
 *   },
 *   token: 'USDC',
 *   config: {
 *     transferSpeed: 'FAST',
 *     maxFee: '1.5', // Must use dot as decimal separator
 *     customFee: {
 *       value: '0.5', // Must use dot as decimal separator
 *       recipientAddress: '0x1234567890123456789012345678901234567890'
 *     }
 *   }
 * }
 *
 * const result = bridgeParamsSchema.safeParse(validBridge)
 * console.log(result.success) // true
 * ```
 */
const bridgeParamsSchema = zod.z.object({
    amount: zod.z
        .string()
        .min(1, 'Required')
        .pipe(createDecimalStringValidator({
        allowZero: false,
        regexMessage: AMOUNT_FORMAT_ERROR_MESSAGE,
        attributeName: 'amount',
        maxDecimals: 6,
    })(zod.z.string())),
    source: walletContextSchema,
    destination: walletContextSchema,
    token: zod.z.literal('USDC'),
    config: zod.z.object({
        transferSpeed: zod.z.nativeEnum(TransferSpeed).optional(),
        maxFee: zod.z
            .string()
            .pipe(createDecimalStringValidator({
            allowZero: true,
            regexMessage: MAX_FEE_FORMAT_ERROR_MESSAGE,
            attributeName: 'maxFee',
            maxDecimals: 6,
        })(zod.z.string()))
            .optional(),
        customFee: customFeeSchema.optional(),
    }),
});

/**
 * Base URL for Circle's IRIS API (mainnet/production).
 *
 * The IRIS API provides attestation services for CCTP cross-chain transfers.
 */
const IRIS_API_BASE_URL = 'https://iris-api.circle.com';
/**
 * Base URL for Circle's IRIS API (testnet/sandbox).
 *
 * Used for development and testing on testnet chains.
 */
const IRIS_API_SANDBOX_BASE_URL = 'https://iris-api-sandbox.circle.com';

/**
 * Type guard to validate the API response structure.
 *
 * This function performs runtime validation to ensure that the provided value
 * conforms to the expected structure of a FastBurnFeeResponse. It checks that:
 * 1. The value is an array
 * 2. Each array element is an object with 'finalityThreshold' and 'minimumFee' properties
 * 3. The 'finalityThreshold' property is a number
 * 4. The 'minimumFee' property is either a string or number
 *
 * @param data - The response data to validate
 * @returns True if the data matches the expected structure, false otherwise
 *
 * @example
 * ```typescript
 * const response = await fetch('https://iris-api.circle.com/...')
 * const data = await response.json()
 *
 * if (isFastBurnFeeResponse(data)) {
 *   // TypeScript now knows data is an array of BurnFeeTier objects
 *   console.log(`Number of fee tiers: ${data.length}`)
 * } else {
 *   throw new Error('Invalid response format')
 * }
 * ```
 */
const isBurnFeeTier = (item) => {
    return (typeof item === 'object' &&
        item !== null &&
        'finalityThreshold' in item &&
        'minimumFee' in item &&
        typeof item.finalityThreshold === 'number' &&
        (typeof item.minimumFee === 'string' || typeof item.minimumFee === 'number'));
};
const isFastBurnFeeResponse = (data) => {
    if (!Array.isArray(data)) {
        return false;
    }
    return data.every(isBurnFeeTier);
};
/**
 * Builds the API URL for fetching USDC fast burn fees.
 * @param sourceDomain - The source domain
 * @param destinationDomain - The destination domain
 * @param isTestnet - Whether the request is for a testnet chain
 * @returns The complete API URL
 */
function buildFastBurnFeeUrl(sourceDomain, destinationDomain, isTestnet) {
    const baseUrl = isTestnet ? IRIS_API_SANDBOX_BASE_URL : IRIS_API_BASE_URL;
    return `${baseUrl}/v2/burn/USDC/fees/${sourceDomain.toString()}/${destinationDomain.toString()}`;
}
const FAST_TIER_FINALITY_THRESHOLD = 1000;
/**
 * Fetches the minimum fee for a USDC fast burn operation with retry and timeout handling.
 *
 * Implements timeout and retry logic to handle network issues and temporary API failures.
 * Each HTTP request is given a maximum of 2 seconds before it is aborted.
 * We retry up to 10 times, waiting 200ms between attempts.
 *
 * The total maximum time this function might take (worst case) is:
 * - Per‐attempt timeout: 2 000 ms
 * - Retry delays: 9 × 200 ms = 1 800 ms
 * - Total max time: 2 000 ms + 1 800 ms = 3 800 ms
 *
 * @remarks
 * The API returns basis points as a decimal (e.g., "1.3" for 1.3 bps = 0.013%).
 * This function scales the value by 100 to preserve 2 decimal places of precision.
 * Callers must divide by 1,000,000 (instead of 10,000) when calculating fees.
 *
 * @param sourceDomain - The source domain
 * @param destinationDomain - The destination domain
 * @param isTestnet - Whether the request is for a testnet chain
 * @returns The minimum fee in scaled basis points (bps × 100)
 * @throws Error if the input domains are invalid, the API request fails, returns invalid data, or network errors occur
 * @example
 * ```typescript
 * const scaledBps = await fetchUsdcFastBurnFee(0, 6, false) // Ethereum -> Base
 * console.log(scaledBps) // 130n (representing 1.3 bps)
 *
 * // To calculate fee for an amount:
 * const amount = 1_000_000n // 1 USDC
 * const fee = (scaledBps * amount) / 1_000_000n // 130n (0.00013 USDC)
 * ```
 */
async function fetchUsdcFastBurnFee(sourceDomain, destinationDomain, isTestnet) {
    // Validate source domain
    if (!Number.isInteger(sourceDomain) || sourceDomain < 0) {
        throw new Error('Invalid source domain: must be a non-negative integer');
    }
    // Validate destination domain
    if (!Number.isInteger(destinationDomain) || destinationDomain < 0) {
        throw new Error('Invalid destination domain: must be a non-negative integer');
    }
    // Fetch the fee tiers from the API
    const url = buildFastBurnFeeUrl(sourceDomain, destinationDomain, isTestnet);
    const response = await pollApiGet(url, isFastBurnFeeResponse, DEFAULT_CONFIG$1);
    // Validate that we have at least one fee tier
    if (response.length === 0) {
        throw new Error('No fee tiers available in API response');
    }
    // Select the fee tier with finalityThreshold of FAST_TIER_FINALITY_THRESHOLD (fast tier)
    // Type assertion is safe here because isFastBurnFeeResponse validates the structure
    const feeTiers = response;
    const fastTier = feeTiers.find((tier) => tier.finalityThreshold === FAST_TIER_FINALITY_THRESHOLD);
    if (!fastTier) {
        throw new Error(`No fast tier (finalityThreshold: ${FAST_TIER_FINALITY_THRESHOLD.toString()}) available in API response`);
    }
    // Convert minimumFee to scaled basis points (bigint)
    // The API returns basis points as a decimal (e.g., "1.3" for 1.3 bps = 0.013%).
    // We scale by 100 to preserve 2 decimal places of precision.
    // The caller (getMaxFee) must divide by 1,000,000 instead of 10,000.
    const feeValue = Number.parseFloat(String(fastTier.minimumFee));
    if (Number.isNaN(feeValue) || !Number.isFinite(feeValue)) {
        throw new Error(`Invalid minimumFee value: cannot parse "${String(fastTier.minimumFee)}" as a number`);
    }
    // Scale by 100 and round to get integer representation
    const minimumFee = BigInt(Math.round(feeValue * 100));
    // Validate that minimumFee is non-negative
    if (minimumFee < 0n) {
        throw new Error('Invalid minimumFee: value must be non-negative');
    }
    return minimumFee;
}

/**
 * These values are used to estimate the gas fee for the depositForBurn and
 * receiveMessage functions on the source and destination chains on EVM chains.
 *
 * We use these values so that we can bypass the real-time gas estimation because
 * because these smart contract function calls may fail due to insufficient approval
 * amount and invalid atttestation messages.
 *
 * These values were obtained by averaging gas for the function call from the last 3 months.
 * see: https://dune.com/queries/6022210/9697710/
 */
const DEPOSIT_FOR_BURN_GAS_ESTIMATE_EVM = 169914n; // (99p: 111_521n + max: 226_506n) / 2 = 169_914n
const CUSTOM_BURN_GAS_ESTIMATE_EVM = 201525n; // p99 and max are same here: 201_525n
const RECEIVE_MESSAGE_GAS_ESTIMATE_EVM = 237401n; // (99p: 163_963n + max: 310_839n) / 2 = 237_401n
/**
 * The minimum finality threshold for CCTPv2 transfers.
 *
 * @remarks
 * This is a constant that is used to set the minimum finality threshold for CCTPv2 transfers.
 *
 * @example
 * ```typescript
 * const minFinalityThreshold = CCTPv2MinFinalityThreshold[TransferSpeed.FAST]
 * ```
 *
 * @see https://developers.circle.com/stablecoins/evm-smart-contracts#interface-highlights-cctp-v1-and-cctp-v2
 */
const CCTPv2MinFinalityThreshold = {
    [TransferSpeed.FAST]: 1000,
    [TransferSpeed.SLOW]: 2000,
};

/**
 * Default configuration values for the attestation fetcher.
 * @internal
 */
const DEFAULT_CONFIG = {
    timeout: 2_000, // 2 seconds
    maxRetries: 30 * 20, // 30 * 20 * 2 seconds (from the retry delay) = 20 minutes (to account for slow transfers maximum time based on confirmations)
    retryDelay: 2_000, // 2 seconds
    headers: {
        'Content-Type': 'application/json',
    },
};
/**
 * Type guard that verifies if an unknown value matches the AttestationMessage shape
 * and has all required properties.
 *
 * @param obj - The value to check, typically an element from the messages array
 * @returns True if the object matches the AttestationMessage shape, false otherwise
 * @internal
 */
const isValidAttestationMessage = (obj) => {
    return (typeof obj === 'object' &&
        obj !== null &&
        'message' in obj &&
        'eventNonce' in obj &&
        'attestation' in obj &&
        'decodedMessage' in obj &&
        'cctpVersion' in obj &&
        'status' in obj &&
        typeof obj.status === 'string');
};
/**
 * Type guard that verifies if an attestation message is complete.
 *
 * @param message - The attestation message to check
 * @returns True if the message status is 'complete', false otherwise
 * @internal
 */
const isCompleteAttestation = (message) => {
    return message.status === 'complete';
};
/**
 * Type guard that verifies if an unknown value has the correct structure
 * for an AttestationResponse, regardless of attestation completion status.
 *
 * @param obj - The value to check, typically a parsed JSON response
 * @returns True if the object matches the AttestationResponse shape
 * @internal
 */
const hasValidAttestationStructure = (obj) => {
    if (typeof obj !== 'object' ||
        obj === null ||
        !('messages' in obj) ||
        !Array.isArray(obj.messages)) {
        return false;
    }
    const messages = obj.messages;
    // Validate all messages have the correct shape
    return messages.every(isValidAttestationMessage);
};
/**
 * Type guard that verifies if an unknown value matches the AttestationResponse shape
 * and contains a complete attestation.
 *
 * This function performs runtime validation to ensure that the provided value
 * conforms to the expected structure of an AttestationResponse and has at least
 * one complete attestation. It checks that:
 * 1. The value has valid AttestationResponse structure
 * 2. At least one message has status 'complete'
 *
 * @remarks
 * This type guard is used internally by the attestation fetcher to validate
 * responses from the IRIS API before processing them. It provides runtime
 * type safety for data coming from the network and ensures we have a complete
 * attestation before proceeding.
 *
 * If the response has valid structure but no complete attestation yet,
 * it throws a retryable error. If the response structure is invalid,
 * it throws a non-retryable validation error.
 *
 * @param obj - The value to check, typically a parsed JSON response
 * @returns True if the object matches the AttestationResponse shape and has a complete attestation
 * @throws {Error} With "Invalid attestation response structure" if structure is invalid (non-retryable)
 * @throws {Error} With "Attestation not ready" if no complete attestation yet (retryable)
 *
 * @example
 * ```typescript
 * const response = await fetch('https://iris-api.circle.com/...')
 * const data = await response.json()
 *
 * if (isAttestationResponse(data)) {
 *   // TypeScript now knows data is AttestationResponse with at least one complete attestation
 *   const completeMessage = data.messages.find(msg => msg.status === 'complete')
 *   console.log('Found complete attestation:', completeMessage.attestation)
 * }
 * ```
 */
const isAttestationResponse = (obj) => {
    // First check if the structure is valid
    if (!hasValidAttestationStructure(obj)) {
        // If structure is invalid, this is a permanent failure - don't retry
        throw new Error('Invalid attestation response structure');
    }
    // Then check if at least one message is complete
    if (!obj.messages.some(isCompleteAttestation)) {
        // If no complete message, this is a temporary state - allow retry
        throw new Error('Attestation not ready');
    }
    return true;
};
/**
 * Builds the IRIS API URL for fetching attestation data from Circle's CCTP service.
 *
 * Constructs a properly formatted URL for the IRIS API v2 endpoint that provides
 * attestation messages for cross-chain transfers. The URL includes both the source
 * domain identifier and the transaction hash as query parameters. The base URL
 * is selected based on whether the operation is for testnet or mainnet.
 *
 * @param sourceDomainId - The CCTP domain ID of the source chain (numeric or string)
 * @param transactionHash - The transaction hash of the burn operation to fetch attestation for
 * @param isTestnet - Whether this is for a testnet chain (true) or mainnet chain (false)
 * @returns A fully qualified URL string for the IRIS API endpoint
 *
 * @example
 * ```typescript
 * // Mainnet URL
 * const mainnetUrl = buildIrisUrl(1, '0xabc...', false)
 * // => 'https://iris-api.circle.com/v2/messages/1?transactionHash=0xabc...'
 *
 * // Testnet URL
 * const testnetUrl = buildIrisUrl(1, '0xdef...', true)
 * // => 'https://iris-api-sandbox.circle.com/v2/messages/1?transactionHash=0xdef...'
 * ```
 */
const buildIrisUrl = (sourceDomainId, transactionHash, isTestnet) => {
    const baseUrl = isTestnet ? IRIS_API_SANDBOX_BASE_URL : IRIS_API_BASE_URL;
    const url = new URL(`${baseUrl}/v2/messages/${String(sourceDomainId)}`);
    url.searchParams.set('transactionHash', transactionHash);
    return url.toString();
};
/**
 * Fetches attestation data from the IRIS API with retry and timeout handling.
 * Since fetching starts after a confirmed burn transaction, we attempt up to 10 retries.
 * Implements a conservative delay between requests to respect the API rate
 * limit of 35 requests per second. To avoid rate limiting when multiple processes are
 * running concurrently, we enforce a 200ms delay between retries.
 *
 * Each HTTP request is given a maximum of 2 seconds before it is aborted.
 * We retry up to 10 times, waiting 200ms between attempts.
 *
 * The total maximum time this function might take (worst case) is:
 * - Per‐attempt timeout: 2 000 ms
 * - Retry delays: 9 × 200 ms = 1 800 ms
 * - Total max time: 2 000 ms + 1 800 ms = 3 800 ms
 *
 * @param sourceDomainId - The CCTP domain ID.
 * @param transactionHash - The transaction hash to fetch attestation for.
 * @param isTestnet - Whether this is for a testnet chain (true) or mainnet chain (false)
 * @param config - Optional configuration overrides for the attestation fetcher
 * @returns The attestation response data.
 * @throws If the request fails, times out, or returns invalid data.
 *
 * @example
 * ```typescript
 * // Fetch attestation for mainnet transaction
 * const response = await fetchAttestation(1, '0xabc...', false)
 * console.log(`Found ${response.messages.length} attestation messages`)
 *
 * // Fetch with custom timeout
 * const response2 = await fetchAttestation(1, '0xdef...', true, {
 *   timeout: 5000,
 *   maxRetries: 5
 * })
 * ```
 */
const fetchAttestation = async (sourceDomainId, transactionHash, isTestnet, config = {}) => {
    const url = buildIrisUrl(sourceDomainId, transactionHash, isTestnet);
    const effectiveConfig = { ...DEFAULT_CONFIG, ...config };
    return await pollApiGet(url, isAttestationResponse, effectiveConfig);
};
/**
 * Type guard that validates attestation response structure without requiring completion status.
 *
 * This is used by `fetchAttestationWithoutStatusCheck` to extract the nonce from an existing
 * attestation, even if the attestation is expired or pending. Unlike `isAttestationResponse`,
 * this function does not throw if no complete attestation is found.
 *
 * @param obj - The value to check, typically a parsed JSON response
 * @returns True if the object has valid attestation structure
 * @throws {Error} With "Invalid attestation response structure" if structure is invalid
 * @internal
 */
const isAttestationResponseWithoutStatusCheck = (obj) => {
    if (!hasValidAttestationStructure(obj)) {
        throw new Error('Invalid attestation response structure');
    }
    return true;
};
/**
 * Fetches attestation data without requiring the attestation to be complete.
 *
 * This function is useful for retrieving attestation data (particularly the nonce)
 * from an existing transaction, even if the attestation has expired or is pending.
 * It uses minimal retries since we're fetching existing data, not waiting for completion.
 *
 * @param sourceDomainId - The CCTP domain ID of the source chain
 * @param transactionHash - The transaction hash to fetch attestation for
 * @param isTestnet - Whether this is for a testnet chain (true) or mainnet chain (false)
 * @param config - Optional configuration overrides
 * @returns The attestation response data (may contain incomplete/expired attestations)
 * @throws If the request fails, times out, or returns invalid data
 *
 * @example
 * ```typescript
 * // Fetch existing attestation to extract nonce for re-attestation
 * const response = await fetchAttestationWithoutStatusCheck(1, '0xabc...', true)
 * const nonce = response.messages[0]?.eventNonce
 * ```
 */
const fetchAttestationWithoutStatusCheck = async (sourceDomainId, transactionHash, isTestnet, config = {}) => {
    const url = buildIrisUrl(sourceDomainId, transactionHash, isTestnet);
    // Use minimal retries since we're just fetching existing data
    const effectiveConfig = {
        ...DEFAULT_CONFIG,
        maxRetries: 3,
        ...config,
    };
    return await pollApiGet(url, isAttestationResponseWithoutStatusCheck, effectiveConfig);
};
/**
 * Type guard that validates attestation response has expirationBlock === '0'.
 *
 * This is used after requestReAttestation() to poll until the attestation
 * is fully re-processed and has a zero expiration block (never expires).
 * The expiration block transitions from non-zero to zero when Circle
 * completes processing the re-attestation request.
 *
 * @param obj - The value to check, typically a parsed JSON response
 * @returns True if the attestation has expirationBlock === '0'
 * @throws {Error} With "Re-attestation not yet complete" if expirationBlock is not '0'
 *
 * @example
 * ```typescript
 * // After requesting re-attestation, use this to validate the response
 * const response = await pollApiGet(url, isReAttestedAttestationResponse, config)
 * // response.messages[0].decodedMessage.decodedMessageBody.expirationBlock === '0'
 * ```
 *
 * @internal
 */
const isReAttestedAttestationResponse = (obj) => {
    // First validate the basic structure and completion status
    // This will throw appropriate errors for invalid structure or incomplete attestation
    if (!isAttestationResponse(obj)) ;
    // Check if the first message has expirationBlock === '0'
    const expirationBlock = obj.messages[0]?.decodedMessage?.decodedMessageBody?.expirationBlock;
    if (expirationBlock !== '0') {
        // Re-attestation not yet complete - allow retry via polling
        throw new Error('Re-attestation not yet complete: waiting for expirationBlock to become 0');
    }
    return true;
};
/**
 * Fetches attestation data and polls until expirationBlock === '0'.
 *
 * This function is used after calling requestReAttestation() to wait until
 * the attestation is fully re-processed. The expirationBlock transitions
 * from non-zero to zero when Circle completes the re-attestation.
 *
 * @param sourceDomainId - The CCTP domain ID of the source chain
 * @param transactionHash - The transaction hash to fetch attestation for
 * @param isTestnet - Whether this is for a testnet chain (true) or mainnet chain (false)
 * @param config - Optional configuration overrides
 * @returns The re-attested attestation response with expirationBlock === '0'
 * @throws If the request fails, times out, or expirationBlock never becomes 0
 *
 * @example
 * ```typescript
 * // After requesting re-attestation
 * await requestReAttestation(nonce, isTestnet)
 *
 * // Poll until expirationBlock becomes 0
 * const response = await fetchReAttestedAttestation(domainId, txHash, isTestnet)
 * // response.messages[0].decodedMessage.decodedMessageBody.expirationBlock === '0'
 * ```
 */
const fetchReAttestedAttestation = async (sourceDomainId, transactionHash, isTestnet, config = {}) => {
    const url = buildIrisUrl(sourceDomainId, transactionHash, isTestnet);
    const effectiveConfig = { ...DEFAULT_CONFIG, ...config };
    return await pollApiGet(url, isReAttestedAttestationResponse, effectiveConfig);
};
/**
 * Builds the IRIS API URL for re-attestation requests.
 *
 * Constructs the URL for Circle's re-attestation endpoint that allows
 * requesting a fresh attestation for an expired nonce.
 *
 * @param nonce - The nonce from the original attestation
 * @param isTestnet - Whether this is for a testnet chain (true) or mainnet chain (false)
 * @returns A fully qualified URL string for the re-attestation endpoint
 *
 * @example
 * ```typescript
 * // Mainnet URL
 * const mainnetUrl = buildReAttestUrl('0xabc', false)
 * // => 'https://iris-api.circle.com/v2/reattest/0xabc'
 *
 * // Testnet URL
 * const testnetUrl = buildReAttestUrl('0xabc', true)
 * // => 'https://iris-api-sandbox.circle.com/v2/reattest/0xabc'
 * ```
 */
const buildReAttestUrl = (nonce, isTestnet) => {
    const baseUrl = isTestnet ? IRIS_API_SANDBOX_BASE_URL : IRIS_API_BASE_URL;
    const url = new URL(`${baseUrl}/v2/reattest/${nonce}`);
    return url.toString();
};
/**
 * Type guard that validates the re-attestation API response structure.
 *
 * @param obj - The value to check, typically a parsed JSON response
 * @returns True if the object matches the ReAttestationResponse shape
 * @throws {Error} With "Invalid re-attestation response structure" if structure is invalid
 * @internal
 */
const isReAttestationResponse = (obj) => {
    if (typeof obj !== 'object' ||
        obj === null ||
        !('message' in obj) ||
        !('nonce' in obj) ||
        typeof obj.message !== 'string' ||
        typeof obj.nonce !== 'string') {
        throw new Error('Invalid re-attestation response structure');
    }
    return true;
};
/**
 * Requests re-attestation for an expired attestation nonce.
 *
 * This function calls Circle's re-attestation API endpoint to request a fresh
 * attestation for a previously issued nonce. After calling this function,
 * you should poll `fetchAttestation` to retrieve the new attestation.
 *
 * @param nonce - The nonce from the original (expired) attestation
 * @param isTestnet - Whether this is for a testnet chain (true) or mainnet chain (false)
 * @param config - Optional configuration overrides for the request
 * @returns The re-attestation response confirming the request was accepted
 * @throws If the request fails, times out, or returns invalid data
 *
 * @example
 * ```typescript
 * // Request re-attestation for an expired nonce
 * const response = await requestReAttestation('0xabc', true)
 * console.log(response.message) // "Re-attestation successfully requested for nonce."
 *
 * // After requesting re-attestation, poll for the new attestation
 * const attestation = await fetchAttestation(domainId, txHash, true)
 * ```
 */
const requestReAttestation = async (nonce, isTestnet, config = {}) => {
    const url = buildReAttestUrl(nonce, isTestnet);
    // Use minimal retries since we're just submitting a request, not polling for state
    const effectiveConfig = {
        ...DEFAULT_CONFIG,
        maxRetries: 3,
        ...config,
    };
    return await pollApiPost(url, {}, isReAttestationResponse, effectiveConfig);
};

const assertCCTPv2WalletContextSymbol = Symbol('assertCCTPv2WalletContext');
/**
 * Asserts that the provided parameters match the CCTPv2 wallet context interface.
 * The validation includes:
 * - Basic wallet context validation (adapter, address, chain)
 * - CCTPv2-specific chain validation (must be an EVM chain)
 *
 * @param params - The parameters to validate
 * @throws {KitError} If validation fails with INPUT_VALIDATION_FAILED code (1098), with details about which properties failed
 *
 * @example
 * ```typescript
 * import { assertCCTPv2WalletContext } from '@circle-fin/provider-cctp-v2'
 * import { Ethereum } from '@core/chains'
 *
 * // Prepare wallet context
 * const context = {
 *   adapter: {
 *     prepare: async () => ({ data: 'prepared transaction' }),
 *     waitForTransaction: async () => ({ status: 'confirmed' })
 *   },
 *   address: '0x1234567890123456789012345678901234567890',
 *   chain: {
 *     ...Ethereum,
 *     usdcAddress: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
 *     cctp: {
 *       domain: 1,
 *       contracts: {
 *         v2: {
 *           tokenMessenger: '0xTokenMessenger',
 *           messageTransmitter: '0xMessageTransmitter'
 *         }
 *       }
 *     }
 *   }
 * }
 *
 * // This will throw if validation fails
 * assertCCTPv2WalletContext(context)
 *
 * // If we get here, context is guaranteed to be valid
 * console.log('CCTPv2 wallet context is valid')
 * ```
 */
function assertCCTPv2WalletContext(params) {
    // First validate basic wallet context
    validateWithStateTracking(params, walletContextSchema, 'CCTPv2 wallet context', assertCCTPv2WalletContextSymbol);
    // After validation, we know params is WalletContext
    const context = params;
    // Validate USDC support
    if (context.chain.usdcAddress === null) {
        throw createInvalidChainError(context.chain.name, 'Does not have USDC configured');
    }
    // Validate CCTPv2 support
    if (!isCCTPV2Supported(context.chain)) {
        throw createInvalidChainError(context.chain.name, 'Does not support CCTPv2');
    }
}

const assertCCTPv2BridgeParamsSymbol = Symbol('assertCCTPv2BridgeParams');
/**
 * Asserts that the provided parameters match the CCTPv2 bridge parameters interface.
 * The validation includes:
 * - Basic parameter structure and types
 * - Amount validation (non-empty numeric string \> 0)
 * - Wallet address format validation (must be valid Ethereum address)
 * - Chain definition validation (must be a valid chain with required properties)
 * - Adapter validation (must implement required methods)
 * - Optional config validation (transfer speed and max fee)
 * - Network compatibility (source and destination chains must both be testnet or both mainnet)
 * - CCTPv2-specific wallet context validations
 *
 * @param params - The parameters to validate
 * @throws {KitError} If validation fails, with details about which properties failed
 *
 * @example
 * ```typescript
 * import { assertCCTPv2BridgeParams } from '@circle-fin/provider-cctp-v2'
 * import { Ethereum, Base } from '@core/chains'
 *
 * // Prepare transfer parameters
 * const params = {
 *   amount: '100.50',
 *   source: {
 *     adapter: sourceAdapter,
 *     address: '0xSourceAddress',
 *     chain: {
 *       ...Ethereum,
 *       cctp: {
 *         domain: 1,
 *         contracts: {
 *           v2: {
 *             tokenMessenger: '0xTokenMessenger',
 *             messageTransmitter: '0xMessageTransmitter'
 *           }
 *         }
 *       }
 *     }
 *   },
 *   destination: {
 *     adapter: destAdapter,
 *     address: '0xDestAddress',
 *     chain: {
 *       ...Base,
 *       cctp: {
 *         domain: 2,
 *         contracts: {
 *           v2: {
 *             tokenMessenger: '0xTokenMessenger',
 *             messageTransmitter: '0xMessageTransmitter'
 *           }
 *         }
 *       }
 *     }
 *   },
 *   token: 'USDC',
 *   config: {
 *     transferSpeed: 'FAST',
 *     maxFee: '1000000'
 *   }
 * }
 *
 * // This will throw if validation fails
 * assertCCTPv2BridgeParams(params)
 *
 * // If we get here, params is guaranteed to be valid
 * console.log('CCTPv2 transfer parameters are valid')
 * ```
 */
function assertCCTPv2BridgeParams(params) {
    // First validate basic bridge params
    validateWithStateTracking(params, bridgeParamsSchema, 'CCTPv2 bridge parameters', assertCCTPv2BridgeParamsSymbol);
    // After validation, we know params is BridgeParams
    const bridgeParams = params;
    // Enforce that source and destination chains are either testnet or mainnet
    if (bridgeParams.source.chain.isTestnet !==
        bridgeParams.destination.chain.isTestnet) {
        throw createNetworkMismatchError(bridgeParams.source.chain, bridgeParams.destination.chain);
    }
    assertCCTPV2Support(bridgeParams.source.chain, bridgeParams.destination.chain);
    /**
     * Enforce that if fee is defined then feeRecipient must be defined.
     * We do not do this in the validation function itself because we want to allow
     * optional properties when calling `provider.bridge()` due to the custom fee
     * configuration being possible at the kit level as well.
     */
    if (bridgeParams.config?.customFee?.value !== undefined &&
        bridgeParams.config?.customFee?.recipientAddress === undefined) {
        throw createValidationFailedError('recipientAddress', bridgeParams.config.customFee.value, 'Custom fee is defined but fee recipient is not. Please provide a fee recipient.');
    }
    // Validate CCTP v2 specific requirements for both wallets
    assertCCTPv2WalletContext(bridgeParams.source);
    assertCCTPv2WalletContext(bridgeParams.destination);
    // Validate that adapters support their respective chains (defense-in-depth)
    // This provides additional validation for users calling the provider directly
    // without going through the kit layer, ensuring early detection of unsupported chains
    bridgeParams.source.adapter.validateChainSupport(bridgeParams.source.chain);
    bridgeParams.destination.adapter.validateChainSupport(bridgeParams.destination.chain);
}
/**
 * Validate CCTP v2 support on both chains
 */
/**
 * Throws a KitError if the given chain does not support CCTP v2.
 *
 * @param chain - The chain to check for CCTP v2 support
 * @param otherChain - The other chain in the route (for error context)
 * @param isSource - Whether this is the source chain (for error context)
 */
function assertCCTPV2Support(source, destination) {
    if (!isCCTPV2Supported(source) || !isCCTPV2Supported(destination)) {
        throw createUnsupportedRouteError(source.name, destination.name);
    }
}

/**
 * Get the token account address where USDC will be minted for the recipient.
 *
 * For EVM chains, the recipient address directly holds ERC20 tokens, so the raw
 * address is returned as-is. For Solana, USDC is held in Associated Token Accounts
 * (ATAs), so this function derives the ATA address for the given owner and USDC mint.
 *
 * @param chainType - The type of blockchain ('evm' or 'solana').
 * @param rawAddress - The recipient's wallet address on the destination chain.
 * @param mint - The USDC mint address (only used for Solana chains).
 * @returns The address where USDC tokens will be minted (raw address for EVM, ATA for Solana).
 *
 * @example
 * ```typescript
 * import { getMintRecipientAccount } from './getMintRecipientAccount'
 *
 * // EVM: returns the same address
 * const evmAccount = await getMintRecipientAccount(
 *   'evm',
 *   '0x742d35Cc6634C0532925a3b8D89C7DA5C3cfa',
 *   'N/A'
 * )
 *
 * // Solana: derives the Associated Token Account
 * const solanaAccount = await getMintRecipientAccount(
 *   'solana',
 *   '9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM',
 *   'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'
 * )
 * ```
 */
const getMintRecipientAccount = async (
/** The blockchain type - determines how token accounts are handled */
chainType, 
/** The recipient's wallet address (hex format for EVM, base58 for Solana) */
rawAddress, 
/** The USDC mint address (ignored for EVM chains, required base58 address for Solana) */
mintAddress) => {
    if (chainType === 'evm') {
        // EVM: the rawAddress IS the ERC20 account
        return rawAddress;
    }
    else {
        // Solana: derive the associated token account
        // Use dynamic import to avoid loading Solana dependencies for EVM-only users
        try {
            const [{ PublicKey }, { getAssociatedTokenAddressSync }] = await Promise.all([
                import('@solana/web3.js'),
                import('@solana/spl-token'),
            ]);
            const owner = new PublicKey(rawAddress);
            const mintPub = new PublicKey(mintAddress);
            const ata = getAssociatedTokenAddressSync(mintPub, owner);
            return ata.toBase58();
        }
        catch {
            throw new Error('Failed to derive Solana token account. Please ensure @solana/web3.js and @solana/spl-token are installed: npm install @solana/web3.js @solana/spl-token');
        }
    }
};

/**
 * Converts a block number to bigint with validation.
 *
 * @param value - The block number value to convert (bigint, number, or string)
 * @returns The validated block number as a bigint
 * @throws KitError If the value is invalid (empty string, non-integer, negative, etc.)
 * @internal
 */
const toBlockNumber = (value) => {
    if (value === null || value === undefined) {
        throw createValidationFailedError('blockNumber', value, 'cannot be null or undefined');
    }
    // Empty string edge case - BigInt('') === 0n which is misleading
    if (value === '') {
        throw createValidationFailedError('blockNumber', value, 'cannot be empty string');
    }
    // For numbers, validate before BigInt conversion
    if (typeof value === 'number') {
        if (!Number.isFinite(value) || !Number.isInteger(value)) {
            throw createValidationFailedError('blockNumber', value, 'must be a finite integer');
        }
    }
    let result;
    try {
        result = BigInt(value);
    }
    catch {
        throw createValidationFailedError('blockNumber', value, 'cannot be converted to BigInt');
    }
    if (result < 0n) {
        throw createValidationFailedError('blockNumber', result.toString(), 'must be non-negative');
    }
    return result;
};
/**
 * Determines whether an attestation has expired based on the current block number.
 *
 * An attestation expires when the destination chain's current block number is greater
 * than or equal to the expiration block specified in the attestation message.
 * Slow transfers and re-attested messages have `expirationBlock: '0'` and never expire.
 *
 * @param attestation - The attestation message containing expiration block information
 * @param currentBlockNumber - The current block number on the destination chain (bigint, number, or string)
 * @returns `true` if the attestation has expired, `false` if still valid or never expires
 * @throws KitError If currentBlockNumber or expirationBlock is invalid
 *
 * @example
 * ```typescript
 * import { isAttestationExpired } from '@circle-fin/cctp-v2-provider'
 *
 * // Check if attestation is expired on EVM chain
 * const publicClient = await adapter.getPublicClient(destinationChain)
 * const currentBlock = await publicClient.getBlockNumber()
 * const expired = isAttestationExpired(attestation, currentBlock)
 *
 * if (expired) {
 *   const freshAttestation = await provider.reAttest(source, burnTxHash)
 * }
 * ```
 *
 * @example
 * ```typescript
 * // Check on Solana
 * const slot = await adapter.getConnection(destinationChain).getSlot()
 * const expired = isAttestationExpired(attestation, slot)
 * ```
 */
const isAttestationExpired = (attestation, currentBlockNumber) => {
    const currentBlock = toBlockNumber(currentBlockNumber);
    const expiration = toBlockNumber(attestation.decodedMessage.decodedMessageBody.expirationBlock);
    // 0n means it never expires (re-attested messages and slow transfers)
    if (expiration === 0n) {
        return false;
    }
    // Attestation is expired if current block >= expiration block
    return currentBlock >= expiration;
};
/**
 * Calculates the number of blocks remaining until an attestation expires.
 *
 * Returns the difference between the expiration block and the current block number.
 * Returns `null` if the attestation has `expirationBlock: '0'` (never expires).
 * Returns `0n` or a negative bigint if the attestation has already expired.
 *
 * @param attestation - The attestation message containing expiration block information
 * @param currentBlockNumber - The current block number on the destination chain (bigint, number, or string)
 * @returns The number of blocks until expiry as a bigint, or `null` if the attestation never expires
 * @throws KitError If currentBlockNumber or expirationBlock is invalid
 *
 * @example
 * ```typescript
 * import { getBlocksUntilExpiry } from '@circle-fin/cctp-v2-provider'
 *
 * const publicClient = await adapter.getPublicClient(destinationChain)
 * const currentBlock = await publicClient.getBlockNumber()
 * const blocksRemaining = getBlocksUntilExpiry(attestation, currentBlock)
 *
 * if (blocksRemaining === null) {
 *   console.log('Attestation never expires')
 * } else if (blocksRemaining <= 0n) {
 *   console.log('Attestation has expired')
 * } else {
 *   console.log(`${blocksRemaining} blocks until expiry`)
 * }
 * ```
 */
const getBlocksUntilExpiry = (attestation, currentBlockNumber) => {
    const currentBlock = toBlockNumber(currentBlockNumber);
    const expiration = toBlockNumber(attestation.decodedMessage.decodedMessageBody.expirationBlock);
    // 0n means it never expires (re-attested messages and slow transfers)
    if (expiration === 0n) {
        return null;
    }
    // Return the difference (can be negative if expired)
    return expiration - currentBlock;
};
/**
 * Determines whether a mint failure was caused by an expired attestation.
 *
 * This function inspects the error thrown during a mint operation to detect
 * if the failure is due to the attestation's expiration block being exceeded.
 * When this returns `true`, the caller should use `reAttest()` to obtain a
 * fresh attestation before retrying the mint.
 *
 * @param error - The error thrown during the mint operation
 * @returns `true` if the error indicates the attestation has expired, `false` otherwise
 *
 * @example
 * ```typescript
 * import { isMintFailureRelatedToAttestation } from '@circle-fin/cctp-v2-provider'
 *
 * try {
 *   await mintRequest.execute()
 * } catch (error) {
 *   if (isMintFailureRelatedToAttestation(error)) {
 *     // Attestation expired - get a fresh one
 *     const freshAttestation = await provider.reAttest(source, burnTxHash)
 *     const newMintRequest = await provider.mint(source, destination, freshAttestation)
 *     await newMintRequest.execute()
 *   } else {
 *     throw error
 *   }
 * }
 * ```
 */
const isMintFailureRelatedToAttestation = (error) => {
    if (error === null || error === undefined) {
        return false;
    }
    const errorString = getErrorMessage(error).toLowerCase();
    // Check for Solana "MessageExpired" error pattern
    // Full error: "AnchorError thrown in ...handle_receive_finalized_message.rs:169.
    //              Error Code: MessageExpired. Error Number: 6016. Error Message: Message has expired."
    if (errorString.includes('messageexpired')) {
        return true;
    }
    // Check for EVM attestation expiry errors
    // Contract reverts with: "Message expired and must be re-signed"
    if (errorString.includes('message') && errorString.includes('expired')) {
        return true;
    }
    return false;
};

/**
 * Checks if a decoded attestation field matches the corresponding transfer parameter.
 * If the values do not match, appends a descriptive error message to the errors array.
 *
 * @param field - The name of the field being compared (for error reporting)
 * @param decoded - The value decoded from the attestation message
 * @param param - The expected value from the transfer parameters
 * @param errors - The array to which error messages will be appended if a mismatch is found
 */
function checkFieldMismatch(field, decoded, param, errors) {
    if (decoded !== param) {
        errors.push(`${field} mismatch: decoded=${String(decoded)}, params=${String(param)}`);
    }
}
/**
 * Asserts that the decoded message from attestation matches the provided transfer params.
 * Throws KitError if any field mismatches, with clear error messages.
 *
 * @param attestation - The attestation message containing the decoded message
 * @param params - The transfer parameters to validate against
 * @throws {@link KitError} If any field mismatches
 */
async function assertCCTPv2AttestationParams(attestation, params) {
    const errors = [];
    const message = attestation.decodedMessage;
    const messageBody = message.decodedMessageBody;
    // Use recipientAddress if provided, otherwise use destination.address
    const destinationAddressForMint = params.destination.recipientAddress ?? params.destination.address;
    const mintRecipient = await getMintRecipientAccount(params.destination.chain.type, destinationAddressForMint, params.destination.chain.usdcAddress);
    let sender;
    if (hasCustomContractSupport(params.source.chain, 'bridge')) {
        if (params.source.chain.type === 'solana') {
            // Solana: User → Bridge contract → CCTP (user remains sender)
            sender = params.source.address;
        }
        else {
            // Other chains (like EVM): Bridge contract → CCTP (bridge contract becomes sender)
            sender = params.source.chain.kitContracts?.bridge;
        }
    }
    else {
        sender = params.source.address;
    }
    checkFieldMismatch('sourceDomain', message.sourceDomain, params.source.chain.cctp.domain.toString(), errors);
    checkFieldMismatch('destinationDomain', message.destinationDomain, params.destination.chain.cctp.domain.toString(), errors);
    checkFieldMismatch('minFinalityThreshold', message.minFinalityThreshold, CCTPv2MinFinalityThreshold[params.config.transferSpeed ?? 'FAST'].toString(), errors);
    checkFieldMismatch('sender', params.source.chain.type === 'evm'
        ? messageBody.messageSender.toLowerCase()
        : messageBody.messageSender, params.source.chain.type === 'evm' ? sender?.toLowerCase() : sender, errors);
    checkFieldMismatch('recipient', params.destination.chain.type === 'evm'
        ? messageBody.mintRecipient.toLowerCase()
        : messageBody.mintRecipient, params.destination.chain.type === 'evm'
        ? mintRecipient.toLowerCase()
        : mintRecipient, errors);
    checkFieldMismatch('amount', messageBody.amount, params.amount.toString(), errors);
    checkFieldMismatch('burnToken', messageBody.burnToken.toLowerCase(), params.source.chain.usdcAddress.toLowerCase(), errors);
    if (errors.length > 0) {
        const errorMessage = 'Attestation validation failed: received attestation does not match expected transfer parameters';
        const firstError = errors[0] ?? '';
        throw new KitError({
            ...InputError.VALIDATION_FAILED,
            recoverability: 'FATAL',
            message: `${errorMessage}: ${firstError}`,
            cause: {
                trace: {
                    validationErrors: errors,
                },
            },
        });
    }
}

/**
 * Executes a prepared chain request and returns the result as a bridge step.
 *
 * This function takes a prepared chain request (containing transaction data) and executes
 * it using the appropriate adapter. It handles the execution details and formats
 * the result as a standardized bridge step with transaction details and explorer URLs.
 *
 * @param params - The execution parameters containing:
 *   - `name`: The name of the step
 *   - `request`: The prepared chain request containing transaction data
 *   - `adapter`: The adapter that will execute the transaction
 *   - `confirmations`: The number of confirmations to wait for (defaults to 1)
 *   - `timeout`: The timeout for the request in milliseconds
 * @returns The bridge step with the transaction details and explorer URL
 * @throws If the transaction execution fails
 *
 * @example
 * ```typescript
 * const step = await executePreparedChainRequest({
 *   name: 'approve',
 *   request: preparedRequest,
 *   adapter: adapter,
 *   confirmations: 2,
 *   timeout: 30000
 * })
 * console.log('Transaction hash:', step.txHash)
 * ```
 */
async function executePreparedChainRequest({ name, request, adapter, chain, confirmations = 1, timeout, }) {
    const step = { name, state: 'pending' };
    try {
        /**
         * No-op requests are not executed.
         * We return a noop step instead.
         */
        if (request.type === 'noop') {
            step.state = 'noop';
            return step;
        }
        const txHash = await request.execute();
        step.txHash = txHash;
        const transaction = await adapter.waitForTransaction(txHash, {
            confirmations,
            timeout,
        }, chain);
        step.state = transaction.blockNumber ? 'success' : 'error';
        step.data = transaction;
        // Generate explorer URL for the step
        step.explorerUrl = buildExplorerUrl(chain, txHash);
        if (!transaction.blockNumber) {
            step.errorMessage = 'Transaction was not confirmed on-chain.';
        }
    }
    catch (err) {
        step.state = 'error';
        step.error = err;
        // Optionally parse for common blockchain error formats
        if (err instanceof Error) {
            step.errorMessage = err.message;
        }
        else if (typeof err === 'object' && err != null && 'message' in err) {
            step.errorMessage = String(err.message);
        }
        else {
            step.errorMessage = 'Unknown error occurred during approval step.';
        }
    }
    return step;
}

/**
 * Approves the TokenMessenger contract to spend USDC tokens for a bridge operation.
 *
 * This function handles the approval step of the CCTP v2 bridge process, allowing
 * the TokenMessenger contract to spend the specified amount of USDC tokens on behalf
 * of the user. This is a prerequisite for the subsequent burn operation.
 *
 * @param params - The bridge parameters containing source, destination, amount and optional config
 * @param sourceChain - The source chain definition where the approval will occur
 * @returns Promise resolving to the bridge step with transaction details
 * @throws {KitError} If the parameters are invalid
 * @throws {BridgeError} If the approval transaction fails
 *
 * @example
 * ```typescript
 * const approveStep = await approve(params, sourceChain)
 * console.log('Approval tx:', approveStep.transactionHash)
 * ```
 */
async function bridgeApproval({ params, provider, }) {
    // Calculate the approval amount
    const customFee = BigInt(params.config?.customFee?.value ?? '0');
    const amountBigInt = BigInt(params.amount);
    const approvalAmount = (amountBigInt + customFee).toString();
    return await executePreparedChainRequest({
        name: 'approve',
        adapter: params.source.adapter,
        chain: params.source.chain,
        request: await provider.approve(params.source, approvalAmount),
    });
}

/**
 * Executes a deposit-for-burn operation on the source chain to initiate a bridge.
 *
 * This function handles the burning step of the CCTP v2 bridge process, where USDC tokens
 * are burned on the source chain to create a message that can be used to mint equivalent
 * tokens on the destination chain.
 *
 * @param params - The bridge parameters containing source, destination, amount and optional config
 * @param sourceChain - The source chain definition where the burn will occur
 * @returns Promise resolving to the bridge step with transaction details
 * @throws {KitError} If the parameters are invalid
 * @throws \{BridgeError\} If the burn transaction fails
 *
 * @example
 * ```typescript
 * const burnStep = await burn(params, sourceChain)
 * console.log('Burn tx:', burnStep.transactionHash)
 * ```
 */
async function bridgeBurn({ params, provider, }) {
    return await executePreparedChainRequest({
        name: 'burn',
        adapter: params.source.adapter,
        chain: params.source.chain,
        request: await provider.burn(params),
    });
}

/**
 * Fetches the attestation from Circle's API for a completed burn operation.
 *
 * This function retrieves the attestation data required to mint tokens on the destination
 * chain after a successful burn operation. The attestation proves that the burn occurred
 * and authorizes the minting of equivalent tokens.
 *
 * @param params - The bridge parameters containing source, destination, amount and optional config
 * @param txHash - The hash of the burn transaction
 * @returns Promise resolving to the bridge step with attestation data
 * @throws {KitError} If the parameters are invalid
 * @throws {BridgeError} If the attestation fetch fails
 *
 * @example
 * ```typescript
 * const attestationStep = await bridgeFetchAttestation(
 *   { params, provider },
 *   burnTxHash
 * )
 * console.log('Attestation data:', attestationStep.data)
 * ```
 */
async function bridgeFetchAttestation({ params, provider, }, txHash) {
    let step = {
        name: 'fetchAttestation',
        state: 'pending',
    };
    try {
        /**
         * Give slow transfers a longer retry delay of 30 seconds to account for the longer time it takes to get the
         * attestation so that we do not hit the rate limit of the IRIS API or the retry limit of the API polling utility.
         * We only do this for slow transfers on source chains that have greater than 20 confirmations (5 minutes of blocktime
         * on the slowest blocktime chains) so that we do not slow down the attestation polling for lower confirmation chains.
         */
        const apiPollingConfig = params.config?.transferSpeed === TransferSpeed.SLOW &&
            params.source.chain.cctp.contracts.v2.confirmations > 20
            ? { retryDelay: 30_000 }
            : undefined;
        const attestation = await provider.fetchAttestation(params.source, txHash, apiPollingConfig);
        step = {
            ...step,
            state: 'success',
            data: attestation,
        };
    }
    catch (err) {
        let errorMessage = 'Unknown attestation error';
        if (err instanceof Error) {
            errorMessage = err.message;
        }
        else if (typeof err === 'string') {
            errorMessage = err;
        }
        step = {
            ...step,
            state: 'error',
            error: err,
            errorMessage,
            data: undefined,
        };
    }
    return step;
}

/**
 * Executes a mint operation on the destination chain to complete a bridge.
 *
 * This function handles the minting step of the CCTP v2 bridge process, where USDC tokens
 * are minted on the destination chain using the attestation and message from the source chain.
 * This is the final step that completes the cross-chain bridge operation.
 *
 * @param params - The bridge parameters containing source, destination, amount and optional config
 * @param destinationChain - The destination chain definition where the mint will occur
 * @param attestation - The attestation data from Circle's API
 * @param message - The message from the source chain burn operation
 * @returns Promise resolving to the bridge step with transaction details
 * @throws {KitError} If the parameters are invalid
 * @throws {BridgeError} If the mint transaction fails
 *
 * @example
 * ```typescript
 * const mintStep = await mint(params, destinationChain, attestation, message)
 * console.log('Mint tx:', mintStep.transactionHash)
 * ```
 */
async function bridgeMint({ params, provider, }, attestation) {
    // Validate attestation message matches transfer params
    await assertCCTPv2AttestationParams(attestation, params);
    return await executePreparedChainRequest({
        name: 'mint',
        adapter: params.destination.adapter,
        chain: params.destination.chain,
        request: await provider.mint(params.source, params.destination, attestation),
    });
}
const mockAttestationMessage = {
    attestation: '0x8bd9b9e63eb05128eb2896b63e3e1df39bfd6bbfb893b69dc53c39252aeb85df1ded70263b07da17abf88e6e1b77f16ebcdb4eb1c6b4ea4c625215e5cb9dddb81bffe0b9d75e2094f05e48f18f70d0b254999bde90bab26f5c0da29b2d7e00feca1cfed119cba0d2a0e887648a40e803e0ca34aa8fd94ce068515eeaef72b520aa1b',
    message: '0x000000010000000000000006f446cb82eb486fef485c14c301eaab73aa35f87e3feda3547acf0f33cd4b40f30000000000000000000000008fe6b999dc680ccfdd5bf7eb0974218be2542daa0000000000000000000000008fe6b999dc680ccfdd5bf7eb0974218be2542daa0000000000000000000000000000000000000000000000000000000000000000000003e8000003e8000000010000000000000000000000001c7d4b196cb0c7b01d743fbc6116a902379c723800000000000000000000000023f9a5bea7b92a0638520607407bc7f0310aeed400000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000c5567a5e3370d4dbfb0540025078e283e36a363d000000000000000000000000000000000000000000000000000000000000000b000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000001f6b158',
    eventNonce: '0xf446cb82eb486fef485c14c301eaab73aa35f87e3feda3547acf0f33cd4b40f3',
    cctpVersion: 2,
    status: 'complete',
    decodedMessage: {
        sourceDomain: '0',
        destinationDomain: '6',
        nonce: '0xf446cb82eb486fef485c14c301eaab73aa35f87e3feda3547acf0f33cd4b40f3',
        sender: '0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa',
        recipient: '0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa',
        destinationCaller: '0x0000000000000000000000000000000000000000000000000000000000000000',
        minFinalityThreshold: '1000',
        finalityThresholdExecuted: '1000',
        messageBody: '0x000000010000000000000000000000001c7d4b196cb0c7b01d743fbc6116a902379c723800000000000000000000000023f9a5bea7b92a0638520607407bc7f0310aeed400000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000c5567a5e3370d4dbfb0540025078e283e36a363d000000000000000000000000000000000000000000000000000000000000000b000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000001f6b158',
        decodedMessageBody: {
            burnToken: '0x1c7d4b196cb0c7b01d743fbc6116a902379c7238',
            mintRecipient: '0x23f9a5bea7b92a0638520607407bc7f0310aeed4',
            amount: '100000',
            messageSender: '0xc5567a5e3370d4dbfb0540025078e283e36a363d',
            maxFee: '11',
            feeExecuted: '10',
            expirationBlock: '32944472',
            hookData: null,
        },
    },
    delayReason: null,
};

/**
 * Ordered sequence of CCTP v2 bridge step executors.
 *
 * Defines the complete bridge flow: approve → burn → fetchAttestation → mint.
 * Each step includes an executor function and optional context updater for
 * passing data between steps.
 */
const stepExecutors = [
    {
        name: 'approve',
        executor: async (params, provider) => bridgeApproval({ params, provider }),
    },
    {
        name: 'burn',
        executor: async (params, provider) => bridgeBurn({ params, provider }),
        updateContext: (step) => {
            if (!step.txHash) {
                throw new Error('Burn step completed but no transaction hash was returned');
            }
            return {
                burnTxHash: step.txHash,
            };
        },
    },
    {
        name: 'fetchAttestation',
        executor: async (params, provider, context) => {
            if (!context?.burnTxHash) {
                throw new Error('Burn transaction hash not available for attestation');
            }
            return bridgeFetchAttestation({ params, provider }, context.burnTxHash);
        },
        updateContext: (step) => {
            if (!step.data) {
                throw new Error('Attestation step completed but no data was returned');
            }
            return {
                attestationData: step.data,
            };
        },
    },
    {
        name: 'mint',
        executor: async (params, provider, context) => {
            if (!context?.attestationData) {
                throw new Error('Attestation data not available for minting');
            }
            return bridgeMint({ params, provider }, context.attestationData);
        },
    },
];
/**
 * Helper function to create error step and set result state to error.
 *
 * @param stepName - The name of the step that failed
 * @param error - The error that occurred
 * @param result - The bridge result object to update
 */
function handleStepError(stepName, error, result) {
    result.state = 'error';
    // Parse error message using comprehensive error handling logic
    let errorMessage;
    if (error instanceof Error) {
        errorMessage = error.message;
    }
    else if (typeof error === 'string') {
        errorMessage = error;
    }
    else if (typeof error === 'object' && error != null && 'message' in error) {
        errorMessage = error.message;
    }
    else {
        errorMessage = `Unknown error occurred during ${stepName.toLowerCase()} step.`;
    }
    result.steps.push({
        name: stepName,
        state: 'error',
        error,
        errorMessage,
    });
}

/**
 * Dispatch a bridge step event through the provider's action dispatcher.
 *
 * Constructs the appropriate action payload and dispatches it to any registered
 * event listeners. Handles type-safe dispatching for different step types.
 *
 * @param name - The step name (approve, burn, fetchAttestation, or mint).
 * @param step - The completed bridge step containing transaction details and explorerUrl.
 * @param provider - The CCTP v2 provider with action dispatcher.
 *
 * @example
 * ```typescript
 * const step: BridgeStep = {
 *   name: 'burn',
 *   state: 'success',
 *   txHash: '0xabc...',
 *   explorerUrl: 'https://sepolia.etherscan.io/tx/0xabc...',
 *   data: { ... }
 * }
 * dispatchStepEvent('burn', step, provider)
 * ```
 */
function dispatchStepEvent(name, step, provider) {
    if (!provider.actionDispatcher) {
        return;
    }
    const actionValues = {
        protocol: 'cctp',
        version: 'v2',
        values: step,
    };
    switch (name) {
        case 'approve':
        case 'burn':
        case 'mint':
            provider.actionDispatcher.dispatch(name, {
                ...actionValues,
                method: name,
            });
            break;
        case 'fetchAttestation':
        case 'reAttest':
            provider.actionDispatcher.dispatch(name, {
                ...actionValues,
                method: name,
                values: step,
            });
            break;
    }
}

/**
 * Execute a cross-chain USDC bridge using the CCTP v2 protocol.
 *
 * @remarks
 * This function performs the full CCTP v2 bridge flow: token approval, burning on the source chain,
 * attestation fetching, and minting on the destination chain. Each step is validated and dispatched
 * through the provider's action dispatcher. If any step fails, the bridge result will have state 'error'.
 * Each step includes transaction details and explorer URLs for easy verification on block explorers.
 *
 * @param params - The bridge parameters containing source, destination, amount, and optional config.
 * @param provider - The CCTP v2 bridging provider instance.
 * @returns A promise resolving to the bridge result, including transaction details, step states, and explorer URLs.
 *
 * @throws Will propagate errors thrown by underlying step functions (approval, burn, attestation, mint) if they throw unexpectedly.
 *
 * @example
 * ```typescript
 * import { bridge } from '@circle-fin/provider-cctp-v2/provider/bridge/bridge'
 * // ...setup params and provider...
 * const result = await bridge(params, provider)
 * if (result.state === 'success') {
 *   console.log('Bridge completed!')
 *   result.steps.forEach(step => {
 *     if (step.explorerUrl) {
 *       console.log(`${step.name}: ${step.explorerUrl}`)
 *     }
 *   })
 * } else {
 *   console.error('Bridge failed at step:', result.steps.find(s => s.state === 'error'))
 * }
 * ```
 */
async function bridge(params, provider) {
    const result = {
        state: 'pending',
        amount: params.amount,
        token: params.token,
        source: {
            address: params.source.address,
            chain: params.source.chain,
        },
        destination: {
            address: params.destination.address,
            chain: params.destination.chain,
            // Preserve recipientAddress
            ...(params.destination.recipientAddress && {
                recipientAddress: params.destination.recipientAddress,
            }),
        },
        steps: [],
        config: params.config,
        provider: provider.name,
    };
    // Context shared between steps
    let context = undefined;
    // Execute each step in sequence
    for (const { name, executor, updateContext } of stepExecutors) {
        try {
            const step = await executor(params, provider, context);
            if (step.state === 'error') {
                // If step.error is a KitError, preserve it by re-throwing directly
                if (isKitError(step.error)) {
                    throw step.error;
                }
                // For non-KitError errors, wrap in descriptive Error
                let fallbackErrorMessage = 'Unknown error';
                if (step.error instanceof Error) {
                    fallbackErrorMessage = step.error.message;
                }
                else if (typeof step.error === 'string') {
                    fallbackErrorMessage = step.error;
                }
                const errorDetails = step.errorMessage ?? fallbackErrorMessage;
                throw new Error(`${name} step failed: ${errorDetails}`);
            }
            context = updateContext?.(step);
            dispatchStepEvent(name, step, provider);
            result.steps.push(step);
        }
        catch (error) {
            handleStepError(name, error, result);
            return result;
        }
    }
    result.state = 'success';
    return result;
}

/**
 * Resolves an operation context into concrete chain and address values.
 *
 * This function ensures that action handlers always receive defined chain and address
 * values by applying validation and resolution logic based on the adapter's capabilities.
 * It enforces compile-time and runtime address requirements based on the adapter's
 * address control model.
 *
 * **Resolution logic**:
 * - **Chain**: Uses provided chain identifier and resolves to ChainDefinition
 * - **Address**:
 *   - For user-controlled adapters: Retrieves current address from adapter (context address ignored)
 *   - For developer-controlled adapters: Uses address provided in context (required)
 *
 * @typeParam TAdapterCapabilities - The adapter capabilities type for compile-time validation
 * @param adapter - The typed adapter instance with capabilities defined
 * @param ctx - Operation context with compile-time validated address requirements
 * @returns Promise resolving to concrete chain and address values
 * @throws Error when adapter capabilities are not defined
 * @throws Error when operation context is not provided
 * @throws Error when address is required but not provided (developer-controlled)
 * @throws Error when adapter.getAddress() fails (user-controlled)
 *
 * @example
 * ```typescript
 * import { resolveOperationContext } from '@core/adapter'
 *
 * // User-controlled adapter - address forbidden in context
 * const userAdapter: Adapter<{ addressContext: 'user-controlled', supportedChains: [] }>
 * const resolved = await resolveOperationContext(userAdapter, {
 *   chain: 'Base' // address will be resolved from wallet
 * })
 * console.log(resolved.chain)   // ChainDefinition - always defined
 * console.log(resolved.address) // string - resolved from adapter
 *
 * // Developer-controlled adapter - address required in context
 * const devAdapter: Adapter<{ addressContext: 'developer-controlled', supportedChains: [] }>
 * const resolved = await resolveOperationContext(devAdapter, {
 *   chain: 'Base',
 *   address: '0x123...' // Required and enforced at compile time
 * })
 * console.log(resolved.address) // '0x123...' - from context
 * ```
 */
async function resolveOperationContext(adapter, ctx) {
    // Adapter must have capabilities defined
    if (adapter.capabilities === undefined) {
        throw new Error('Adapter capabilities must be defined. Please ensure the adapter implements the capabilities property.');
    }
    // Operation context is required for new typed adapters
    if (ctx === undefined) {
        throw new Error('Operation context is required. Please provide a context with the required chain and address information.');
    }
    // Resolve chain from context (required)
    const resolvedChain = resolveChainIdentifier(ctx.chain);
    // Resolve address based on adapter capabilities
    let resolvedAddress;
    if (adapter.capabilities.addressContext === 'developer-controlled') {
        // Developer-controlled: address must be explicitly provided
        if (!ctx.address) {
            throw new Error('Address is required for developer-controlled adapters. Please provide an address in the operation context.');
        }
        resolvedAddress = ctx.address;
    }
    else {
        // User-controlled: get current address from adapter
        try {
            // Pass resolved chain to getAddress for adapters that support it (like ViemAdapter)
            // The chain parameter is optional in implementations, so this is safe
            resolvedAddress = await adapter.getAddress(resolvedChain);
        }
        catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            throw new Error(`Failed to resolve address from user-controlled adapter: ${message}`);
        }
    }
    return {
        chain: resolvedChain,
        address: resolvedAddress,
    };
}

/**
 * Schema for validating hexadecimal strings with '0x' prefix.
 *
 * This schema validates that a string:
 * - Is a string type
 * - Is not empty after trimming
 * - Starts with '0x'
 * - Contains only valid hexadecimal characters (0-9, a-f, A-F) after '0x'
 *
 * @remarks
 * This schema does not validate length, making it suitable for various hex string types
 * like addresses, transaction hashes, and other hex-encoded data.
 *
 * @throws {KitError} If validation fails with INPUT_VALIDATION_FAILED code (1098), with details about which properties failed
 *
 * @example
 * ```typescript
 * import { hexStringSchema } from '@core/adapter'
 *
 * const validAddress = '0x1234567890123456789012345678901234567890'
 * const validTxHash = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef'
 *
 * const addressResult = hexStringSchema.safeParse(validAddress)
 * const txHashResult = hexStringSchema.safeParse(validTxHash)
 * console.log(addressResult.success) // true
 * console.log(txHashResult.success) // true
 * ```
 */
const hexStringSchema = zod.z
    .string()
    .min(1, 'Hex string is required')
    .refine((value) => value.trim().length > 0, 'Hex string cannot be empty')
    .refine((value) => value.startsWith('0x'), 'Hex string must start with 0x prefix')
    .refine((value) => {
    const hexPattern = /^0x[0-9a-fA-F]+$/;
    return hexPattern.test(value);
}, 'Hex string contains invalid characters. Only hexadecimal characters (0-9, a-f, A-F) are allowed after 0x');
/**
 * Schema for validating EVM addresses.
 *
 * This schema validates that a string is a properly formatted EVM address:
 * - Must be a valid hex string with '0x' prefix
 * - Must be exactly 42 characters long (0x + 40 hex characters)
 *
 * @throws {KitError} If validation fails with INPUT_VALIDATION_FAILED code (1098), with details about which properties failed
 *
 * @example
 * ```typescript
 * import { evmAddressSchema } from '@core/adapter'
 *
 * const validAddress = '0x1234567890123456789012345678901234567890'
 *
 * const result = evmAddressSchema.safeParse(validAddress)
 * console.log(result.success) // true
 * ```
 */
hexStringSchema.refine((value) => value.length === 42, 'EVM address must be exactly 42 characters long (0x + 40 hex characters)');
/**
 * Schema for validating transaction hashes.
 *
 * This schema validates that a string is a properly formatted transaction hash:
 * - Must be a valid hex string with '0x' prefix
 * - Must be exactly 66 characters long (0x + 64 hex characters)
 *
 * @throws {KitError} If validation fails with INPUT_VALIDATION_FAILED code (1098), with details about which properties failed
 *
 * @example
 * ```typescript
 * import { evmTransactionHashSchema } from '@core/adapter'
 *
 * const validTxHash = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef'
 *
 * const result = evmTransactionHashSchema.safeParse(validTxHash)
 * console.log(result.success) // true
 * ```
 */
hexStringSchema.refine((value) => value.length === 66, 'Transaction hash must be exactly 66 characters long (0x + 64 hex characters)');
/**
 * Schema for validating base58-encoded strings.
 *
 * This schema validates that a string:
 * - Is a string type
 * - Is not empty after trimming
 * - Contains only valid base58 characters (1-9, A-H, J-N, P-Z, a-k, m-z)
 * - Does not contain commonly confused characters (0, O, I, l)
 *
 * @remarks
 * This schema does not validate length, making it suitable for various base58-encoded data
 * like Solana addresses, transaction signatures, and other base58-encoded data.
 *
 * @throws {KitError} If validation fails with INPUT_VALIDATION_FAILED code (1098), with details about which properties failed
 *
 * @example
 * ```typescript
 * import { base58StringSchema } from '@core/adapter'
 *
 * const validAddress = 'DhzPkKCLJGHBZbs1AzmK2tRNLZkV8J3yWF3LuWMuKJpN'
 * const validTxHash = '3Jf8k2L5mN9pQ7rS1tV4wX6yZ8aB2cD4eF5gH7iJ9kL1mN3oP5qR7sT9uV1wX3yZ5'
 *
 * const addressResult = base58StringSchema.safeParse(validAddress)
 * const txHashResult = base58StringSchema.safeParse(validTxHash)
 * console.log(addressResult.success) // true
 * console.log(txHashResult.success) // true
 * ```
 */
const base58StringSchema = zod.z
    .string()
    .min(1, 'Base58 string is required')
    .refine((value) => value.trim().length > 0, 'Base58 string cannot be empty')
    .refine((value) => {
    // Base58 alphabet: 123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
    // Excludes: 0, O, I, l to avoid confusion
    const base58Pattern = /^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$/;
    return base58Pattern.test(value);
}, 'Base58 string contains invalid characters. Only base58 characters (1-9, A-H, J-N, P-Z, a-k, m-z) are allowed');
/**
 * Schema for validating Solana addresses.
 *
 * This schema validates that a string is a properly formatted Solana address:
 * - Must be a valid base58-encoded string
 * - Must be between 32-44 characters long (typical length for base58-encoded 32-byte addresses)
 *
 * @throws {KitError} If validation fails with INPUT_VALIDATION_FAILED code (1098), with details about which properties failed
 *
 * @example
 * ```typescript
 * import { solanaAddressSchema } from '@core/adapter'
 *
 * const validAddress = 'DhzPkKCLJGHBZbs1AzmK2tRNLZkV8J3yWF3LuWMuKJpN'
 *
 * const result = solanaAddressSchema.safeParse(validAddress)
 * console.log(result.success) // true
 * ```
 */
base58StringSchema.refine((value) => value.length >= 32 && value.length <= 44, 'Solana address must be between 32-44 characters long (base58-encoded 32-byte address)');
/**
 * Schema for validating Solana transaction hashes.
 *
 * This schema validates that a string is a properly formatted Solana transaction hash:
 * - Must be a valid base58-encoded string
 * - Must be between 86-88 characters long (typical length for base58-encoded 64-byte signatures)
 *
 * @throws {KitError} If validation fails with INPUT_VALIDATION_FAILED code (1098), with details about which properties failed
 *
 * @example
 * ```typescript
 * import { solanaTransactionHashSchema } from '@core/adapter'
 *
 * const validTxHash = '5VfYmGBjvQKe3xgLtTQPSMEUdpEVHrJwLK7pKBJWKzYpNBE2g3kJrq7RSe9M8DqzQJ5J2aZPTjHLvd4WgxPpJKS'
 *
 * const result = solanaTransactionHashSchema.safeParse(validTxHash)
 * console.log(result.success) // true
 * ```
 */
base58StringSchema.refine((value) => value.length >= 86 && value.length <= 88, 'Solana transaction hash must be between 86-88 characters long (base58-encoded 64-byte signature)');
/**
 * Schema for validating Adapter objects.
 * Checks for the required methods that define an Adapter.
 */
zod.z.object({
    prepare: zod.z.function(),
    waitForTransaction: zod.z.function(),
    getAddress: zod.z.function(),
});

/**
 * Validate that the adapter has sufficient token balance for a transaction.
 *
 * This function checks if the adapter's current token balance is greater than or equal
 * to the requested transaction amount. It throws a KitError with code 9001
 * (BALANCE_INSUFFICIENT_TOKEN) if the balance is insufficient, providing detailed
 * information about the shortfall.
 *
 * @param params - The validation parameters containing adapter, amount, token, and token address.
 * @returns A promise that resolves to void if validation passes.
 * @throws {KitError} When the adapter's balance is less than the required amount (code: 9001).
 *
 * @example
 * ```typescript
 * import { validateBalanceForTransaction } from '@core/adapter'
 * import { createViemAdapterFromPrivateKey } from '@circle-fin/adapter-viem-v2'
 * import { isKitError, ERROR_TYPES } from '@core/errors'
 *
 * const adapter = createViemAdapterFromPrivateKey({
 *   privateKey: '0x...',
 *   chain: 'Ethereum',
 * })
 *
 * try {
 *   await validateBalanceForTransaction({
 *     adapter,
 *     amount: '1000000', // 1 USDC (6 decimals)
 *     token: 'USDC',
 *     tokenAddress: '0xA0b86a33E6441c8C1c7C16e4c5e3e5b5e4c5e3e5b5e4c5e',
 *     operationContext: { chain: 'Ethereum' },
 *   })
 *   console.log('Balance validation passed')
 * } catch (error) {
 *   if (isKitError(error) && error.type === ERROR_TYPES.BALANCE) {
 *     console.error('Insufficient funds:', error.message)
 *   }
 * }
 * ```
 */
const validateBalanceForTransaction = async (params) => {
    const { amount, adapter, token, tokenAddress, operationContext } = params;
    const balancePrepared = await adapter.prepareAction('usdc.balanceOf', {
        walletAddress: operationContext.address,
    }, operationContext);
    const balance = await balancePrepared.execute();
    if (BigInt(balance) < BigInt(amount)) {
        // Extract chain name from operationContext
        const chainName = extractChainInfo(operationContext.chain).name;
        // Create KitError with rich context in trace
        throw createInsufficientTokenBalanceError(chainName, token, {
            balance: balance.toString(),
            amount,
            tokenAddress,
            walletAddress: operationContext.address,
        });
    }
};

/**
 * CCTP bridge step names that can occur in the bridging flow.
 *
 * This object provides type safety for step names and represents all possible
 * steps that can be executed during a CCTP bridge operation. Using const assertions
 * makes this tree-shakable and follows modern TypeScript best practices.
 */
const CCTPv2StepName = {
    approve: 'approve',
    burn: 'burn',
    fetchAttestation: 'fetchAttestation',
    mint: 'mint',
    reAttest: 'reAttest',
};
/**
 * Conditional step transition rules for CCTP bridge flow.
 *
 * Rules are evaluated in order - the first matching condition determines the next step.
 * This approach supports flexible flow logic and makes it easy to extend with new patterns.
 */
const STEP_TRANSITION_RULES = {
    // Starting state - no steps executed yet
    '': [
        {
            condition: () => true,
            nextStep: CCTPv2StepName.approve,
            reason: 'Start with approval step',
            isActionable: true,
        },
    ],
    // After Approve step
    [CCTPv2StepName.approve]: [
        {
            condition: (ctx) => ctx.lastStep?.state === 'success',
            nextStep: CCTPv2StepName.burn,
            reason: 'Approval successful, proceed to burn',
            isActionable: true,
        },
        {
            condition: (ctx) => ctx.lastStep?.state === 'error',
            nextStep: CCTPv2StepName.approve,
            reason: 'Retry failed approval',
            isActionable: true,
        },
        {
            condition: (ctx) => ctx.lastStep?.state === 'noop',
            nextStep: CCTPv2StepName.burn,
            reason: 'No approval needed, proceed to burn',
            isActionable: true,
        },
        {
            condition: (ctx) => ctx.lastStep?.state === 'pending',
            nextStep: CCTPv2StepName.approve,
            reason: 'Continue pending approval',
            isActionable: false, // Waiting for pending transaction
        },
    ],
    // After Burn step
    [CCTPv2StepName.burn]: [
        {
            condition: (ctx) => ctx.lastStep?.state === 'success',
            nextStep: CCTPv2StepName.fetchAttestation,
            reason: 'Burn successful, fetch attestation',
            isActionable: true,
        },
        {
            condition: (ctx) => ctx.lastStep?.state === 'error',
            nextStep: CCTPv2StepName.burn,
            reason: 'Retry failed burn',
            isActionable: true,
        },
        {
            condition: (ctx) => ctx.lastStep?.state === 'pending',
            nextStep: CCTPv2StepName.burn,
            reason: 'Continue pending burn',
            isActionable: false, // Waiting for pending transaction
        },
    ],
    // After FetchAttestation step
    [CCTPv2StepName.fetchAttestation]: [
        {
            condition: (ctx) => ctx.lastStep?.state === 'success',
            nextStep: CCTPv2StepName.mint,
            reason: 'Attestation fetched, proceed to mint',
            isActionable: true,
        },
        {
            condition: (ctx) => ctx.lastStep?.state === 'error',
            nextStep: CCTPv2StepName.fetchAttestation,
            reason: 'Retry fetching attestation',
            isActionable: true,
        },
        {
            condition: (ctx) => ctx.lastStep?.state === 'pending',
            nextStep: CCTPv2StepName.fetchAttestation,
            reason: 'Continue pending attestation fetch',
            isActionable: false, // Waiting for attestation to be ready
        },
    ],
    // After Mint step
    [CCTPv2StepName.mint]: [
        {
            condition: (ctx) => ctx.lastStep?.state === 'success',
            nextStep: null,
            reason: 'Bridge completed successfully',
            isActionable: false, // Nothing more to do
        },
        {
            condition: (ctx) => ctx.lastStep?.state === 'error',
            nextStep: CCTPv2StepName.mint,
            reason: 'Retry failed mint',
            isActionable: true,
        },
        {
            condition: (ctx) => ctx.lastStep?.state === 'pending',
            nextStep: CCTPv2StepName.mint,
            reason: 'Continue pending mint',
            isActionable: false, // Waiting for pending transaction
        },
    ],
    // After ReAttest step
    [CCTPv2StepName.reAttest]: [
        {
            condition: (ctx) => ctx.lastStep?.state === 'success',
            nextStep: CCTPv2StepName.mint,
            reason: 'Re-attestation successful, proceed to mint',
            isActionable: true,
        },
        {
            condition: (ctx) => ctx.lastStep?.state === 'error',
            nextStep: CCTPv2StepName.mint,
            reason: 'Re-attestation failed, retry mint to re-initiate recovery',
            isActionable: true,
        },
        {
            condition: (ctx) => ctx.lastStep?.state === 'pending',
            nextStep: CCTPv2StepName.mint,
            reason: 'Re-attestation pending, retry mint to re-initiate recovery',
            isActionable: true,
        },
    ],
};
/**
 * Analyze bridge steps to determine retry feasibility and continuation point.
 *
 * This function examines the current state of bridge steps to determine the optimal
 * continuation strategy. It uses a rule-based approach that makes it easy to extend
 * with new flow patterns and step types in the future.
 *
 * The current analysis supports the standard CCTP flow:
 * **Traditional flow**: Approve → Burn → FetchAttestation → Mint
 *
 * Key features:
 * - Rule-based transitions: Easy to extend with new step types and logic
 * - Context-aware decisions: Considers execution history and step states
 * - Actionable logic: Distinguishes between steps requiring user action vs waiting
 * - Terminal states: Properly handles completion and non-actionable states
 *
 * @param bridgeResult - The bridge result containing step execution history.
 * @returns Analysis result with continuation step and actionability information.
 * @throws Error when bridgeResult is invalid or contains no steps array.
 *
 * @example
 * ```typescript
 * import { analyzeSteps } from './analyzeSteps'
 *
 * // Failed approval step (requires user action)
 * const bridgeResult = {
 *   steps: [
 *     { name: 'Approve', state: 'error', errorMessage: 'User rejected' }
 *   ]
 * }
 *
 * const analysis = analyzeSteps(bridgeResult)
 * // Result: { continuationStep: 'Approve', isRetryable: true,
 * //          reason: 'Retry failed approval' }
 * ```
 *
 * @example
 * ```typescript
 * // Pending transaction (requires waiting, not actionable)
 * const bridgeResult = {
 *   steps: [
 *     { name: 'Approve', state: 'pending' }
 *   ]
 * }
 *
 * const analysis = analyzeSteps(bridgeResult)
 * // Result: { continuationStep: 'Approve', isRetryable: false,
 * //          reason: 'Continue pending approval' }
 * ```
 *
 * @example
 * ```typescript
 * // Completed bridge (nothing to do)
 * const bridgeResult = {
 *   steps: [
 *     { name: 'Approve', state: 'success' },
 *     { name: 'Burn', state: 'success' },
 *     { name: 'FetchAttestation', state: 'success' },
 *     { name: 'Mint', state: 'success' }
 *   ]
 * }
 *
 * const analysis = analyzeSteps(bridgeResult)
 * // Result: { continuationStep: null, isRetryable: false,
 * //          reason: 'Bridge completed successfully' }
 * ```
 */
const analyzeSteps = (bridgeResult) => {
    // Input validation
    if (!bridgeResult || !Array.isArray(bridgeResult.steps)) {
        throw new Error('Invalid bridgeResult: must contain a steps array');
    }
    const { steps } = bridgeResult;
    // Build execution context from step history
    const context = buildFlowContext(steps);
    // Determine continuation logic using rule engine
    const continuation = determineContinuationFromRules(context);
    return {
        continuationStep: continuation.nextStep,
        isActionable: continuation.isActionable,
        completedSteps: Array.from(context.completedSteps),
        failedSteps: Array.from(context.failedSteps),
        reason: continuation.reason,
    };
};
/**
 * Build flow context from the execution history.
 *
 * @param steps - Array of executed bridge steps.
 * @returns Flow context with execution state and history.
 */
function buildFlowContext(steps) {
    const completedSteps = new Set();
    const failedSteps = new Set();
    let lastStep;
    // Process step history to build context
    for (const step of steps) {
        if (step.state === 'success' || step.state === 'noop') {
            completedSteps.add(step.name);
        }
        else if (step.state === 'error') {
            failedSteps.add(step.name);
        }
        // Track the last step for continuation logic
        lastStep = {
            name: step.name,
            state: step.state,
        };
    }
    return {
        completedSteps,
        failedSteps,
        ...(lastStep && { lastStep }),
    };
}
/**
 * Determine continuation step using the rule engine.
 *
 * @param context - The flow context with execution history.
 * @returns Continuation decision with next step and actionability information.
 */
function determineContinuationFromRules(context) {
    const lastStepName = context.lastStep?.name;
    // Handle initial state when no steps have been executed
    if (lastStepName === undefined) {
        const rules = STEP_TRANSITION_RULES[''];
        const matchingRule = rules?.find((rule) => rule.condition(context));
        if (!matchingRule) {
            return {
                nextStep: null,
                isActionable: false,
                reason: 'No initial state rule found',
            };
        }
        return {
            nextStep: matchingRule.nextStep,
            isActionable: matchingRule.isActionable,
            reason: matchingRule.reason,
        };
    }
    // A step with an empty name is ambiguous and should be treated as an unrecoverable state.
    if (lastStepName === '') {
        return {
            nextStep: null,
            isActionable: false,
            reason: 'No transition rules defined for step with empty name',
        };
    }
    const rules = STEP_TRANSITION_RULES[lastStepName];
    if (!rules) {
        return {
            nextStep: null,
            isActionable: false,
            reason: `No transition rules defined for step: ${lastStepName}`,
        };
    }
    // Find the first matching rule
    const matchingRule = rules.find((rule) => rule.condition(context));
    if (!matchingRule) {
        return {
            nextStep: null,
            isActionable: false,
            reason: `No matching transition rule for current context`,
        };
    }
    return {
        nextStep: matchingRule.nextStep,
        isActionable: matchingRule.isActionable,
        reason: matchingRule.reason,
    };
}

/**
 * Find a step by name in the bridge result.
 *
 * @param result - The bridge result to search.
 * @param stepName - The name of the step to find.
 * @returns The step if found, undefined otherwise.
 *
 * @example
 * ```typescript
 * import { findStepByName } from './findStep'
 *
 * const burnStep = findStepByName(result, 'burn')
 * if (burnStep) {
 *   console.log('Burn tx:', burnStep.txHash)
 * }
 * ```
 */
function findStepByName(result, stepName) {
    return result.steps.find((step) => step.name === stepName);
}
/**
 * Find a pending step by name and return it with its index.
 *
 * Searches for a step that matches both the step name and has a pending state.
 *
 * @param result - The bridge result containing steps to search through.
 * @param stepName - The step name to find (e.g., 'burn', 'mint', 'fetchAttestation').
 * @returns An object containing the step and its index in the steps array.
 * @throws KitError if the specified pending step is not found.
 *
 * @example
 * ```typescript
 * import { findPendingStep } from './findStep'
 *
 * const { step, index } = findPendingStep(result, 'burn')
 * console.log('Pending step:', step.name, 'at index:', index)
 * ```
 */
function findPendingStep(result, stepName) {
    const index = result.steps.findIndex((step) => step.name === stepName && step.state === 'pending');
    if (index === -1) {
        throw new KitError({
            ...InputError.VALIDATION_FAILED,
            recoverability: 'FATAL',
            message: `Pending step "${stepName}" not found in result`,
        });
    }
    const step = result.steps[index];
    if (!step) {
        throw new KitError({
            ...InputError.VALIDATION_FAILED,
            recoverability: 'FATAL',
            message: 'Pending step is undefined',
        });
    }
    return { step, index };
}
/**
 * Get the burn transaction hash from bridge result.
 *
 * @param result - The bridge result.
 * @returns The burn transaction hash, or undefined if not found.
 *
 * @example
 * ```typescript
 * import { getBurnTxHash } from './findStep'
 *
 * const burnTxHash = getBurnTxHash(result)
 * if (burnTxHash) {
 *   console.log('Burn tx hash:', burnTxHash)
 * }
 * ```
 */
function getBurnTxHash(result) {
    return findStepByName(result, CCTPv2StepName.burn)?.txHash;
}
/**
 * Get the attestation data from bridge result.
 *
 * @param result - The bridge result.
 * @returns The attestation data, or undefined if not found.
 *
 * @example
 * ```typescript
 * import { getAttestationData } from './findStep'
 *
 * const attestation = getAttestationData(result)
 * if (attestation) {
 *   console.log('Attestation:', attestation.message)
 * }
 * ```
 */
function getAttestationData(result) {
    // Prefer reAttest data (most recent attestation after expiry)
    const reAttestStep = findStepByName(result, CCTPv2StepName.reAttest);
    if (reAttestStep?.state === 'success' && reAttestStep.data) {
        return reAttestStep.data;
    }
    // Fall back to fetchAttestation step
    const fetchStep = findStepByName(result, CCTPv2StepName.fetchAttestation);
    return fetchStep?.data;
}

/**
 * Determine if a step executes on the source chain.
 *
 * Source chain steps include approval and burn operations, which happen
 * on the originating blockchain before the CCTP message is sent.
 *
 * @param stepName - The name of the step to check.
 * @returns True if the step executes on the source chain, false if on destination chain.
 *
 * @example
 * ```typescript
 * import { isSourceChainStep } from './stepChainClassifier'
 *
 * isSourceChainStep('approve') // true
 * isSourceChainStep('burn') // true
 * isSourceChainStep('mint') // false
 * ```
 */
function isSourceChainStep(stepName) {
    return stepName === CCTPv2StepName.approve || stepName === CCTPv2StepName.burn;
}
/**
 * Determine which adapter and chain to use for a step.
 *
 * Uses step chain classification to return the appropriate adapter
 * and chain for executing or waiting on a step.
 *
 * @typeParam TFromAdapterCapabilities - The capabilities of the source adapter.
 * @typeParam TToAdapterCapabilities - The capabilities of the destination adapter.
 * @param step - The step object to determine context for.
 * @param context - The retry context containing source and destination adapters.
 * @param result - The bridge result containing chain information.
 * @returns An object with the appropriate adapter and chain for the step.
 *
 * @example
 * ```typescript
 * import { getStepAdapterAndChain } from './stepChainClassifier'
 *
 * const { adapter, chain } = getStepAdapterAndChain(burnStep, context, result)
 * // adapter = context.from (source adapter)
 * // chain = result.source.chain
 * ```
 */
function getStepAdapterAndChain(step, context, result) {
    const isSource = isSourceChainStep(step.name);
    return {
        adapter: (isSource ? context.from : context.to),
        chain: isSource ? result.source.chain : result.destination.chain,
    };
}

/**
 * Check if the analysis indicates a non-actionable pending state.
 *
 * A pending state is non-actionable when there's a continuation step but
 * the analysis marks it as not actionable, typically because we need to
 * wait for an ongoing operation to complete.
 *
 * @param analysis - The step analysis result from analyzeSteps.
 * @param result - The bridge result to check for pending steps.
 * @returns True if there is a pending step that we should wait for.
 *
 * @example
 * ```typescript
 * import { hasPendingState } from './stepUtils'
 * import { analyzeSteps } from '../analyzeSteps'
 *
 * const analysis = analyzeSteps(bridgeResult)
 * if (hasPendingState(analysis, bridgeResult)) {
 *   // Wait for the pending operation to complete
 * }
 * ```
 */
function hasPendingState(analysis, result) {
    // Check if there's a continuation step that's marked as non-actionable
    if (analysis.continuationStep === null || analysis.isActionable) {
        return false;
    }
    // Verify that the continuation step actually exists and is in pending state
    const pendingStep = result.steps.find((step) => step.name === analysis.continuationStep && step.state === 'pending');
    return pendingStep !== undefined;
}
/**
 * Check if the step is the last one in the execution flow.
 *
 * @param step - The step object to check.
 * @param stepNames - The ordered list of step names in the execution flow.
 * @returns True if this is the last step in the flow.
 *
 * @example
 * ```typescript
 * import { isLastStep } from './stepUtils'
 *
 * const stepNames = ['approve', 'burn', 'fetchAttestation', 'mint']
 * isLastStep({ name: 'mint' }, stepNames) // true
 * isLastStep({ name: 'burn' }, stepNames) // false
 * ```
 */
function isLastStep(step, stepNames) {
    const stepIndex = stepNames.indexOf(step.name);
    return stepIndex === -1 || stepIndex >= stepNames.length - 1;
}
/**
 * Wait for a pending transaction to complete.
 *
 * Poll the adapter until the transaction is confirmed on-chain and return
 * the updated step with success or error state based on the receipt.
 *
 * @param pendingStep - The full step object containing the transaction hash.
 * @param adapter - The adapter to use for waiting.
 * @param chain - The chain where the transaction was submitted.
 * @returns The updated step object with success or error state.
 *
 * @throws KitError when the pending step has no transaction hash.
 *
 * @example
 * ```typescript
 * import { waitForPendingTransaction } from './bridgeStepUtils'
 *
 * const pendingStep = { name: 'burn', state: 'pending', txHash: '0x123...' }
 * const updatedStep = await waitForPendingTransaction(pendingStep, adapter, chain)
 * // updatedStep.state is now 'success' or 'error'
 * ```
 */
async function waitForPendingTransaction(pendingStep, adapter, chain) {
    if (!pendingStep.txHash) {
        throw new KitError({
            ...InputError.VALIDATION_FAILED,
            recoverability: 'FATAL',
            message: `Cannot wait for pending ${pendingStep.name}: no transaction hash available`,
        });
    }
    const txReceipt = await adapter.waitForTransaction(pendingStep.txHash, undefined, chain);
    // Check if transaction was confirmed on-chain
    if (!txReceipt.blockNumber) {
        return {
            ...pendingStep,
            state: 'error',
            errorMessage: txReceipt.status === 'reverted'
                ? `Transaction ${pendingStep.txHash} was reverted`
                : 'Transaction was not confirmed on-chain',
            data: txReceipt,
        };
    }
    return {
        ...pendingStep,
        state: 'success',
        data: txReceipt,
    };
}
/**
 * Wait for a pending step to complete.
 *
 * For transaction steps: waits for the transaction to be confirmed.
 * For attestation: re-executes the attestation fetch.
 *
 * @typeParam TFromAdapterCapabilities - The capabilities of the source adapter.
 * @typeParam TToAdapterCapabilities - The capabilities of the destination adapter.
 * @param pendingStep - The full step object (with name, state, txHash, data, etc.) to resolve.
 * @param adapter - The adapter to use.
 * @param chain - The chain where the step is executing.
 * @param context - The retry context.
 * @param result - The bridge result.
 * @param provider - The CCTP v2 bridging provider.
 * @returns The resolved step object with updated state.
 *
 * @throws KitError when fetching attestation but burn transaction hash is not found.
 *
 * @example
 * ```typescript
 * import { waitForStepToComplete } from './bridgeStepUtils'
 *
 * const pendingStep = { name: 'burn', state: 'pending', txHash: '0x123...' }
 * const updatedStep = await waitForStepToComplete(
 *   pendingStep,
 *   adapter,
 *   chain,
 *   context,
 *   result,
 *   provider,
 * )
 * // updatedStep.state is now 'success' or 'error'
 * ```
 */
async function waitForStepToComplete(pendingStep, adapter, chain, context, result, provider) {
    if (pendingStep.name === CCTPv2StepName.fetchAttestation) {
        // For attestation, re-run the fetch (it has built-in polling)
        const burnTxHash = getBurnTxHash(result);
        if (!burnTxHash) {
            throw new KitError({
                ...InputError.VALIDATION_FAILED,
                recoverability: 'FATAL',
                message: 'Cannot fetch attestation: burn transaction hash not found',
            });
        }
        const sourceAddress = result.source.address;
        const attestation = await provider.fetchAttestation({
            chain: result.source.chain,
            adapter: context.from,
            address: sourceAddress,
        }, burnTxHash);
        return {
            ...pendingStep,
            state: 'success',
            data: attestation,
        };
    }
    // For transaction steps, wait for the transaction to complete
    return waitForPendingTransaction(pendingStep, adapter, chain);
}

/**
 * Executes a re-attestation operation to obtain a fresh attestation for an expired message.
 *
 * This function handles the re-attestation step of the CCTP v2 bridge process, where a fresh
 * attestation is requested from Circle's API when the original attestation has expired.
 * It first checks if the attestation has already been re-attested before making the API call.
 *
 * @param params - The bridge parameters containing source, destination, amount and optional config
 * @param provider - The CCTP v2 bridging provider
 * @param burnTxHash - The transaction hash of the original burn operation
 * @returns Promise resolving to the bridge step with fresh attestation data
 *
 * @example
 * ```typescript
 * const reAttestStep = await bridgeReAttest(
 *   { params, provider },
 *   burnTxHash
 * )
 * console.log('Fresh attestation:', reAttestStep.data)
 * ```
 */
async function bridgeReAttest({ params, provider, }, burnTxHash) {
    const step = {
        name: 'reAttest',
        state: 'pending',
    };
    try {
        // Fetch current attestation to check if already re-attested
        const currentAttestation = await provider.fetchAttestation(params.source, burnTxHash);
        // Check if already re-attested (expirationBlock === '0' means never expires)
        const expirationBlock = currentAttestation.decodedMessage.decodedMessageBody.expirationBlock;
        if (expirationBlock === '0') {
            // Already re-attested - return current attestation without calling reAttest API
            return { ...step, state: 'success', data: currentAttestation };
        }
        // Not yet re-attested - proceed with re-attestation request
        const reAttestedAttestation = await provider.reAttest(params.source, burnTxHash);
        return { ...step, state: 'success', data: reAttestedAttestation };
    }
    catch (err) {
        let errorMessage = 'Unknown re-attestation error';
        if (err instanceof Error) {
            errorMessage = err.message;
        }
        else if (typeof err === 'string') {
            errorMessage = err;
        }
        return {
            ...step,
            state: 'error',
            error: err,
            errorMessage,
            data: undefined,
        };
    }
}

/**
 * Extract context data from completed bridge steps for retry operations.
 *
 * Searches for the burn transaction hash and attestation data from the
 * completed steps, which are needed to continue a partially completed bridge.
 *
 * @param result - The bridge result containing completed steps.
 * @returns Step context with burn tx hash and attestation data (undefined if not found).
 */
function populateContext(result) {
    return {
        burnTxHash: getBurnTxHash(result),
        attestationData: getAttestationData(result),
    };
}
/**
 * Handle re-attestation and mint retry when mint fails due to expired attestation.
 *
 * @internal
 */
async function handleReAttestationAndRetry(params, provider, executor, updateContext, stepContext, result) {
    const burnTxHash = stepContext?.burnTxHash ?? getBurnTxHash(result);
    if (burnTxHash === undefined || burnTxHash === '') {
        handleStepError('mint', new Error('Cannot attempt re-attestation: Burn transaction hash not found in previous steps.'), result);
        return { success: false };
    }
    const reAttestStep = await bridgeReAttest({ params, provider }, burnTxHash);
    dispatchStepEvent('reAttest', reAttestStep, provider);
    result.steps.push(reAttestStep);
    if (reAttestStep.state === 'error') {
        result.state = 'error';
        return { success: false };
    }
    const freshContext = {
        ...stepContext,
        burnTxHash,
        attestationData: reAttestStep.data,
    };
    return executeMintRetry(params, provider, executor, freshContext, updateContext, result);
}
/**
 * Handle step execution error in retry loop.
 *
 * Determines if re-attestation should be attempted for mint failures,
 * or records the error and signals to exit the loop.
 *
 * @internal
 */
async function handleStepExecutionError(name, error, context) {
    const { params, provider, executor, updateContext, stepContext, result } = context;
    const shouldAttemptReAttestation = name === 'mint' && isMintFailureRelatedToAttestation(error);
    if (!shouldAttemptReAttestation) {
        handleStepError(name, error, result);
        return { shouldContinue: false };
    }
    const reAttestResult = await handleReAttestationAndRetry(params, provider, executor, updateContext, stepContext, result);
    if (!reAttestResult.success) {
        return { shouldContinue: false };
    }
    return { shouldContinue: true, stepContext: reAttestResult.stepContext };
}
/**
 * Execute mint retry with fresh attestation context.
 *
 * @internal
 */
async function executeMintRetry(params, provider, executor, freshContext, updateContext, result) {
    try {
        const retryStep = await executor(params, provider, freshContext);
        if (retryStep.state === 'error') {
            throw new Error(retryStep.errorMessage ?? 'mint step returned error state');
        }
        dispatchStepEvent('mint', retryStep, provider);
        result.steps.push(retryStep);
        return { success: true, stepContext: updateContext?.(retryStep) };
    }
    catch (retryError) {
        if (isMintFailureRelatedToAttestation(retryError)) {
            const kitError = createSimulationFailedError(result.destination.chain.name, getErrorMessage(retryError), { error: retryError });
            handleStepError('mint', kitError, result);
        }
        else {
            handleStepError('mint', retryError, result);
        }
        return { success: false };
    }
}
/**
 * Execute remaining bridge steps starting from a specific index.
 *
 * Handles the step execution loop with error handling and re-attestation support.
 * Returns true if all steps completed successfully, false if stopped due to error.
 *
 * @internal
 */
async function executeSteps(params, provider, result, startIndex) {
    let stepContext = populateContext(result);
    for (const { name, executor, updateContext } of stepExecutors.slice(startIndex)) {
        try {
            const step = await executor(params, provider, stepContext);
            if (step.state === 'error') {
                const errorMessage = step.errorMessage ?? `${name} step returned error state`;
                throw new Error(errorMessage);
            }
            stepContext = updateContext?.(step);
            dispatchStepEvent(name, step, provider);
            result.steps.push(step);
        }
        catch (error) {
            const errorResult = await handleStepExecutionError(name, error, {
                params,
                provider,
                executor,
                updateContext,
                stepContext,
                result,
            });
            if (!errorResult.shouldContinue) {
                return false;
            }
            stepContext = errorResult.stepContext;
        }
    }
    return true;
}
/**
 * Retry a failed or incomplete CCTP v2 bridge operation from where it left off.
 *
 * Analyzes the bridge result to determine the continuation point and executes
 * remaining steps in the CCTPv2 flow.
 *
 * @param result - The bridge result containing current state and step history.
 * @param context - The retry context with source and destination adapters.
 * @param provider - The CCTP v2 bridging provider for executing steps.
 * @returns Updated bridge result after retry execution.
 *
 * @throws Error when the result is not actionable or step execution fails.
 *
 * @example
 * ```typescript
 * const updatedResult = await retry(failedResult, retryContext, provider)
 * ```
 */
async function retry(result, context, provider) {
    const analysis = analyzeSteps(result);
    if (!analysis.isActionable) {
        if (analysis.continuationStep === null && result.state === 'success') {
            return result;
        }
        if (hasPendingState(analysis, result)) {
            return handlePendingState(result, context, provider, analysis);
        }
        throw new Error('Retry not supported for this result, requires user action');
    }
    if (!isCCTPV2Supported(result.source.chain)) {
        throw new Error(`Source chain ${result.source.chain.name} does not support CCTP v2`);
    }
    if (!isCCTPV2Supported(result.destination.chain)) {
        throw new Error(`Destination chain ${result.destination.chain.name} does not support CCTP v2`);
    }
    const params = {
        ...result,
        source: {
            ...result.source,
            adapter: context.from,
            chain: result.source.chain,
        },
        destination: {
            ...result.destination,
            adapter: context.to,
            chain: result.destination.chain,
        },
        config: result.config ?? {},
    };
    const indexOfSteps = stepExecutors.findIndex((step) => step.name === analysis.continuationStep);
    if (indexOfSteps === -1) {
        throw new Error(`Continuation step ${analysis.continuationStep ?? ''} not found`);
    }
    const completed = await executeSteps(params, provider, result, indexOfSteps);
    if (completed) {
        result.state = 'success';
    }
    return result;
}
/**
 * Handle pending state by waiting for the pending operation to complete.
 *
 * This orchestrator function coordinates the resolution of a pending step
 * by finding it, resolving it, updating the result, and continuing the flow.
 *
 * The flow uses both concepts:
 * - `analysis.continuationStep`: The step name (string like 'burn', 'mint', etc.)
 * - `currentStep`: The full step object (with state, txHash, data, etc.)
 *
 * @param result - The bridge result with pending step.
 * @param context - The retry context with adapters.
 * @param provider - The CCTP v2 bridging provider.
 * @param analysis - The analysis result containing the continuation step name.
 * @returns Updated bridge result after pending operation completes.
 */
async function handlePendingState(result, context, provider, analysis) {
    if (analysis.continuationStep === null || analysis.continuationStep === '') {
        // This should not be reachable due to the `hasPendingState` check,
        // but it ensures type safety for `continuationStep`.
        throw new KitError({
            ...InputError.VALIDATION_FAILED,
            recoverability: 'FATAL',
            message: 'No continuation step provided for pending state handling.',
        });
    }
    // Find the full step object using the continuation step name
    // - analysis.continuationStep: step name like 'burn', 'mint', etc. (string)
    // - currentStep: full step object with { name, state, txHash, data, ... }
    const { step: currentStep, index: currentStepIndex } = findPendingStep(result, analysis.continuationStep);
    const { adapter, chain } = getStepAdapterAndChain(currentStep, context, result);
    try {
        // Wait for the pending step to complete
        const updatedStep = await waitForStepToComplete(currentStep, adapter, chain, context, result, provider);
        // Update the step in the result
        result.steps[currentStepIndex] = updatedStep;
        // Dispatch event for the completed step
        dispatchStepEvent(currentStep.name, updatedStep, provider);
        // Handle errors
        if (updatedStep.state === 'error') {
            result.state = 'error';
            return result;
        }
        // Check if flow is complete
        const stepNames = stepExecutors.map((s) => s.name);
        if (isLastStep(currentStep, stepNames)) {
            result.state = 'success';
            return result;
        }
        // Continue with remaining steps.
        // Recursive call handles subsequent pending states (e.g., next step may also
        // be pending), allowing the retry logic to loop through all actionable steps.
        return await retry(result, context, provider);
    }
    catch (error) {
        // Re-throw FATAL validation errors - these indicate invalid input
        if (isFatalError(error)) {
            throw error;
        }
        // Handle recoverable errors gracefully
        handleStepError(currentStep.name, error, result);
        return result;
    }
}

/**
 * All chains that are supported by the CCTP v2 provider.
 *
 * This is a filtered list of all chains that are supported by the CCTP v2 provider.
 * It is used to initialize the `supportedChains` property of the `CCTPV2BridgingProvider`.
 *
 * @internal
 */
const SUPPORTED_CHAINS = Object.values(Chains).filter((chain) => isCCTPV2Supported(chain));
/**
 * Concrete implementation of BridgingProvider for Circle's Cross-Chain Transfer Protocol (CCTP) version 2.
 *
 * This provider handles cross-chain bridging using CCTP v2 contracts, which enable native USDC
 * bridging between supported blockchain networks. The provider supports burn-and-mint operations
 * with built-in validation, fee estimation, and transaction monitoring.
 *
 * The CCTPv2 provider is designed to be:
 * - **Type-safe**: Full TypeScript support with comprehensive validation
 * - **Flexible**: Support for both FAST and SLOW bridge configurations
 * - **Reliable**: Built-in error handling and recovery mechanisms
 * - **Observable**: Rich event emission for monitoring and debugging
 *
 * @example
 * ```typescript
 * import { CCTPV2BridgingProvider } from '@circle-fin/provider-cctp-v2'
 * import { createEvmAdapter } from '@circle-fin/adapter-viem-v2'
 *
 * const provider = new CCTPV2BridgingProvider()
 *
 * // Check route support
 * const isSupported = provider.supportsRoute('Ethereum', 'Base', 'USDC')
 *
 * // Create adapters
 * const sourceAdapter = createEvmAdapter({ privateKey: '0x...' })
 * const destAdapter = createEvmAdapter({ privateKey: '0x...' })
 *
 * // Prepare bridge parameters
 * const params: BridgeParams = {
 *   source: { adapter: sourceAdapter, chain: 'Ethereum' },
 *   destination: { adapter: destAdapter, chain: 'Base' },
 *   amount: '10.50',
 *   token: 'USDC',
 *   config: {
 *     transferSpeed: 'FAST',
 *   },
 * }
 *
 * // Estimate bridge costs
 * const estimate = await provider.estimate(params)
 * console.log('Estimated cost:', estimate.totalCost)
 *
 * // Execute bridge operation (when implemented)
 * const result = await provider.bridge(params)
 * console.log('Bridge completed!')
 * ```
 */
class CCTPV2BridgingProvider extends BridgingProvider {
    /** The name of the provider */
    name = 'CCTPV2BridgingProvider';
    /**
     * The chains that this provider supports.
     */
    supportedChains = SUPPORTED_CHAINS;
    /**
     * The provider's configuration.
     */
    config;
    /**
     * Creates a new instance of the CCTP v2 bridging provider.
     *
     * @param config - Optional configuration overrides for the provider
     */
    constructor(config = {}) {
        super();
        this.config = config;
    }
    /**
     * Execute a cross-chain USDC bridge operation using the CCTP v2 protocol.
     *
     * This method orchestrates the complete CCTP v2 bridge flow including validation,
     * token approval, burning on source chain, attestation retrieval, and minting on
     * destination chain. The process is atomic and will revert if any step fails.
     *
     * This method performs the full CCTP v2 bridge flow by validating parameters and delegating
     * to the core bridge logic. It handles token approval, burning, attestation fetching, and minting.
     *
     * The bridge operation consists of these sequential steps:
     * 1. **Approval**: Approve USDC spending (if needed)
     * 2. **Burn**: Burn USDC on source chain
     * 3. **Attestation**: Fetch attestation from Circle's API
     * 4. **Mint**: Mint USDC on destination chain
     *
     * @param params - The bridge parameters containing source, destination, amount, and optional config.
     * @returns A promise resolving to the bridge result, including transaction details, step states, and explorer URLs.
     * @throws {KitError} When the parameters are invalid.
     * @throws {BridgeError} When the bridge operation fails.
     * @throws {UnsupportedRouteError} When the route is not supported.
     *
     * @example
     * ```typescript
     * const result = await provider.bridge({
     *   source: { adapter: sourceAdapter, chain: 'Ethereum' },
     *   destination: { adapter: destAdapter, chain: 'Base' },
     *   amount: '10.50',
     *   token: 'USDC',
     *   config: { transferSpeed: 'FAST' }
     * })
     *
     * console.log('Bridge completed!')
     * console.log('Source tx:', result.steps.burn.transactionHash)
     * console.log('Destination tx:', result.steps.mint.transactionHash)
     * ```
     */
    async bridge(params) {
        // CCTP-specific bridge params validation (includes base validation)
        assertCCTPv2BridgeParams(params);
        const { source, amount, token } = params;
        // Extract operation context from source wallet context for balance validation
        const sourceOperationContext = this.extractOperationContext(source);
        // Validate USDC balance for transaction on source chain
        await validateBalanceForTransaction({
            adapter: source.adapter,
            amount,
            token,
            tokenAddress: source.chain.usdcAddress,
            operationContext: sourceOperationContext,
        });
        return bridge(params, this);
    }
    /**
     * Retry a failed or incomplete CCTP v2 bridge operation.
     *
     * Analyzes the bridge result to determine where to continue and executes
     * remaining steps from that point. Handles transaction failures, network
     * issues, and incomplete multi-step flows.
     *
     * @param result - The bridge result containing step history and current state.
     * @param context - The retry context with fresh adapter instances.
     * @returns Updated bridge result after retry execution.
     *
     * @throws Error when the result is not actionable or retry fails.
     *
     * @example
     * ```typescript
     * const retryResult = await provider.retry(failedResult, retryContext)
     * ```
     */
    async retry(result, context) {
        return retry(result, context, this);
    }
    /**
     * Estimate the cost and fees for a CCTP v2 cross-chain bridge operation.
     *
     * This method validates parameters and calculates the expected gas and protocol fees for a bridge
     * operation without executing it. The estimation includes gas costs for both source and destination
     * chains, as well as any applicable protocol fees.
     *
     * @param params - The bridge parameters containing source, destination, amount, and optional config.
     * @returns Promise resolving to detailed cost breakdown including:
     *          - `gasFees`: Array of gas estimates for each step (Approve, Burn, Mint)
     *            - Gas amounts in native token smallest units (wei for ETH, lamports for SOL, etc.)
     *          - `fees`: Array of protocol and kit fees
     *            - Provider fees in USDC decimal units (e.g., "0.1" USDC)
     *            - Kit fees in USDC decimal units if configured
     * @throws {KitError} When the parameters are invalid.
     * @throws {UnsupportedRouteError} When the route is not supported.
     *
     * @example
     * ```typescript
     * const estimate = await provider.estimate({
     *   source: { adapter: sourceAdapter, chain: 'Ethereum' },
     *   destination: { adapter: destAdapter, chain: 'Base' },
     *   amount: '10.50',
     *   token: 'USDC'
     * })
     *
     * console.log('Total cost:', estimate.totalCost)
     * console.log('Source gas:', estimate.sourceGas)
     * console.log('Destination gas:', estimate.destinationGas)
     * ```
     */
    async estimate(params) {
        // CCTP-specific transfer params validation (includes base validation)
        assertCCTPv2BridgeParams(params);
        const { source, destination, amount } = params;
        const estimateBurn = async () => {
            const burn = await this.burn(params);
            return await burn.estimate(undefined, await source.adapter.calculateTransactionFee(hasCustomContractSupport(source.chain, 'bridge')
                ? CUSTOM_BURN_GAS_ESTIMATE_EVM
                : DEPOSIT_FOR_BURN_GAS_ESTIMATE_EVM, undefined, source.chain));
        };
        const estimateMint = async () => {
            const mint = await this.mint(source, destination, mockAttestationMessage);
            return await mint.estimate(undefined, await destination.adapter.calculateTransactionFee(RECEIVE_MESSAGE_GAS_ESTIMATE_EVM, undefined, destination.chain));
        };
        // Parallelize all independent async operations
        const [approveEstimate, depositForBurnFee, receiveMessageFee, maxFee] = await Promise.allSettled([
            this.approve(source, amount).then(async (approve) => approve.estimate()),
            estimateBurn(),
            estimateMint(),
            params.config?.transferSpeed === undefined ||
                params.config?.transferSpeed === TransferSpeed.FAST
                ? this.getMaxFee(params)
                : Promise.resolve(0n),
        ]);
        const estimateResult = {
            token: params.token,
            amount: params.amount,
            source: {
                address: source.address,
                chain: source.chain.chain,
            },
            destination: {
                address: destination.address,
                chain: destination.chain.chain,
                ...(destination.recipientAddress && {
                    recipientAddress: destination.recipientAddress,
                }),
            },
            gasFees: [],
            fees: [],
        };
        // Process gas fee estimates
        this.addGasFeeEstimate(estimateResult, approveEstimate, 'Approve', source);
        this.addGasFeeEstimate(estimateResult, depositForBurnFee, 'Burn', source);
        this.addGasFeeEstimate(estimateResult, receiveMessageFee, 'Mint', destination);
        // Process provider fee estimate
        this.addProviderFeeEstimate(estimateResult, maxFee);
        this.addKitFeeEstimate(estimateResult, params.config?.customFee?.value);
        return estimateResult;
    }
    /**
     * Extracts OperationContext from bridge parameters for a given wallet context.
     *
     * This method extracts the chain and address information from the wallet context
     * to construct an OperationContext for use with adapter method calls.
     *
     * @param walletContext - The wallet context to extract operation context from
     * @returns The operation context with chain and address information
     */
    extractOperationContext(walletContext) {
        return {
            chain: walletContext.chain,
            address: walletContext.address,
        };
    }
    /**
     * Helper method to add gas fee estimates to the result.
     */
    addGasFeeEstimate(result, estimate, name, walletContext) {
        try {
            if (estimate.status === 'fulfilled') {
                const formattedFee = formatUnits(estimate.value.fee, walletContext.chain.nativeCurrency.decimals);
                result.gasFees.push({
                    name,
                    token: walletContext.chain.nativeCurrency.symbol,
                    blockchain: walletContext.chain.chain,
                    fees: {
                        gas: estimate.value.gas,
                        gasPrice: estimate.value.gasPrice,
                        fee: formattedFee,
                    },
                });
            }
            else {
                throw new Error(estimate.reason);
            }
        }
        catch (err) {
            result.gasFees.push({
                name,
                token: walletContext.chain.nativeCurrency.symbol,
                blockchain: walletContext.chain.chain,
                fees: null,
                error: err,
            });
        }
    }
    /**
     * Helper method to add provider fee estimates to the result.
     */
    addProviderFeeEstimate(result, maxFeeEstimate) {
        try {
            if (maxFeeEstimate.status === 'fulfilled') {
                const formattedMaxFee = formatUnits(String(maxFeeEstimate.value), 6);
                result.fees.push({
                    type: 'provider',
                    token: 'USDC',
                    amount: formattedMaxFee,
                });
            }
            else {
                throw new Error(maxFeeEstimate.reason);
            }
        }
        catch (err) {
            result.fees.push({
                type: 'provider',
                token: 'USDC',
                amount: null,
                error: err,
            });
        }
    }
    /**
     * Helper method to add kit fee to the result.
     */
    addKitFeeEstimate(result, customFee) {
        try {
            if (customFee && BigInt(customFee) > 0n) {
                const formattedCustomFee = formatUnits(customFee, 6);
                result.fees.push({
                    type: 'kit',
                    token: 'USDC',
                    amount: formattedCustomFee,
                });
            }
        }
        catch (err) {
            result.fees.push({
                type: 'kit',
                token: 'USDC',
                amount: null,
                error: err,
            });
        }
    }
    /**
     * Prepares a USDC token approval transaction for CCTP v2 transfers.
     *
     * This method creates a prepared transaction that approves the CCTP v2 contract
     * to spend a specified amount of USDC tokens. The approval is required before
     * initiating a cross-chain burn operation.
     *
     * @param adapter - The adapter for transaction preparation and execution
     * @param amount - The amount of USDC to approve (as string to avoid precision issues)
     * @returns Promise resolving to a prepared chain request ready for gas estimation and execution
     *
     * @throws Error when adapter is not provided
     * @throws Error when amount is invalid (empty, negative, or malformed)
     * @throws Error when chain does not support CCTP v2
     * @throws Error when chain does not have USDC configured
     * @throws Error when CCTP v2 contracts are missing or misconfigured
     *
     * @example
     * ```typescript
     * const provider = new CCTPV2BridgingProvider()
     * const prepared = await provider.approve(adapter, '1000000') // 1 USDC (6 decimals)
     *
     * // Estimate gas cost
     * const gasEstimate = await prepared.estimate()
     * console.log('Gas required:', gasEstimate.gas)
     *
     * // Execute the approval
     * const txHash = await prepared.execute()
     * console.log('Approval transaction:', txHash)
     * ```
     */
    async approve(source, amount) {
        assertCCTPv2WalletContext(source);
        const { chain, adapter } = source;
        // Extract operation context from source wallet context
        const operationContext = this.extractOperationContext(source);
        // Resolve operation context to get concrete chain and address values
        let resolvedContext;
        try {
            resolvedContext = await resolveOperationContext(adapter, operationContext);
        }
        catch (error) {
            throw new Error(`Failed to resolve operation context: ${error instanceof Error ? error.message : String(error)}`);
        }
        // Resolve spender address with proper error handling
        const spenderAddress = resolveCCTPV2ContractAddress(chain);
        // Prepare action parameters
        const actionParams = {
            amount: BigInt(amount),
            delegate: spenderAddress,
            chain: resolvedContext?.chain ?? chain,
        };
        return await adapter.prepareAction('usdc.increaseAllowance', actionParams, resolvedContext);
    }
    /**
     * Prepares a CCTP v2 token minting transaction on the destination chain.
     *
     * This method creates a prepared transaction that calls the receiveMessage function
     * on the CCTP v2 MessageTransmitter contract to finalize the cross-chain transfer.
     * It's used to mint tokens on the destination chain after a successful burn operation
     * on the source chain.
     *
     * @param adapter - The adapter for transaction preparation and execution
     * @param messageBytes - The encoded message bytes from the source chain burn transaction
     * @param attestation - The attestation signature from Circle proving the burn happened
     * @returns Promise resolving to a prepared chain request ready for gas estimation and execution
     *
     * @throws Error when adapter is not provided
     * @throws Error when messageBytes is invalid (empty or malformed)
     * @throws Error when attestation is invalid (empty or malformed)
     * @throws Error when chain does not support CCTP v2
     * @throws Error when CCTP v2 contracts are missing or misconfigured
     *
     * @example
     * ```typescript
     * const provider = new CCTPV2BridgingProvider()
     * const prepared = await provider.mint(
     *   destAdapter,
     *   '0x1234...', // message bytes from burn transaction
     *   '0xabcd...'  // attestation from Circle
     * )
     *
     * // Estimate gas cost
     * const gasEstimate = await prepared.estimate()
     * console.log('Gas required:', gasEstimate.gas)
     *
     * // Execute the mint transaction
     * const txHash = await prepared.execute()
     * console.log('Mint transaction:', txHash)
     * ```
     */
    async mint(source, destination, attestation) {
        assertCCTPv2WalletContext(source);
        assertCCTPv2WalletContext(destination);
        // Extract operation context from destination wallet context
        const operationContext = this.extractOperationContext(destination);
        // Use recipientAddress if provided, otherwise use destination.address
        const destinationAddressForMint = destination.recipientAddress ?? destination.address;
        // Prepare action parameters
        const actionParams = {
            fromChain: source.chain,
            toChain: destination.chain,
            message: attestation.message,
            attestation: attestation.attestation,
            eventNonce: attestation.eventNonce,
            destinationAddress: destinationAddressForMint,
        };
        return await destination.adapter.prepareAction('cctp.v2.receiveMessage', actionParams, operationContext);
    }
    /**
     * Fetches attestation data for a burn transaction from the IRIS API.
     *
     * This method retrieves the attestation data required to complete a mint operation
     * after a successful burn. It includes retry logic and timeout handling to ensure
     * reliable attestation fetching.
     *
     * @param sourceDomainId - The CCTP domain ID of the source chain
     * @param transactionHash - The transaction hash of the burn operation
     * @param isTestnet - Whether this is for a testnet chain (true) or mainnet chain (false)
     * @param config - Optional configuration overrides for this specific request
     * @returns Promise resolving to the first attestation message
     * @throws Error If no attestation is found for the transaction
     * @throws Error If the request times out after retries
     * @throws Error If the IRIS API returns an error response
     * @throws Error If the response format is invalid
     *
     * @example
     * ```typescript
     * const provider = new CCTPV2BridgingProvider({
     *   attestation: { maxRetries: 5 } // Global config
     * })
     *
     * try {
     *   // Use global config for mainnet
     *   const result1 = await provider.fetchAttestation(1, '0x123...', false)
     *
     *   // Override for this specific call on testnet
     *   const result2 = await provider.fetchAttestation(1, '0x456...', true, {
     *     timeout: 5000 // Override just the timeout
     *   })
     * } catch (error) {
     *   if (error.message.includes('No attestation found')) {
     *     // Handle missing attestation
     *   } else if (error.message.includes('Request timed out')) {
     *     // Handle timeout
     *   } else if (error.message.includes('HTTP 4')) {
     *     // Handle API error
     *   } else {
     *     // Handle other errors
     *   }
     * }
     * ```
     */
    async fetchAttestation(source, transactionHash, config) {
        assertCCTPv2WalletContext(source);
        try {
            // Merge configs: defaults <- global config <- per-call config
            const effectiveConfig = {
                ...this.config?.attestation,
                ...config,
            };
            const response = await fetchAttestation(source.chain.cctp.domain, transactionHash, source.chain.isTestnet, effectiveConfig);
            const message = response.messages[0];
            if (!message) {
                throw new Error('Failed to fetch attestation: No attestation found for the given transaction');
            }
            return message;
        }
        catch (err) {
            const error = err instanceof Error ? err : new Error(String(err));
            // Always prefix with 'Failed to fetch attestation'
            if (!error.message.startsWith('Failed to fetch attestation')) {
                throw new Error(`Failed to fetch attestation: ${error.message}`);
            }
            throw error;
        }
    }
    /**
     * Requests a fresh attestation for an expired attestation.
     *
     * This method is used when the original attestation has expired before the mint
     * transaction could be completed. It performs three steps:
     * 1. Fetches the existing attestation data to extract the nonce
     * 2. Requests re-attestation from Circle's API using the nonce
     * 3. Polls for the fresh attestation and returns it
     *
     * @typeParam TFromAdapterCapabilities - The type representing the capabilities of the source adapter
     * @param source - The source wallet context containing the chain definition and wallet address
     * @param transactionHash - The transaction hash of the original burn transaction
     * @param config - Optional polling configuration overrides for timeout, retries, and delay
     * @returns A promise that resolves to the fresh attestation message
     * @throws {Error} With "Failed to re-attest: No nonce found for transaction" if the original
     *   attestation cannot be found or has no nonce
     * @throws {Error} With "Failed to re-attest: No attestation found after re-attestation request"
     *   if the fresh attestation cannot be retrieved
     * @throws {Error} With "Failed to re-attest: {details}" for other errors
     *
     * @example
     * ```typescript
     * import { CCTPV2BridgingProvider } from '@circle-fin/provider-cctp-v2'
     * import { Chains } from '@core/chains'
     *
     * const provider = new CCTPV2BridgingProvider()
     *
     * // After a mint fails due to expired attestation, request a fresh one
     * const source = {
     *   adapter: viemAdapter,
     *   chain: Chains.EthereumSepolia,
     *   address: '0x1234...'
     * }
     *
     * try {
     *   const freshAttestation = await provider.reAttest(
     *     source,
     *     '0xabc123...', // Original burn transaction hash
     *     { timeout: 10000, maxRetries: 5 }
     *   )
     *
     *   // Use the fresh attestation to retry the mint
     *   const mintRequest = await provider.mint(source, destination, freshAttestation)
     *   const result = await mintRequest.execute()
     * } catch (error) {
     *   console.error('Re-attestation failed:', error.message)
     * }
     * ```
     */
    async reAttest(source, transactionHash, config) {
        assertCCTPv2WalletContext(source);
        if (!transactionHash ||
            typeof transactionHash !== 'string' ||
            transactionHash.trim() === '') {
            throw new Error('Failed to re-attest: Invalid transaction hash');
        }
        try {
            // Merge configs: defaults <- global config <- per-call config
            const effectiveConfig = {
                ...this.config?.attestation,
                ...config,
            };
            // Step 1: Get existing attestation data to extract nonce
            const existingAttestation = await fetchAttestationWithoutStatusCheck(source.chain.cctp.domain, transactionHash, source.chain.isTestnet, effectiveConfig);
            const nonce = existingAttestation.messages[0]?.eventNonce;
            if (!nonce || typeof nonce !== 'string') {
                throw new Error('Failed to re-attest: No nonce found for transaction');
            }
            // Step 2: Request re-attestation
            await requestReAttestation(nonce, source.chain.isTestnet, effectiveConfig);
            // Step 3: Poll for fresh attestation until expirationBlock === '0'
            // The expiration block transitions from non-zero to zero when Circle
            // completes processing the re-attestation request.
            const response = await fetchReAttestedAttestation(source.chain.cctp.domain, transactionHash, source.chain.isTestnet, effectiveConfig);
            const message = response.messages[0];
            if (!message) {
                throw new Error('Failed to re-attest: No attestation found after re-attestation request');
            }
            return message;
        }
        catch (err) {
            const error = err instanceof Error ? err : new Error(String(err));
            // Always prefix with 'Failed to re-attest'
            if (!error.message.startsWith('Failed to re-attest')) {
                throw new Error(`Failed to re-attest: ${error.message}`);
            }
            throw error;
        }
    }
    /**
     * Checks if both source and destination chains support CCTP v2 transfers.
     *
     * This method validates that both chains have CCTP v2 contracts deployed and configured.
     * It uses the `isCCTPV2Supported` guard function to check each chain individually.
     *
     * @param source - The source chain definition to check for CCTP v2 support
     * @param destination - The destination chain definition to check for CCTP v2 support
     * @returns `true` if both chains support CCTP v2, `false` otherwise
     *
     * @example
     * ```typescript
     * const provider = new CCTPV2BridgingProvider()
     * const canTransfer = provider.supportsRoute(Ethereum, Base)
     *
     * if (canTransfer) {
     *   console.log('CCTP v2 transfer is supported between these chains')
     * } else {
     *   console.log('One or both chains do not support CCTP v2')
     * }
     * ```
     */
    supportsRoute(source, destination, token) {
        if (source.chain === destination.chain) {
            return false;
        }
        if (source.isTestnet !== destination.isTestnet) {
            return false;
        }
        if (token === 'USDC') {
            return isCCTPV2Supported(source) && isCCTPV2Supported(destination);
        }
        return false;
    }
    /**
     * Determines the appropriate maximum fee for a cross-chain bridge operation.
     *
     * For FAST bridge operations, it calculates a dynamic fee based on the bridge amount
     * and fast bridge burn fee, or uses a provided maxFee if specified.
     *
     * For SLOW bridge operations, it returns 0 as there are no additional fees.
     *
     * @param params - The bridge parameters object containing:
     *   - `source`: The source wallet context with chain definition and adapter
     *   - `destination`: The destination wallet context with chain definition and adapter
     *   - `amount`: The bridge amount in minor units (e.g., "1000000" for 1 USDC)
     *   - `config`: Optional bridge configuration including transferSpeed and maxFee settings.
     *     When used via BridgeKit, fee values are automatically converted from human-readable
     *     format (e.g., "1") to smallest units (e.g., "1000000").
     * @returns The maximum fee to be used for the bridge operation in minor units
     *
     * @example
     * ```typescript
     * const maxFee = await provider.getMaxFee({
     *   source: { adapter: sourceAdapter, chain: Chains.Ethereum, address: '0x...' },
     *   destination: { adapter: destAdapter, chain: Chains.Base, address: '0x...' },
     *   amount: '1000000', // 1 USDC in minor units
     *   token: 'USDC',
     *   config: {
     *     transferSpeed: TransferSpeed.FAST,
     *     maxFee: '1000000' // Provider receives values in smallest units
     *   }
     * })
     * console.log('Max fee:', maxFee)
     * ```
     */
    async getMaxFee(params) {
        assertCCTPv2BridgeParams(params);
        const { source, destination, amount, config } = params;
        // Default to fast transfer if `transferSpeed` is not provided in the config
        const transferSpeed = config?.transferSpeed ?? TransferSpeed.FAST;
        // Calculate the max fee based on the transfer speed
        let maxFee;
        if (transferSpeed === TransferSpeed.SLOW) {
            // If the transfer speed is slow, set the max fee to 0 (no fee)
            maxFee = 0n;
        }
        else if (config?.maxFee === undefined) {
            // If the max fee is not provided and the transfer speed is fast, dynamically calculate the max fee
            const scaledBps = await fetchUsdcFastBurnFee(source.chain.cctp.domain, destination.chain.cctp.domain, source.chain.isTestnet);
            // Calculate fee proportional to the transfer amount
            // Convert amount to minor units
            const amountInMinorUnits = BigInt(amount);
            // Calculate base fee proportional to the transfer amount
            // The API returns basis points as a decimal (e.g., "1.3" for 1.3 bps).
            // fetchUsdcFastBurnFee scales by 100 to preserve precision, so we divide by 1,000,000.
            // Formula: (scaledBps * amountInMinorUnits) / 1_000_000
            // We use ceiling division (round up) to ensure sufficient fees and avoid failover to slow burn
            // Ceiling division: (a + b - 1) / b, where b = 1_000_000, so (b - 1) = 999_999n
            const baseFee = (scaledBps * amountInMinorUnits + 999999n) / 1000000n;
            // Add 10% buffer to account for fee fluctuations: fee + (fee * 10 / 100) = fee + (fee / 10)
            maxFee = baseFee + baseFee / 10n;
        }
        else {
            // Use the max fee from the config (converted to minor units by BridgeKit)
            maxFee = BigInt(config.maxFee);
        }
        return maxFee;
    }
    /**
     * Prepares a CCTP v2 burn operation to initiate a cross-chain bridge operation.
     *
     * This method creates the necessary transaction data for burning USDC tokens on the source
     * chain as part of the CCTP v2 bridge flow. The burn operation locks the tokens and emits
     * a message that can be used to mint equivalent tokens on the destination chain.
     *
     * @param params - The bridge parameters including source, destination, amount, and config
     * @returns Promise resolving to the prepared burn transaction data
     *
     * @example
     * ```typescript
     * const preparedBurn = await provider.burn(
     *   {
     *     source: { adapter, chain: "Ethereum_Sepolia" },
     *     destination: { adapter, chain: "Base_Sepolia" },
     *     amount: '1000000', // 1 USDC
     *     token: 'USDC',
     *     config: { transferSpeed: 'FAST' }
     *   }
     * )
     * await preparedBurn.execute()
     * ```
     */
    async burn(params) {
        assertCCTPv2BridgeParams(params);
        const { source, destination, amount, config } = params;
        // Default to fast transfer if `transferSpeed` is not provided in the config
        const transferSpeed = config?.transferSpeed ?? TransferSpeed.FAST;
        // Get the min finality threshold based on the transfer speed
        const minFinalityThreshold = CCTPv2MinFinalityThreshold[transferSpeed];
        // Calculate the max fee
        // Use recipientAddress if provided, otherwise use destination.address
        const destinationAddressForMint = destination.recipientAddress ?? destination.address;
        const [maxFee, mintRecipient] = await Promise.all([
            this.getMaxFee(params),
            getMintRecipientAccount(destination.chain.type, destinationAddressForMint, destination.chain.usdcAddress),
        ]);
        const actionParams = {
            fromChain: source.chain,
            toChain: destination.chain,
            amount: BigInt(amount),
            mintRecipient: convertAddress(mintRecipient, 'bytes32'),
            maxFee,
            minFinalityThreshold,
        };
        const { recipientAddress, value } = params.config.customFee ?? {};
        const protocolFee = value ? BigInt(value) : undefined;
        // Extract operation context from source wallet context
        const operationContext = this.extractOperationContext(source);
        // Resolve operation context to get concrete chain and address values
        let resolvedContext;
        try {
            resolvedContext = await resolveOperationContext(source.adapter, operationContext);
        }
        catch (error) {
            throw new Error(`Failed to resolve operation context: ${error instanceof Error ? error.message : String(error)}`);
        }
        // Determine action and params once
        const useCustomBurn = hasCustomContractSupport(source.chain, 'bridge');
        const actionType = useCustomBurn
            ? 'cctp.v2.customBurn'
            : 'cctp.v2.depositForBurn';
        const finalParams = useCustomBurn
            ? { ...actionParams, feeRecipient: recipientAddress, protocolFee }
            : actionParams;
        return await source.adapter.prepareAction(actionType, finalParams, resolvedContext);
    }
    /**
     * Waits for a transaction to be mined and confirmed on the blockchain.
     *
     * This method should block until the transaction is confirmed on the blockchain.
     *
     * @param adapter - The adapter to use for transaction waiting
     * @param txHash - The hash of the transaction to wait for
     * @param chain - The chain definition where the transaction was executed
     * @param config - Optional configuration for transaction waiting (confirmations, timeout)
     * @returns The hash of the confirmed transaction
     * @example
     * ```typescript
     * const provider = new CCTPV2BridgingProvider()
     * const txHash = await provider.waitForTransaction(
     *   adapter,
     *   '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
     *   Ethereum,
     * )
     * console.log('Transaction confirmed:', txHash)
     * ```
     */
    async waitForTransaction(adapter, txHash, chain, config) {
        return adapter.waitForTransaction(txHash, config, chain);
    }
}

exports.CCTPV2BridgingProvider = CCTPV2BridgingProvider;
exports.getBlocksUntilExpiry = getBlocksUntilExpiry;
exports.getMintRecipientAccount = getMintRecipientAccount;
exports.isAttestationExpired = isAttestationExpired;
exports.isMintFailureRelatedToAttestation = isMintFailureRelatedToAttestation;
//# sourceMappingURL=index.cjs.map
