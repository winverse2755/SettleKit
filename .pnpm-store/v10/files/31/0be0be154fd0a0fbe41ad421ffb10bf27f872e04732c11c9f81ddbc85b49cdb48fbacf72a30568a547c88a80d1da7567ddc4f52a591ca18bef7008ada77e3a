import type { BaseContract, BigNumberish, BytesLike, FunctionFragment, Result, Interface, EventFragment, AddressLike, ContractRunner, ContractMethod, Listener } from "ethers";
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedLogDescription, TypedListener, TypedContractMethod } from "../../../common";
export type MarketParamsStruct = {
    loanToken: AddressLike;
    collateralToken: AddressLike;
    oracle: AddressLike;
    irm: AddressLike;
    lltv: BigNumberish;
};
export type MarketParamsStructOutput = [
    loanToken: string,
    collateralToken: string,
    oracle: string,
    irm: string,
    lltv: bigint
] & {
    loanToken: string;
    collateralToken: string;
    oracle: string;
    irm: string;
    lltv: bigint;
};
export type AuthorizationStruct = {
    authorizer: AddressLike;
    authorized: AddressLike;
    isAuthorized: boolean;
    nonce: BigNumberish;
    deadline: BigNumberish;
};
export type AuthorizationStructOutput = [
    authorizer: string,
    authorized: string,
    isAuthorized: boolean,
    nonce: bigint,
    deadline: bigint
] & {
    authorizer: string;
    authorized: string;
    isAuthorized: boolean;
    nonce: bigint;
    deadline: bigint;
};
export type SignatureStruct = {
    v: BigNumberish;
    r: BytesLike;
    s: BytesLike;
};
export type SignatureStructOutput = [v: bigint, r: string, s: string] & {
    v: bigint;
    r: string;
    s: string;
};
export interface MorphoBlueInterface extends Interface {
    getFunction(nameOrSignature: "DOMAIN_SEPARATOR" | "accrueInterest" | "borrow" | "createMarket" | "enableIrm" | "enableLltv" | "extSloads" | "feeRecipient" | "flashLoan" | "idToMarketParams" | "isAuthorized" | "isIrmEnabled" | "isLltvEnabled" | "liquidate" | "market" | "nonce" | "owner" | "position" | "repay" | "setAuthorization" | "setAuthorizationWithSig" | "setFee" | "setFeeRecipient" | "setOwner" | "supply" | "supplyCollateral" | "withdraw" | "withdrawCollateral"): FunctionFragment;
    getEvent(nameOrSignatureOrTopic: "AccrueInterest" | "Borrow" | "CreateMarket" | "EnableIrm" | "EnableLltv" | "FlashLoan" | "IncrementNonce" | "Liquidate" | "Repay" | "SetAuthorization" | "SetFee" | "SetFeeRecipient" | "SetOwner" | "Supply" | "SupplyCollateral" | "Withdraw" | "WithdrawCollateral"): EventFragment;
    encodeFunctionData(functionFragment: "DOMAIN_SEPARATOR", values?: undefined): string;
    encodeFunctionData(functionFragment: "accrueInterest", values: [MarketParamsStruct]): string;
    encodeFunctionData(functionFragment: "borrow", values: [
        MarketParamsStruct,
        BigNumberish,
        BigNumberish,
        AddressLike,
        AddressLike
    ]): string;
    encodeFunctionData(functionFragment: "createMarket", values: [MarketParamsStruct]): string;
    encodeFunctionData(functionFragment: "enableIrm", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "enableLltv", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "extSloads", values: [BytesLike[]]): string;
    encodeFunctionData(functionFragment: "feeRecipient", values?: undefined): string;
    encodeFunctionData(functionFragment: "flashLoan", values: [AddressLike, BigNumberish, BytesLike]): string;
    encodeFunctionData(functionFragment: "idToMarketParams", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "isAuthorized", values: [AddressLike, AddressLike]): string;
    encodeFunctionData(functionFragment: "isIrmEnabled", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "isLltvEnabled", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "liquidate", values: [
        MarketParamsStruct,
        AddressLike,
        BigNumberish,
        BigNumberish,
        BytesLike
    ]): string;
    encodeFunctionData(functionFragment: "market", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "nonce", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "owner", values?: undefined): string;
    encodeFunctionData(functionFragment: "position", values: [BytesLike, AddressLike]): string;
    encodeFunctionData(functionFragment: "repay", values: [
        MarketParamsStruct,
        BigNumberish,
        BigNumberish,
        AddressLike,
        BytesLike
    ]): string;
    encodeFunctionData(functionFragment: "setAuthorization", values: [AddressLike, boolean]): string;
    encodeFunctionData(functionFragment: "setAuthorizationWithSig", values: [AuthorizationStruct, SignatureStruct]): string;
    encodeFunctionData(functionFragment: "setFee", values: [MarketParamsStruct, BigNumberish]): string;
    encodeFunctionData(functionFragment: "setFeeRecipient", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "setOwner", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "supply", values: [
        MarketParamsStruct,
        BigNumberish,
        BigNumberish,
        AddressLike,
        BytesLike
    ]): string;
    encodeFunctionData(functionFragment: "supplyCollateral", values: [MarketParamsStruct, BigNumberish, AddressLike, BytesLike]): string;
    encodeFunctionData(functionFragment: "withdraw", values: [
        MarketParamsStruct,
        BigNumberish,
        BigNumberish,
        AddressLike,
        AddressLike
    ]): string;
    encodeFunctionData(functionFragment: "withdrawCollateral", values: [MarketParamsStruct, BigNumberish, AddressLike, AddressLike]): string;
    decodeFunctionResult(functionFragment: "DOMAIN_SEPARATOR", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "accrueInterest", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "borrow", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "createMarket", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "enableIrm", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "enableLltv", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "extSloads", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "feeRecipient", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "flashLoan", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "idToMarketParams", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isAuthorized", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isIrmEnabled", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isLltvEnabled", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "liquidate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "market", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "nonce", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "position", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "repay", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setAuthorization", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setAuthorizationWithSig", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setFee", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setFeeRecipient", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setOwner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "supply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "supplyCollateral", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "withdrawCollateral", data: BytesLike): Result;
}
export declare namespace AccrueInterestEvent {
    type InputTuple = [
        id: BytesLike,
        prevBorrowRate: BigNumberish,
        interest: BigNumberish,
        feeShares: BigNumberish
    ];
    type OutputTuple = [
        id: string,
        prevBorrowRate: bigint,
        interest: bigint,
        feeShares: bigint
    ];
    interface OutputObject {
        id: string;
        prevBorrowRate: bigint;
        interest: bigint;
        feeShares: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace BorrowEvent {
    type InputTuple = [
        id: BytesLike,
        caller: AddressLike,
        onBehalf: AddressLike,
        receiver: AddressLike,
        assets: BigNumberish,
        shares: BigNumberish
    ];
    type OutputTuple = [
        id: string,
        caller: string,
        onBehalf: string,
        receiver: string,
        assets: bigint,
        shares: bigint
    ];
    interface OutputObject {
        id: string;
        caller: string;
        onBehalf: string;
        receiver: string;
        assets: bigint;
        shares: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace CreateMarketEvent {
    type InputTuple = [id: BytesLike, marketParams: MarketParamsStruct];
    type OutputTuple = [
        id: string,
        marketParams: MarketParamsStructOutput
    ];
    interface OutputObject {
        id: string;
        marketParams: MarketParamsStructOutput;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace EnableIrmEvent {
    type InputTuple = [irm: AddressLike];
    type OutputTuple = [irm: string];
    interface OutputObject {
        irm: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace EnableLltvEvent {
    type InputTuple = [lltv: BigNumberish];
    type OutputTuple = [lltv: bigint];
    interface OutputObject {
        lltv: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace FlashLoanEvent {
    type InputTuple = [
        caller: AddressLike,
        token: AddressLike,
        assets: BigNumberish
    ];
    type OutputTuple = [caller: string, token: string, assets: bigint];
    interface OutputObject {
        caller: string;
        token: string;
        assets: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace IncrementNonceEvent {
    type InputTuple = [
        caller: AddressLike,
        authorizer: AddressLike,
        usedNonce: BigNumberish
    ];
    type OutputTuple = [
        caller: string,
        authorizer: string,
        usedNonce: bigint
    ];
    interface OutputObject {
        caller: string;
        authorizer: string;
        usedNonce: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace LiquidateEvent {
    type InputTuple = [
        id: BytesLike,
        caller: AddressLike,
        borrower: AddressLike,
        repaidAssets: BigNumberish,
        repaidShares: BigNumberish,
        seizedAssets: BigNumberish,
        badDebtAssets: BigNumberish,
        badDebtShares: BigNumberish
    ];
    type OutputTuple = [
        id: string,
        caller: string,
        borrower: string,
        repaidAssets: bigint,
        repaidShares: bigint,
        seizedAssets: bigint,
        badDebtAssets: bigint,
        badDebtShares: bigint
    ];
    interface OutputObject {
        id: string;
        caller: string;
        borrower: string;
        repaidAssets: bigint;
        repaidShares: bigint;
        seizedAssets: bigint;
        badDebtAssets: bigint;
        badDebtShares: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace RepayEvent {
    type InputTuple = [
        id: BytesLike,
        caller: AddressLike,
        onBehalf: AddressLike,
        assets: BigNumberish,
        shares: BigNumberish
    ];
    type OutputTuple = [
        id: string,
        caller: string,
        onBehalf: string,
        assets: bigint,
        shares: bigint
    ];
    interface OutputObject {
        id: string;
        caller: string;
        onBehalf: string;
        assets: bigint;
        shares: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace SetAuthorizationEvent {
    type InputTuple = [
        caller: AddressLike,
        authorizer: AddressLike,
        authorized: AddressLike,
        newIsAuthorized: boolean
    ];
    type OutputTuple = [
        caller: string,
        authorizer: string,
        authorized: string,
        newIsAuthorized: boolean
    ];
    interface OutputObject {
        caller: string;
        authorizer: string;
        authorized: string;
        newIsAuthorized: boolean;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace SetFeeEvent {
    type InputTuple = [id: BytesLike, newFee: BigNumberish];
    type OutputTuple = [id: string, newFee: bigint];
    interface OutputObject {
        id: string;
        newFee: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace SetFeeRecipientEvent {
    type InputTuple = [newFeeRecipient: AddressLike];
    type OutputTuple = [newFeeRecipient: string];
    interface OutputObject {
        newFeeRecipient: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace SetOwnerEvent {
    type InputTuple = [newOwner: AddressLike];
    type OutputTuple = [newOwner: string];
    interface OutputObject {
        newOwner: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace SupplyEvent {
    type InputTuple = [
        id: BytesLike,
        caller: AddressLike,
        onBehalf: AddressLike,
        assets: BigNumberish,
        shares: BigNumberish
    ];
    type OutputTuple = [
        id: string,
        caller: string,
        onBehalf: string,
        assets: bigint,
        shares: bigint
    ];
    interface OutputObject {
        id: string;
        caller: string;
        onBehalf: string;
        assets: bigint;
        shares: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace SupplyCollateralEvent {
    type InputTuple = [
        id: BytesLike,
        caller: AddressLike,
        onBehalf: AddressLike,
        assets: BigNumberish
    ];
    type OutputTuple = [
        id: string,
        caller: string,
        onBehalf: string,
        assets: bigint
    ];
    interface OutputObject {
        id: string;
        caller: string;
        onBehalf: string;
        assets: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace WithdrawEvent {
    type InputTuple = [
        id: BytesLike,
        caller: AddressLike,
        onBehalf: AddressLike,
        receiver: AddressLike,
        assets: BigNumberish,
        shares: BigNumberish
    ];
    type OutputTuple = [
        id: string,
        caller: string,
        onBehalf: string,
        receiver: string,
        assets: bigint,
        shares: bigint
    ];
    interface OutputObject {
        id: string;
        caller: string;
        onBehalf: string;
        receiver: string;
        assets: bigint;
        shares: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace WithdrawCollateralEvent {
    type InputTuple = [
        id: BytesLike,
        caller: AddressLike,
        onBehalf: AddressLike,
        receiver: AddressLike,
        assets: BigNumberish
    ];
    type OutputTuple = [
        id: string,
        caller: string,
        onBehalf: string,
        receiver: string,
        assets: bigint
    ];
    interface OutputObject {
        id: string;
        caller: string;
        onBehalf: string;
        receiver: string;
        assets: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export interface MorphoBlue extends BaseContract {
    connect(runner?: ContractRunner | null): MorphoBlue;
    waitForDeployment(): Promise<this>;
    interface: MorphoBlueInterface;
    queryFilter<TCEvent extends TypedContractEvent>(event: TCEvent, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TypedEventLog<TCEvent>>>;
    queryFilter<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TypedEventLog<TCEvent>>>;
    on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
    on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>;
    once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
    once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>;
    listeners<TCEvent extends TypedContractEvent>(event: TCEvent): Promise<Array<TypedListener<TCEvent>>>;
    listeners(eventName?: string): Promise<Array<Listener>>;
    removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>;
    DOMAIN_SEPARATOR: TypedContractMethod<[], [string], "view">;
    accrueInterest: TypedContractMethod<[
        marketParams: MarketParamsStruct
    ], [
        void
    ], "nonpayable">;
    borrow: TypedContractMethod<[
        marketParams: MarketParamsStruct,
        assets: BigNumberish,
        shares: BigNumberish,
        onBehalf: AddressLike,
        receiver: AddressLike
    ], [
        [bigint, bigint]
    ], "nonpayable">;
    createMarket: TypedContractMethod<[
        marketParams: MarketParamsStruct
    ], [
        void
    ], "nonpayable">;
    enableIrm: TypedContractMethod<[irm: AddressLike], [void], "nonpayable">;
    enableLltv: TypedContractMethod<[lltv: BigNumberish], [void], "nonpayable">;
    extSloads: TypedContractMethod<[slots: BytesLike[]], [string[]], "view">;
    feeRecipient: TypedContractMethod<[], [string], "view">;
    flashLoan: TypedContractMethod<[
        token: AddressLike,
        assets: BigNumberish,
        data: BytesLike
    ], [
        void
    ], "nonpayable">;
    idToMarketParams: TypedContractMethod<[
        arg0: BytesLike
    ], [
        [
            string,
            string,
            string,
            string,
            bigint
        ] & {
            loanToken: string;
            collateralToken: string;
            oracle: string;
            irm: string;
            lltv: bigint;
        }
    ], "view">;
    isAuthorized: TypedContractMethod<[
        arg0: AddressLike,
        arg1: AddressLike
    ], [
        boolean
    ], "view">;
    isIrmEnabled: TypedContractMethod<[arg0: AddressLike], [boolean], "view">;
    isLltvEnabled: TypedContractMethod<[arg0: BigNumberish], [boolean], "view">;
    liquidate: TypedContractMethod<[
        marketParams: MarketParamsStruct,
        borrower: AddressLike,
        seizedAssets: BigNumberish,
        repaidShares: BigNumberish,
        data: BytesLike
    ], [
        [bigint, bigint]
    ], "nonpayable">;
    market: TypedContractMethod<[
        arg0: BytesLike
    ], [
        [
            bigint,
            bigint,
            bigint,
            bigint,
            bigint,
            bigint
        ] & {
            totalSupplyAssets: bigint;
            totalSupplyShares: bigint;
            totalBorrowAssets: bigint;
            totalBorrowShares: bigint;
            lastUpdate: bigint;
            fee: bigint;
        }
    ], "view">;
    nonce: TypedContractMethod<[arg0: AddressLike], [bigint], "view">;
    owner: TypedContractMethod<[], [string], "view">;
    position: TypedContractMethod<[
        arg0: BytesLike,
        arg1: AddressLike
    ], [
        [
            bigint,
            bigint,
            bigint
        ] & {
            supplyShares: bigint;
            borrowShares: bigint;
            collateral: bigint;
        }
    ], "view">;
    repay: TypedContractMethod<[
        marketParams: MarketParamsStruct,
        assets: BigNumberish,
        shares: BigNumberish,
        onBehalf: AddressLike,
        data: BytesLike
    ], [
        [bigint, bigint]
    ], "nonpayable">;
    setAuthorization: TypedContractMethod<[
        authorized: AddressLike,
        newIsAuthorized: boolean
    ], [
        void
    ], "nonpayable">;
    setAuthorizationWithSig: TypedContractMethod<[
        authorization: AuthorizationStruct,
        signature: SignatureStruct
    ], [
        void
    ], "nonpayable">;
    setFee: TypedContractMethod<[
        marketParams: MarketParamsStruct,
        newFee: BigNumberish
    ], [
        void
    ], "nonpayable">;
    setFeeRecipient: TypedContractMethod<[
        newFeeRecipient: AddressLike
    ], [
        void
    ], "nonpayable">;
    setOwner: TypedContractMethod<[newOwner: AddressLike], [void], "nonpayable">;
    supply: TypedContractMethod<[
        marketParams: MarketParamsStruct,
        assets: BigNumberish,
        shares: BigNumberish,
        onBehalf: AddressLike,
        data: BytesLike
    ], [
        [bigint, bigint]
    ], "nonpayable">;
    supplyCollateral: TypedContractMethod<[
        marketParams: MarketParamsStruct,
        assets: BigNumberish,
        onBehalf: AddressLike,
        data: BytesLike
    ], [
        void
    ], "nonpayable">;
    withdraw: TypedContractMethod<[
        marketParams: MarketParamsStruct,
        assets: BigNumberish,
        shares: BigNumberish,
        onBehalf: AddressLike,
        receiver: AddressLike
    ], [
        [bigint, bigint]
    ], "nonpayable">;
    withdrawCollateral: TypedContractMethod<[
        marketParams: MarketParamsStruct,
        assets: BigNumberish,
        onBehalf: AddressLike,
        receiver: AddressLike
    ], [
        void
    ], "nonpayable">;
    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;
    getFunction(nameOrSignature: "DOMAIN_SEPARATOR"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "accrueInterest"): TypedContractMethod<[
        marketParams: MarketParamsStruct
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "borrow"): TypedContractMethod<[
        marketParams: MarketParamsStruct,
        assets: BigNumberish,
        shares: BigNumberish,
        onBehalf: AddressLike,
        receiver: AddressLike
    ], [
        [bigint, bigint]
    ], "nonpayable">;
    getFunction(nameOrSignature: "createMarket"): TypedContractMethod<[
        marketParams: MarketParamsStruct
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "enableIrm"): TypedContractMethod<[irm: AddressLike], [void], "nonpayable">;
    getFunction(nameOrSignature: "enableLltv"): TypedContractMethod<[lltv: BigNumberish], [void], "nonpayable">;
    getFunction(nameOrSignature: "extSloads"): TypedContractMethod<[slots: BytesLike[]], [string[]], "view">;
    getFunction(nameOrSignature: "feeRecipient"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "flashLoan"): TypedContractMethod<[
        token: AddressLike,
        assets: BigNumberish,
        data: BytesLike
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "idToMarketParams"): TypedContractMethod<[
        arg0: BytesLike
    ], [
        [
            string,
            string,
            string,
            string,
            bigint
        ] & {
            loanToken: string;
            collateralToken: string;
            oracle: string;
            irm: string;
            lltv: bigint;
        }
    ], "view">;
    getFunction(nameOrSignature: "isAuthorized"): TypedContractMethod<[
        arg0: AddressLike,
        arg1: AddressLike
    ], [
        boolean
    ], "view">;
    getFunction(nameOrSignature: "isIrmEnabled"): TypedContractMethod<[arg0: AddressLike], [boolean], "view">;
    getFunction(nameOrSignature: "isLltvEnabled"): TypedContractMethod<[arg0: BigNumberish], [boolean], "view">;
    getFunction(nameOrSignature: "liquidate"): TypedContractMethod<[
        marketParams: MarketParamsStruct,
        borrower: AddressLike,
        seizedAssets: BigNumberish,
        repaidShares: BigNumberish,
        data: BytesLike
    ], [
        [bigint, bigint]
    ], "nonpayable">;
    getFunction(nameOrSignature: "market"): TypedContractMethod<[
        arg0: BytesLike
    ], [
        [
            bigint,
            bigint,
            bigint,
            bigint,
            bigint,
            bigint
        ] & {
            totalSupplyAssets: bigint;
            totalSupplyShares: bigint;
            totalBorrowAssets: bigint;
            totalBorrowShares: bigint;
            lastUpdate: bigint;
            fee: bigint;
        }
    ], "view">;
    getFunction(nameOrSignature: "nonce"): TypedContractMethod<[arg0: AddressLike], [bigint], "view">;
    getFunction(nameOrSignature: "owner"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "position"): TypedContractMethod<[
        arg0: BytesLike,
        arg1: AddressLike
    ], [
        [
            bigint,
            bigint,
            bigint
        ] & {
            supplyShares: bigint;
            borrowShares: bigint;
            collateral: bigint;
        }
    ], "view">;
    getFunction(nameOrSignature: "repay"): TypedContractMethod<[
        marketParams: MarketParamsStruct,
        assets: BigNumberish,
        shares: BigNumberish,
        onBehalf: AddressLike,
        data: BytesLike
    ], [
        [bigint, bigint]
    ], "nonpayable">;
    getFunction(nameOrSignature: "setAuthorization"): TypedContractMethod<[
        authorized: AddressLike,
        newIsAuthorized: boolean
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "setAuthorizationWithSig"): TypedContractMethod<[
        authorization: AuthorizationStruct,
        signature: SignatureStruct
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "setFee"): TypedContractMethod<[
        marketParams: MarketParamsStruct,
        newFee: BigNumberish
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "setFeeRecipient"): TypedContractMethod<[newFeeRecipient: AddressLike], [void], "nonpayable">;
    getFunction(nameOrSignature: "setOwner"): TypedContractMethod<[newOwner: AddressLike], [void], "nonpayable">;
    getFunction(nameOrSignature: "supply"): TypedContractMethod<[
        marketParams: MarketParamsStruct,
        assets: BigNumberish,
        shares: BigNumberish,
        onBehalf: AddressLike,
        data: BytesLike
    ], [
        [bigint, bigint]
    ], "nonpayable">;
    getFunction(nameOrSignature: "supplyCollateral"): TypedContractMethod<[
        marketParams: MarketParamsStruct,
        assets: BigNumberish,
        onBehalf: AddressLike,
        data: BytesLike
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "withdraw"): TypedContractMethod<[
        marketParams: MarketParamsStruct,
        assets: BigNumberish,
        shares: BigNumberish,
        onBehalf: AddressLike,
        receiver: AddressLike
    ], [
        [bigint, bigint]
    ], "nonpayable">;
    getFunction(nameOrSignature: "withdrawCollateral"): TypedContractMethod<[
        marketParams: MarketParamsStruct,
        assets: BigNumberish,
        onBehalf: AddressLike,
        receiver: AddressLike
    ], [
        void
    ], "nonpayable">;
    getEvent(key: "AccrueInterest"): TypedContractEvent<AccrueInterestEvent.InputTuple, AccrueInterestEvent.OutputTuple, AccrueInterestEvent.OutputObject>;
    getEvent(key: "Borrow"): TypedContractEvent<BorrowEvent.InputTuple, BorrowEvent.OutputTuple, BorrowEvent.OutputObject>;
    getEvent(key: "CreateMarket"): TypedContractEvent<CreateMarketEvent.InputTuple, CreateMarketEvent.OutputTuple, CreateMarketEvent.OutputObject>;
    getEvent(key: "EnableIrm"): TypedContractEvent<EnableIrmEvent.InputTuple, EnableIrmEvent.OutputTuple, EnableIrmEvent.OutputObject>;
    getEvent(key: "EnableLltv"): TypedContractEvent<EnableLltvEvent.InputTuple, EnableLltvEvent.OutputTuple, EnableLltvEvent.OutputObject>;
    getEvent(key: "FlashLoan"): TypedContractEvent<FlashLoanEvent.InputTuple, FlashLoanEvent.OutputTuple, FlashLoanEvent.OutputObject>;
    getEvent(key: "IncrementNonce"): TypedContractEvent<IncrementNonceEvent.InputTuple, IncrementNonceEvent.OutputTuple, IncrementNonceEvent.OutputObject>;
    getEvent(key: "Liquidate"): TypedContractEvent<LiquidateEvent.InputTuple, LiquidateEvent.OutputTuple, LiquidateEvent.OutputObject>;
    getEvent(key: "Repay"): TypedContractEvent<RepayEvent.InputTuple, RepayEvent.OutputTuple, RepayEvent.OutputObject>;
    getEvent(key: "SetAuthorization"): TypedContractEvent<SetAuthorizationEvent.InputTuple, SetAuthorizationEvent.OutputTuple, SetAuthorizationEvent.OutputObject>;
    getEvent(key: "SetFee"): TypedContractEvent<SetFeeEvent.InputTuple, SetFeeEvent.OutputTuple, SetFeeEvent.OutputObject>;
    getEvent(key: "SetFeeRecipient"): TypedContractEvent<SetFeeRecipientEvent.InputTuple, SetFeeRecipientEvent.OutputTuple, SetFeeRecipientEvent.OutputObject>;
    getEvent(key: "SetOwner"): TypedContractEvent<SetOwnerEvent.InputTuple, SetOwnerEvent.OutputTuple, SetOwnerEvent.OutputObject>;
    getEvent(key: "Supply"): TypedContractEvent<SupplyEvent.InputTuple, SupplyEvent.OutputTuple, SupplyEvent.OutputObject>;
    getEvent(key: "SupplyCollateral"): TypedContractEvent<SupplyCollateralEvent.InputTuple, SupplyCollateralEvent.OutputTuple, SupplyCollateralEvent.OutputObject>;
    getEvent(key: "Withdraw"): TypedContractEvent<WithdrawEvent.InputTuple, WithdrawEvent.OutputTuple, WithdrawEvent.OutputObject>;
    getEvent(key: "WithdrawCollateral"): TypedContractEvent<WithdrawCollateralEvent.InputTuple, WithdrawCollateralEvent.OutputTuple, WithdrawCollateralEvent.OutputObject>;
    filters: {
        "AccrueInterest(bytes32,uint256,uint256,uint256)": TypedContractEvent<AccrueInterestEvent.InputTuple, AccrueInterestEvent.OutputTuple, AccrueInterestEvent.OutputObject>;
        AccrueInterest: TypedContractEvent<AccrueInterestEvent.InputTuple, AccrueInterestEvent.OutputTuple, AccrueInterestEvent.OutputObject>;
        "Borrow(bytes32,address,address,address,uint256,uint256)": TypedContractEvent<BorrowEvent.InputTuple, BorrowEvent.OutputTuple, BorrowEvent.OutputObject>;
        Borrow: TypedContractEvent<BorrowEvent.InputTuple, BorrowEvent.OutputTuple, BorrowEvent.OutputObject>;
        "CreateMarket(bytes32,tuple)": TypedContractEvent<CreateMarketEvent.InputTuple, CreateMarketEvent.OutputTuple, CreateMarketEvent.OutputObject>;
        CreateMarket: TypedContractEvent<CreateMarketEvent.InputTuple, CreateMarketEvent.OutputTuple, CreateMarketEvent.OutputObject>;
        "EnableIrm(address)": TypedContractEvent<EnableIrmEvent.InputTuple, EnableIrmEvent.OutputTuple, EnableIrmEvent.OutputObject>;
        EnableIrm: TypedContractEvent<EnableIrmEvent.InputTuple, EnableIrmEvent.OutputTuple, EnableIrmEvent.OutputObject>;
        "EnableLltv(uint256)": TypedContractEvent<EnableLltvEvent.InputTuple, EnableLltvEvent.OutputTuple, EnableLltvEvent.OutputObject>;
        EnableLltv: TypedContractEvent<EnableLltvEvent.InputTuple, EnableLltvEvent.OutputTuple, EnableLltvEvent.OutputObject>;
        "FlashLoan(address,address,uint256)": TypedContractEvent<FlashLoanEvent.InputTuple, FlashLoanEvent.OutputTuple, FlashLoanEvent.OutputObject>;
        FlashLoan: TypedContractEvent<FlashLoanEvent.InputTuple, FlashLoanEvent.OutputTuple, FlashLoanEvent.OutputObject>;
        "IncrementNonce(address,address,uint256)": TypedContractEvent<IncrementNonceEvent.InputTuple, IncrementNonceEvent.OutputTuple, IncrementNonceEvent.OutputObject>;
        IncrementNonce: TypedContractEvent<IncrementNonceEvent.InputTuple, IncrementNonceEvent.OutputTuple, IncrementNonceEvent.OutputObject>;
        "Liquidate(bytes32,address,address,uint256,uint256,uint256,uint256,uint256)": TypedContractEvent<LiquidateEvent.InputTuple, LiquidateEvent.OutputTuple, LiquidateEvent.OutputObject>;
        Liquidate: TypedContractEvent<LiquidateEvent.InputTuple, LiquidateEvent.OutputTuple, LiquidateEvent.OutputObject>;
        "Repay(bytes32,address,address,uint256,uint256)": TypedContractEvent<RepayEvent.InputTuple, RepayEvent.OutputTuple, RepayEvent.OutputObject>;
        Repay: TypedContractEvent<RepayEvent.InputTuple, RepayEvent.OutputTuple, RepayEvent.OutputObject>;
        "SetAuthorization(address,address,address,bool)": TypedContractEvent<SetAuthorizationEvent.InputTuple, SetAuthorizationEvent.OutputTuple, SetAuthorizationEvent.OutputObject>;
        SetAuthorization: TypedContractEvent<SetAuthorizationEvent.InputTuple, SetAuthorizationEvent.OutputTuple, SetAuthorizationEvent.OutputObject>;
        "SetFee(bytes32,uint256)": TypedContractEvent<SetFeeEvent.InputTuple, SetFeeEvent.OutputTuple, SetFeeEvent.OutputObject>;
        SetFee: TypedContractEvent<SetFeeEvent.InputTuple, SetFeeEvent.OutputTuple, SetFeeEvent.OutputObject>;
        "SetFeeRecipient(address)": TypedContractEvent<SetFeeRecipientEvent.InputTuple, SetFeeRecipientEvent.OutputTuple, SetFeeRecipientEvent.OutputObject>;
        SetFeeRecipient: TypedContractEvent<SetFeeRecipientEvent.InputTuple, SetFeeRecipientEvent.OutputTuple, SetFeeRecipientEvent.OutputObject>;
        "SetOwner(address)": TypedContractEvent<SetOwnerEvent.InputTuple, SetOwnerEvent.OutputTuple, SetOwnerEvent.OutputObject>;
        SetOwner: TypedContractEvent<SetOwnerEvent.InputTuple, SetOwnerEvent.OutputTuple, SetOwnerEvent.OutputObject>;
        "Supply(bytes32,address,address,uint256,uint256)": TypedContractEvent<SupplyEvent.InputTuple, SupplyEvent.OutputTuple, SupplyEvent.OutputObject>;
        Supply: TypedContractEvent<SupplyEvent.InputTuple, SupplyEvent.OutputTuple, SupplyEvent.OutputObject>;
        "SupplyCollateral(bytes32,address,address,uint256)": TypedContractEvent<SupplyCollateralEvent.InputTuple, SupplyCollateralEvent.OutputTuple, SupplyCollateralEvent.OutputObject>;
        SupplyCollateral: TypedContractEvent<SupplyCollateralEvent.InputTuple, SupplyCollateralEvent.OutputTuple, SupplyCollateralEvent.OutputObject>;
        "Withdraw(bytes32,address,address,address,uint256,uint256)": TypedContractEvent<WithdrawEvent.InputTuple, WithdrawEvent.OutputTuple, WithdrawEvent.OutputObject>;
        Withdraw: TypedContractEvent<WithdrawEvent.InputTuple, WithdrawEvent.OutputTuple, WithdrawEvent.OutputObject>;
        "WithdrawCollateral(bytes32,address,address,address,uint256)": TypedContractEvent<WithdrawCollateralEvent.InputTuple, WithdrawCollateralEvent.OutputTuple, WithdrawCollateralEvent.OutputObject>;
        WithdrawCollateral: TypedContractEvent<WithdrawCollateralEvent.InputTuple, WithdrawCollateralEvent.OutputTuple, WithdrawCollateralEvent.OutputObject>;
    };
}
