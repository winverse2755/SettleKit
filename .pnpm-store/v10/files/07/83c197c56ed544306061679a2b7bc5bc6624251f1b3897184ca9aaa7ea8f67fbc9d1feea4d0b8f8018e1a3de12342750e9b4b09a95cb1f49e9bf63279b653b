"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccrualVault = exports.Vault = void 0;
const index_js_1 = require("../market/index.js");
const index_js_2 = require("../math/index.js");
const index_js_3 = require("../token/index.js");
const VaultMarketAllocation_js_1 = require("./VaultMarketAllocation.js");
class Vault extends index_js_3.VaultToken {
    /**
     * The MetaMorpho vault's owner address.
     */
    owner;
    /**
     * The MetaMorpho vault's curator address.
     */
    curator;
    /**
     * The MetaMorpho vault's guardian address.
     */
    guardian;
    /**
     * The MetaMorpho vault's skim recipient address (mostly used to skim reward tokens claimed to the vault).
     */
    skimRecipient;
    /**
     * The MetaMorpho vault's fee recipient address.
     */
    feeRecipient;
    /**
     * The MetaMorpho vault's timelock (in seconds).
     */
    timelock;
    /**
     * The MetaMorpho vault's fee.
     */
    fee;
    /**
     * The MetaMorpho vault's pending owner address and activation timestamp.
     */
    pendingOwner;
    /**
     * The MetaMorpho vault's pending guardian address and activation timestamp.
     */
    pendingGuardian;
    /**
     * The MetaMorpho vault's pending timelock (in seconds) and activation timestamp.
     */
    pendingTimelock;
    /**
     * The MetaMorpho vault's ordered supply queue.
     */
    supplyQueue;
    /**
     * The MetaMorpho vault's ordered withdraw queue.
     */
    withdrawQueue;
    /**
     * The MetaMorpho vault's last total assets used to calculate performance fees.
     */
    lastTotalAssets;
    /**
     * The MetaMorpho vault's lost assets due to realized bad debt.
     * Only defined for MetaMorpho V1.1 vaults.
     */
    lostAssets;
    /**
     * The MetaMorpho vault's public allocator configuration.
     */
    publicAllocatorConfig;
    constructor({ curator, owner, guardian, publicAllocatorConfig, fee, feeRecipient, skimRecipient, pendingTimelock, pendingGuardian, pendingOwner, timelock, supplyQueue, withdrawQueue, totalSupply, totalAssets, lastTotalAssets, lostAssets, ...config }) {
        super(config, { totalAssets, totalSupply });
        this.curator = curator;
        this.owner = owner;
        this.guardian = guardian;
        this.fee = fee;
        this.feeRecipient = feeRecipient;
        this.skimRecipient = skimRecipient;
        this.pendingTimelock = {
            value: pendingTimelock.value,
            validAt: pendingTimelock.validAt,
        };
        this.pendingGuardian = pendingGuardian;
        this.pendingOwner = pendingOwner;
        this.timelock = timelock;
        this.supplyQueue = supplyQueue;
        this.withdrawQueue = withdrawQueue;
        this.lastTotalAssets = lastTotalAssets;
        this.lostAssets = lostAssets;
        this.publicAllocatorConfig = publicAllocatorConfig;
    }
    /**
     * The amount of interest in assets accrued since the last interaction with the vault.
     */
    get totalInterest() {
        return index_js_2.MathLib.zeroFloorSub(this.totalAssets, this.lastTotalAssets);
    }
    toAssets(shares, rounding) {
        return this._unwrap(shares, rounding);
    }
    toShares(assets, rounding) {
        return this._wrap(assets, rounding);
    }
}
exports.Vault = Vault;
class AccrualVault extends Vault {
    /**
     * The allocation of the vault on each market enabled.
     */
    allocations;
    /**
     * The proportion of assets of the vault supplied to markets collateralized by each collateral asset.
     */
    collateralAllocations;
    constructor(vault, 
    /**
     * The allocation of the vault on each market of the withdraw queue,
     * in the same order as the withdraw queue.
     */
    allocations) {
        super({
            ...vault,
            withdrawQueue: allocations.map(({ position }) => position.market.id),
            totalAssets: allocations.reduce((total, { position }) => total + position.supplyAssets, 0n),
        });
        this.allocations = new Map(allocations.map((allocation) => [
            allocation.position.market.id,
            new VaultMarketAllocation_js_1.VaultMarketAllocation(allocation),
        ]));
        this.collateralAllocations = new Map();
        for (const { marketId, position } of this.allocations.values()) {
            const address = position.market.params.collateralToken;
            let exposure = this.collateralAllocations.get(address);
            if (!exposure)
                this.collateralAllocations.set(address, (exposure = {
                    address,
                    lltvs: new Set(),
                    oracles: new Set(),
                    markets: new Set(),
                    proportion: 0n,
                }));
            exposure.lltvs.add(position.market.params.lltv);
            exposure.oracles.add(position.market.params.oracle);
            exposure.markets.add(marketId);
            exposure.proportion += this.getAllocationProportion(marketId);
        }
    }
    /**
     * The vault's liquidity directly available from allocated markets.
     */
    get liquidity() {
        return this.allocations
            .values()
            .reduce((total, { position }) => total + position.withdrawCapacityLimit.value, 0n);
    }
    /**
     * The MetaMorpho vault's APY on its assets averaged over its market deposits,
     * before deducting the performance fee, at the time of each market's last update (scaled by WAD).
     * If interested in the APY at a specific timestamp, use `getApy(timestamp)` instead.
     */
    get apy() {
        if (this.totalAssets === 0n)
            return 0n;
        return (this.allocations
            .values()
            .reduce((total, { position }) => total + position.market.supplyApy * position.supplyAssets, 0n) / this.totalAssets);
    }
    /**
     * The MetaMorpho vault's APY on its assets averaged over its market deposits,
     * after deducting the performance fee, at the time of each market's last update (scaled by WAD).
     * If interested in the APY at a specific timestamp, use `getApy(timestamp)` instead.
     */
    get netApy() {
        return index_js_2.MathLib.wMulDown(this.apy, index_js_2.MathLib.WAD - this.fee);
    }
    /**
     * The MetaMorpho vault's APY on its assets averaged over its market deposits,
     * before deducting the performance fee, at the given timestamp,
     * if the state of all the markets remains unchanged (not accrued) (scaled by WAD).
     */
    getApy(timestamp) {
        if (this.totalAssets === 0n)
            return 0n;
        return (this.allocations
            .values()
            .reduce((total, { position }) => total +
            position.market.getSupplyApy(timestamp) * position.supplyAssets, 0n) / this.totalAssets);
    }
    /**
     * The MetaMorpho vault's APY on its assets averaged over its market deposits,
     * after deducting the performance fee, at the given timestamp,
     * if the state of all the markets remains unchanged (not accrued) (scaled by WAD).
     */
    getNetApy(timestamp) {
        return index_js_2.MathLib.wMulDown(this.getApy(timestamp), index_js_2.MathLib.WAD - this.fee);
    }
    getAllocationProportion(marketId) {
        if (this.totalAssets === 0n)
            return 0n;
        const allocation = this.allocations.get(marketId);
        if (!allocation)
            return 0n;
        return index_js_2.MathLib.wDivDown(allocation.position.supplyAssets, this.totalAssets);
    }
    getDepositCapacityLimit(assets) {
        const suppliable = this.allocations
            .values()
            .reduce((total, { config: { cap }, position: { marketId, supplyAssets } }) => index_js_2.MathLib.min(total +
            (this.supplyQueue.includes(marketId)
                ? index_js_2.MathLib.zeroFloorSub(cap, supplyAssets)
                : 0n), index_js_2.MathLib.MAX_UINT_256), 0n);
        if (assets > suppliable)
            return {
                value: suppliable,
                limiter: index_js_1.CapacityLimitReason.cap,
            };
        return {
            value: assets,
            limiter: index_js_1.CapacityLimitReason.balance,
        };
    }
    getWithdrawCapacityLimit(shares) {
        const assets = this.toAssets(shares);
        const { liquidity } = this;
        if (assets > liquidity)
            return {
                value: liquidity,
                limiter: index_js_1.CapacityLimitReason.liquidity,
            };
        return {
            value: assets,
            limiter: index_js_1.CapacityLimitReason.balance,
        };
    }
    /**
     * Returns a new vault derived from this vault, whose interest has been accrued up to the given timestamp.
     * @param timestamp The timestamp at which to accrue interest. Must be greater than or equal to each of the vault's market's `lastUpdate`.
     */
    accrueInterest(timestamp) {
        const vault = new AccrualVault(this, 
        // Keep withdraw queue order.
        this.withdrawQueue.map((marketId) => {
            const { config, position } = this.allocations.get(marketId);
            return {
                config,
                position: position.accrueInterest(timestamp),
            };
        }));
        if (vault.lostAssets != null) {
            vault.lostAssets += index_js_2.MathLib.max(vault.lastTotalAssets - vault.lostAssets - vault.totalAssets, 0n);
            vault.totalAssets += vault.lostAssets;
        }
        const feeAssets = index_js_2.MathLib.wMulDown(vault.totalInterest, vault.fee);
        vault.totalAssets -= feeAssets;
        const feeShares = vault.toShares(feeAssets, "Down");
        vault.totalAssets += feeAssets;
        vault.totalSupply += feeShares;
        vault.lastTotalAssets = vault.totalAssets;
        return vault;
    }
}
exports.AccrualVault = AccrualVault;
