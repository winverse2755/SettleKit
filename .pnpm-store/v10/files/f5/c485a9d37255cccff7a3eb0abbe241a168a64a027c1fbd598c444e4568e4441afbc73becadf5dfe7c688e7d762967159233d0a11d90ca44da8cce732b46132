"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Market = exports.CapacityLimitReason = void 0;
const morpho_ts_1 = require("@morpho-org/morpho-ts");
const errors_js_1 = require("../errors.js");
const index_js_1 = require("../math/index.js");
const MarketParams_js_1 = require("./MarketParams.js");
const MarketUtils_js_1 = require("./MarketUtils.js");
var CapacityLimitReason;
(function (CapacityLimitReason) {
    CapacityLimitReason["liquidity"] = "Liquidity";
    CapacityLimitReason["balance"] = "Balance";
    CapacityLimitReason["position"] = "Position";
    CapacityLimitReason["collateral"] = "Collateral";
    CapacityLimitReason["cap"] = "Cap";
})(CapacityLimitReason || (exports.CapacityLimitReason = CapacityLimitReason = {}));
/**
 * Represents a lending market on Morpho Blue.
 */
class Market {
    /**
     * The market's params.
     */
    params;
    /**
     * The amount of loan assets supplied in total on the market.
     */
    totalSupplyAssets;
    /**
     * The amount of loan assets supplied in total on the market.
     */
    totalBorrowAssets;
    /**
     * The amount of loan assets supplied in total on the market.
     */
    totalSupplyShares;
    /**
     * The amount of loan assets supplied in total on the market.
     */
    totalBorrowShares;
    /**
     * The block timestamp (in __seconds__) when the interest was last accrued.
     */
    lastUpdate;
    /**
     * The fee percentage of the market, scaled by WAD.
     */
    fee;
    /**
     * The price as returned by the market's oracle.
     * `undefined` if the oracle is undefined or reverts.
     */
    price;
    /**
     * If the market uses the Adaptive Curve IRM, the rate at target utilization.
     * Undefined otherwise.
     */
    rateAtTarget;
    constructor({ params, totalSupplyAssets, totalBorrowAssets, totalSupplyShares, totalBorrowShares, lastUpdate, fee, price, rateAtTarget, }) {
        this.params = new MarketParams_js_1.MarketParams(params);
        this.totalSupplyAssets = totalSupplyAssets;
        this.totalBorrowAssets = totalBorrowAssets;
        this.totalSupplyShares = totalSupplyShares;
        this.totalBorrowShares = totalBorrowShares;
        this.lastUpdate = lastUpdate;
        this.fee = fee;
        this.price = price;
        if (rateAtTarget != null)
            this.rateAtTarget = rateAtTarget;
    }
    /**
     * The market's hex-encoded id, defined as the hash of the market params.
     */
    get id() {
        return this.params.id;
    }
    /**
     * Whether the market satisfies the canonical definition of an idle market (i.e. collateral token is the zero address).
     */
    get isIdle() {
        return this.params.collateralToken === morpho_ts_1.ZERO_ADDRESS;
    }
    /**
     * @warning Cannot be used to calculate the liquidity available inside a callback,
     * because the balance of Blue may be lower than the market's liquidity due to assets being transferred out prior to the callback.
     */
    get liquidity() {
        return this.totalSupplyAssets - this.totalBorrowAssets;
    }
    /**
     * The market's utilization rate (scaled by WAD).
     */
    get utilization() {
        return MarketUtils_js_1.MarketUtils.getUtilization(this);
    }
    /**
     * The market's Annual Percentage Yield (APY) at the IRM's target utilization rate, if applicable (scaled by WAD).
     */
    get apyAtTarget() {
        if (this.rateAtTarget == null)
            return;
        return MarketUtils_js_1.MarketUtils.compoundRate(this.rateAtTarget);
    }
    /**
     * Returns the rate at which interest accrued for suppliers of this market,
     * since the last time the market was updated (scaled by WAD).
     * @deprecated There's no such thing as a supply rate in Morpho. Only the supply APY is meaningful.
     */
    get supplyRate() {
        return MarketUtils_js_1.MarketUtils.getSupplyRate(this.borrowRate, this);
    }
    /**
     * Returns the average rate at which interest _would_ accrue from `lastUpdate`
     * till now, if `accrueInterest` was called immediately onchain (scaled by WAD).
     * If `accrueInterest` was just called, the average rate equals the instantaneous rate,
     * so it is equivalent to `getBorrowRate(lastUpdate)`.
     *
     * In most cases, `accrueInterest` will not be called immediately onchain, so the
     * average rate doesn't correspond to anything "real".
     *
     * If interested in the instantaneous rate experienced by existing market actors at a specific timestamp,
     * use `getBorrowRate(timestamp)`, `getBorrowApy(timestamp)`, or `getSupplyApy(timestamp)` instead.
     */
    get borrowRate() {
        return this.getAccrualBorrowRate().avgBorrowRate;
    }
    /**
     * The market's current, instantaneous supply-side Annual Percentage Yield (APY) (scaled by WAD).
     * If interested in the APY at a specific timestamp, use `getSupplyApy(timestamp)` instead.
     */
    get supplyApy() {
        return this.getSupplyApy();
    }
    /**
     * The market's current, instantaneous borrow-side Annual Percentage Yield (APY) (scaled by WAD).
     * If interested in the APY at a specific timestamp, use `getBorrowApy(timestamp)` instead.
     */
    get borrowApy() {
        return this.getBorrowApy();
    }
    /**
     * Returns the instantaneous rate at which interest accrues for borrowers of this market,
     * at the given timestamp, if the state remains unchanged (not accrued) (scaled by WAD).
     * It is fundamentally different from the rate at which interest is paid by borrowers to lenders in the case of an interest accrual,
     * as in the case of the AdaptiveCurveIRM, the (approximated) average rate since the last update is used instead.
     * @param timestamp The timestamp at which to calculate the borrow rate. Must be greater than or equal to `lastUpdate`. Defaults to `Time.timestamp()` (returns the current borrow rate).
     */
    getBorrowRate(timestamp = morpho_ts_1.Time.timestamp()) {
        if (this.rateAtTarget == null)
            return 0n;
        timestamp = BigInt(timestamp);
        const elapsed = timestamp - this.lastUpdate;
        if (elapsed < 0n)
            throw new errors_js_1.BlueErrors.InvalidInterestAccrual(this.id, timestamp, this.lastUpdate);
        const { endBorrowRate } = index_js_1.AdaptiveCurveIrmLib.getBorrowRate(this.utilization, this.rateAtTarget, elapsed);
        return endBorrowRate;
    }
    /**
     * Returns the rate at which interest accrues for borrowers of this market,
     * at the given timestamp, if the state remains unchanged (not accrued) (scaled by WAD).
     * @param timestamp The timestamp at which to calculate the accrual borrow rate. Must be greater than or equal to `lastUpdate`. Defaults to `Time.timestamp()` (returns the current borrow rate).
     */
    getAccrualBorrowRate(timestamp = morpho_ts_1.Time.timestamp()) {
        timestamp = BigInt(timestamp);
        const elapsed = timestamp - this.lastUpdate;
        if (elapsed < 0n)
            throw new errors_js_1.BlueErrors.InvalidInterestAccrual(this.id, timestamp, this.lastUpdate);
        if (this.rateAtTarget == null)
            return {
                elapsed,
                avgBorrowRate: 0n,
                endBorrowRate: 0n,
            };
        return {
            elapsed,
            ...index_js_1.AdaptiveCurveIrmLib.getBorrowRate(this.utilization, this.rateAtTarget, elapsed),
        };
    }
    /**
     * The market's instantaneous borrow-side Annual Percentage Yield (APY) at the given timestamp,
     * if the state remains unchanged (not accrued) (scaled by WAD).
     * @param timestamp The timestamp at which to calculate the borrow APY. Must be greater than or equal to `lastUpdate`. Defaults to `Time.timestamp()` (returns the current borrow APY).
     */
    getBorrowApy(timestamp = morpho_ts_1.Time.timestamp()) {
        const borrowRate = this.getBorrowRate(timestamp);
        return MarketUtils_js_1.MarketUtils.compoundRate(borrowRate);
    }
    /**
     * The market's instantaneous supply-side Annual Percentage Yield (APY) at the given timestamp,
     * if the state remains unchanged (not accrued) (scaled by WAD).
     * @param timestamp The timestamp at which to calculate the supply APY. Must be greater than or equal to `lastUpdate`. Defaults to `Time.timestamp()` (returns the current supply APY).
     */
    getSupplyApy(timestamp = morpho_ts_1.Time.timestamp()) {
        const borrowApy = this.getBorrowApy(timestamp);
        return index_js_1.MathLib.wMulUp(index_js_1.MathLib.wMulDown(borrowApy, this.utilization), index_js_1.MathLib.WAD - this.fee);
    }
    /**
     * Returns a new market derived from this market, whose interest has been accrued up to the given timestamp.
     * @param timestamp The timestamp at which to accrue interest. Must be greater than or equal to `lastUpdate`. Defaults to `lastUpdate` (returns a copy of the market).
     */
    accrueInterest(timestamp = this.lastUpdate) {
        timestamp = BigInt(timestamp);
        const { elapsed, avgBorrowRate, endRateAtTarget } = this.getAccrualBorrowRate(timestamp);
        const { interest, feeShares } = MarketUtils_js_1.MarketUtils.getAccruedInterest(avgBorrowRate, this, elapsed);
        return new Market({
            ...this,
            totalSupplyAssets: this.totalSupplyAssets + interest,
            totalBorrowAssets: this.totalBorrowAssets + interest,
            totalSupplyShares: this.totalSupplyShares + feeShares,
            lastUpdate: timestamp,
            rateAtTarget: endRateAtTarget,
        });
    }
    supply(assets, shares, timestamp) {
        if (assets === 0n && shares === 0n)
            throw new errors_js_1.BlueErrors.InconsistentInput();
        const market = this.accrueInterest(timestamp);
        if (shares === 0n)
            shares = market.toSupplyShares(assets, "Down");
        else
            assets = market.toSupplyAssets(shares, "Up");
        market.totalSupplyAssets += assets;
        market.totalSupplyShares += shares;
        return { market, assets, shares };
    }
    withdraw(assets, shares, timestamp) {
        if (assets === 0n && shares === 0n)
            throw new errors_js_1.BlueErrors.InconsistentInput();
        const market = this.accrueInterest(timestamp);
        if (shares === 0n)
            shares = market.toSupplyShares(assets, "Up");
        else
            assets = market.toSupplyAssets(shares, "Down");
        market.totalSupplyAssets -= assets;
        market.totalSupplyShares -= shares;
        if (market.totalBorrowAssets > market.totalSupplyAssets)
            throw new errors_js_1.BlueErrors.InsufficientLiquidity(market.id);
        return { market, assets, shares };
    }
    borrow(assets, shares, timestamp) {
        if (assets === 0n && shares === 0n)
            throw new errors_js_1.BlueErrors.InconsistentInput();
        const market = this.accrueInterest(timestamp);
        if (shares === 0n)
            shares = market.toBorrowShares(assets, "Up");
        else
            assets = market.toBorrowAssets(shares, "Down");
        market.totalBorrowAssets += assets;
        market.totalBorrowShares += shares;
        if (market.totalBorrowAssets > market.totalSupplyAssets)
            throw new errors_js_1.BlueErrors.InsufficientLiquidity(market.id);
        return { market, assets, shares };
    }
    repay(assets, shares, timestamp) {
        if (assets === 0n && shares === 0n)
            throw new errors_js_1.BlueErrors.InconsistentInput();
        const market = this.accrueInterest(timestamp);
        if (shares === 0n)
            shares = market.toBorrowShares(assets, "Down");
        else
            assets = market.toBorrowAssets(shares, "Up");
        market.totalBorrowAssets -= assets;
        market.totalBorrowShares -= shares;
        return { market, assets, shares };
    }
    /**
     * Converts a given amount of supply shares into supply loan assets.
     * @param shares The amount of shares to convert.
     * @param rounding The rounding direction to use (defaults to "Down").
     */
    toSupplyAssets(shares, rounding) {
        return MarketUtils_js_1.MarketUtils.toSupplyAssets(shares, this, rounding);
    }
    /**
     * Converts a given amount of supply loan assets into supply shares.
     * @param shares The amount of assets to convert.
     * @param rounding The rounding direction to use (defaults to "Up").
     */
    toSupplyShares(assets, rounding) {
        return MarketUtils_js_1.MarketUtils.toSupplyShares(assets, this, rounding);
    }
    /**
     * Converts a given amount of borrow shares into borrow loan assets.
     * @param shares The amount of shares to convert.
     * @param rounding The rounding direction to use (defaults to "Up").
     */
    toBorrowAssets(shares, rounding) {
        return MarketUtils_js_1.MarketUtils.toBorrowAssets(shares, this, rounding);
    }
    /**
     * Converts a given amount of borrow loan assets into borrow shares.
     * @param shares The amount of assets to convert.
     * @param rounding The rounding direction to use (defaults to "Down").
     */
    toBorrowShares(assets, rounding) {
        return MarketUtils_js_1.MarketUtils.toBorrowShares(assets, this, rounding);
    }
    /**
     * Returns the smallest volume to supply until the market gets the closest to the given utilization rate.
     * @param utilization The target utilization rate (scaled by WAD).
     */
    getSupplyToUtilization(utilization) {
        return MarketUtils_js_1.MarketUtils.getSupplyToUtilization(this, utilization);
    }
    /**
     * Returns the liquidity available to withdraw until the market gets the closest to the given utilization rate.
     * @param utilization The target utilization rate (scaled by WAD).
     */
    getWithdrawToUtilization(utilization) {
        return MarketUtils_js_1.MarketUtils.getWithdrawToUtilization(this, utilization);
    }
    /**
     * Returns the liquidity available to borrow until the market gets the closest to the given utilization rate.
     * @param utilization The target utilization rate (scaled by WAD).
     */
    getBorrowToUtilization(utilization) {
        return MarketUtils_js_1.MarketUtils.getBorrowToUtilization(this, utilization);
    }
    /**
     * Returns the smallest volume to repay until the market gets the closest to the given utilization rate.
     * @param utilization The target utilization rate (scaled by WAD).
     */
    getRepayToUtilization(utilization) {
        return MarketUtils_js_1.MarketUtils.getRepayToUtilization(this, utilization);
    }
    /**
     * Returns the value of a given amount of collateral quoted in loan assets.
     * `undefined` iff the market's oracle is undefined or reverts.
     * @param collateral The amount of collateral to quote.
     */
    getCollateralValue(collateral) {
        return MarketUtils_js_1.MarketUtils.getCollateralValue(collateral, this);
    }
    /**
     * Returns the maximum debt allowed given a certain amount of collateral.
     * `undefined` iff the market's oracle is undefined or reverts.
     * To calculate the amount of loan assets that can be borrowed, use `getMaxBorrowableAssets`.
     * @param collateral The amount of collateral to consider.
     */
    getMaxBorrowAssets(collateral, { maxLtv = this.params.lltv } = {}) {
        return MarketUtils_js_1.MarketUtils.getMaxBorrowAssets(collateral, this, {
            lltv: index_js_1.MathLib.min(maxLtv, this.params.lltv),
        });
    }
    /**
     * Returns the maximum amount of loan assets that can be borrowed given a certain borrow position.
     * `undefined` iff the market's oracle is undefined or reverts.
     * @param position The borrow position to consider.
     */
    getMaxBorrowableAssets(position) {
        return MarketUtils_js_1.MarketUtils.getMaxBorrowableAssets(position, this, this.params);
    }
    /**
     * Returns the amount of collateral that would be seized in a liquidation given a certain amount of repaid shares.
     * `undefined` iff the market's oracle is undefined or reverts.
     * @param repaidShares The amount of shares hypothetically repaid.
     */
    getLiquidationSeizedAssets(repaidShares) {
        return MarketUtils_js_1.MarketUtils.getLiquidationSeizedAssets(repaidShares, this, this.params);
    }
    /**
     * Returns the amount of borrow shares that would be repaid in a liquidation given a certain amount of seized collateral.
     * `undefined` iff the market's oracle is undefined or reverts.
     * @param seizedAssets The amount of collateral hypothetically seized.
     */
    getLiquidationRepaidShares(seizedAssets) {
        return MarketUtils_js_1.MarketUtils.getLiquidationRepaidShares(seizedAssets, this, this.params);
    }
    /**
     * Returns the maximum amount of collateral that is worth being seized in a liquidation given a certain borrow position.
     * `undefined` iff the market's oracle is undefined or reverts.
     * @param position The borrow position to consider.
     */
    getSeizableCollateral(position) {
        return MarketUtils_js_1.MarketUtils.getSeizableCollateral(position, this, this.params);
    }
    /**
     * Returns the amount of collateral that can be withdrawn given a certain borrow position.
     * `undefined` iff the market's oracle is undefined or reverts.
     * @param position The borrow position to consider.
     */
    getWithdrawableCollateral(position, { maxLtv = this.params.lltv } = {}) {
        return MarketUtils_js_1.MarketUtils.getWithdrawableCollateral(position, this, {
            lltv: index_js_1.MathLib.min(maxLtv, this.params.lltv),
        });
    }
    /**
     * Returns whether a given borrow position is healthy.
     * `undefined` iff the market's oracle is undefined or reverts.
     * @param position The borrow position to check.
     */
    isHealthy(position) {
        return MarketUtils_js_1.MarketUtils.isHealthy(position, this, this.params);
    }
    /**
     * Returns the liquidation price of a given borrow position.
     * @param position The borrow position to consider.
     */
    getLiquidationPrice(position) {
        return MarketUtils_js_1.MarketUtils.getLiquidationPrice(position, this, this.params);
    }
    /**
     * Returns the price variation required for the given position to reach its liquidation threshold (scaled by WAD).
     * Negative when healthy (the price needs to drop x%), positive when unhealthy (the price needs to soar x%).
     * Returns `undefined` iff the market's price is undefined.
     * Returns null if the position is not a borrow.
     * @param position The borrow position to consider.
     */
    getPriceVariationToLiquidationPrice(position) {
        return MarketUtils_js_1.MarketUtils.getPriceVariationToLiquidationPrice(position, this, this.params);
    }
    /**
     * Returns the health factor of a given borrow position (scaled by WAD).
     * @param position The borrow position to consider.
     */
    getHealthFactor(position) {
        return MarketUtils_js_1.MarketUtils.getHealthFactor(position, this, this.params);
    }
    /**
     * Returns the loan-to-value ratio of a given borrow position (scaled by WAD).
     * @param position The borrow position to consider.
     */
    getLtv(position) {
        return MarketUtils_js_1.MarketUtils.getLtv(position, this);
    }
    /**
     * Returns the usage ratio of the maximum borrow capacity given a certain borrow position (scaled by WAD).
     * @param position The borrow position to consider.
     */
    getBorrowCapacityUsage(position) {
        return MarketUtils_js_1.MarketUtils.getBorrowCapacityUsage(position, this, this.params);
    }
    /**
     * Returns the maximum amount of loan assets that can be borrowed given a certain borrow position
     * and the reason for the limit.
     * Returns `undefined` iff the market's price is undefined.
     * @param position The borrow position to consider.
     */
    getBorrowCapacityLimit({ collateral, borrowShares = 0n, }, options) {
        const maxBorrowAssets = this.getMaxBorrowAssets(collateral, options);
        if (maxBorrowAssets == null)
            return;
        // handle edge cases when the user is liquidatable (maxBorrow < borrow)
        const maxBorrowableAssets = index_js_1.MathLib.zeroFloorSub(maxBorrowAssets, this.toBorrowAssets(borrowShares));
        const { liquidity } = this;
        if (maxBorrowableAssets > liquidity)
            return {
                value: liquidity,
                limiter: CapacityLimitReason.liquidity,
            };
        return {
            value: maxBorrowableAssets,
            limiter: CapacityLimitReason.collateral,
        };
    }
    /**
     * Returns the maximum amount of loan assets that can be repaid given a certain borrow position
     * and a balance of loan assets, and the reason for the limit.
     * @param position The borrow position to consider.
     */
    getRepayCapacityLimit(borrowShares, loanTokenBalance) {
        const borrowAssets = this.toBorrowAssets(borrowShares);
        if (borrowAssets > loanTokenBalance)
            return {
                value: loanTokenBalance,
                limiter: CapacityLimitReason.balance,
            };
        return {
            value: borrowAssets,
            limiter: CapacityLimitReason.position,
        };
    }
    /**
     * Returns the maximum amount of loan assets that can be withdrawn given a certain supply position
     * and a balance of loan assets, and the reason for the limit.
     * @param position The supply position to consider.
     */
    getWithdrawCapacityLimit({ supplyShares, }) {
        const supplyAssets = this.toSupplyAssets(supplyShares);
        const { liquidity } = this;
        if (supplyAssets > liquidity)
            return {
                value: liquidity,
                limiter: CapacityLimitReason.liquidity,
            };
        return {
            value: supplyAssets,
            limiter: CapacityLimitReason.position,
        };
    }
    /**
     * Returns the maximum amount of collateral assets that can be withdrawn given a certain borrow position
     * and the reason for the limit.
     * Returns `undefined` iff the market's price is undefined.
     * @param position The borrow position to consider.
     */
    getWithdrawCollateralCapacityLimit(position, options) {
        const withdrawableCollateral = this.getWithdrawableCollateral(position, options);
        if (withdrawableCollateral == null)
            return;
        if (position.collateral > withdrawableCollateral)
            return {
                value: withdrawableCollateral,
                limiter: CapacityLimitReason.collateral,
            };
        return {
            value: position.collateral,
            limiter: CapacityLimitReason.position,
        };
    }
    /**
     * Returns the maximum capacity for all interactions with Morpho Blue given a certain position
     * and loan and collateral balances.
     * @param position The position to consider.
     * @param loanTokenBalance The balance of loan assets.
     * @param collateralTokenBalance The balance of collateral assets.
     */
    getMaxCapacities(position, loanTokenBalance, collateralTokenBalance, options) {
        return {
            supply: {
                value: loanTokenBalance,
                limiter: CapacityLimitReason.balance,
            },
            withdraw: this.getWithdrawCapacityLimit(position),
            borrow: this.getBorrowCapacityLimit(position, options?.borrow),
            repay: this.getRepayCapacityLimit(position.borrowShares, loanTokenBalance),
            supplyCollateral: {
                value: collateralTokenBalance,
                limiter: CapacityLimitReason.balance,
            },
            withdrawCollateral: this.getWithdrawCollateralCapacityLimit(position, options?.withdrawCollateral),
        };
    }
}
exports.Market = Market;
