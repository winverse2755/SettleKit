"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MarketUtils = void 0;
const sha3_1 = require("@noble/hashes/sha3");
const utils_1 = require("@noble/hashes/utils");
const constants_js_1 = require("../constants.js");
const index_js_1 = require("../math/index.js");
/**
 * Namespace of utility functions to ease market-related calculations.
 */
var MarketUtils;
(function (MarketUtils) {
    /**
     * Returns the id of a market based on its params.
     * @param market The market params.
     */
    function getMarketId(market) {
        return `0x${(0, utils_1.bytesToHex)((0, sha3_1.keccak_256)((0, utils_1.hexToBytes)(`${market.loanToken.substring(2).toLowerCase().padStart(64, "0") +
            market.collateralToken
                .substring(2)
                .toLowerCase()
                .padStart(64, "0") +
            market.oracle.substring(2).padStart(64, "0") +
            market.irm.substring(2).toLowerCase().padStart(64, "0") +
            BigInt(market.lltv).toString(16).padStart(64, "0")}`)))}`;
    }
    MarketUtils.getMarketId = getMarketId;
    /**
     * Returns the liquidation incentive factor for a given market params.
     * @param config The market params.
     */
    function getLiquidationIncentiveFactor({ lltv }) {
        return index_js_1.MathLib.min(constants_js_1.MAX_LIQUIDATION_INCENTIVE_FACTOR, index_js_1.MathLib.wDivDown(index_js_1.MathLib.WAD, index_js_1.MathLib.WAD -
            index_js_1.MathLib.wMulDown(constants_js_1.LIQUIDATION_CURSOR, index_js_1.MathLib.WAD - BigInt(lltv))));
    }
    MarketUtils.getLiquidationIncentiveFactor = getLiquidationIncentiveFactor;
    /**
     * Returns the market's utilization rate (scaled by WAD).
     * @param market The market state.
     */
    function getUtilization({ totalSupplyAssets, totalBorrowAssets, }) {
        totalSupplyAssets = BigInt(totalSupplyAssets);
        totalBorrowAssets = BigInt(totalBorrowAssets);
        if (totalSupplyAssets === 0n) {
            if (totalBorrowAssets > 0n)
                return index_js_1.MathLib.MAX_UINT_256;
            return 0n;
        }
        return index_js_1.MathLib.wDivDown(totalBorrowAssets, totalSupplyAssets);
    }
    MarketUtils.getUtilization = getUtilization;
    /**
     * Returns the rate at which interest accrued for suppliers on the corresponding market,
     * since the last time the market was updated (scaled by WAD).
     * @param borrowRate The average borrow rate since the last market update (scaled by WAD).
     * @param market The market state.
     * @deprecated There's no such thing as a supply rate in Morpho. Only the supply APY is meaningful.
     */
    function getSupplyRate(borrowRate, { utilization, fee }) {
        const borrowRateWithoutFees = index_js_1.MathLib.wMulUp(borrowRate, utilization);
        return index_js_1.MathLib.wMulUp(borrowRateWithoutFees, index_js_1.MathLib.WAD - BigInt(fee));
    }
    MarketUtils.getSupplyRate = getSupplyRate;
    /**
     * Returns the per-second rate continuously compounded over the given period, as calculated in Morpho Blue (scaled by WAD).
     * If the period is 1 year, the compounded rate correspond to the Annual Percentage Yield (APY)
     * @param rate The per-second rate to compound (scaled by WAD).
     * @param period The period to compound the rate over (in seconds). Defaults to 1 year.
     */
    function compoundRate(rate, period = constants_js_1.SECONDS_PER_YEAR) {
        return index_js_1.MathLib.wTaylorCompounded(rate, period);
    }
    MarketUtils.compoundRate = compoundRate;
    /**
     * Returns the interest accrued on both sides of the given market
     * as well as the supply shares minted to the fee recipient.
     * @param borrowRate The average borrow rate since the last market update (scaled by WAD).
     * @param market The market state.
     * @param elapsed The time elapsed since the last market update (in seconds).
     */
    function getAccruedInterest(borrowRate, { totalSupplyAssets, totalBorrowAssets, totalSupplyShares, fee, }, elapsed = 0n) {
        const interest = index_js_1.MathLib.wMulDown(totalBorrowAssets, index_js_1.MathLib.wTaylorCompounded(borrowRate, elapsed));
        const feeAmount = index_js_1.MathLib.wMulDown(interest, fee);
        const feeShares = toSupplyShares(feeAmount, {
            totalSupplyAssets: BigInt(totalSupplyAssets) - feeAmount,
            totalSupplyShares,
        }, "Down");
        return { interest, feeShares };
    }
    MarketUtils.getAccruedInterest = getAccruedInterest;
    /**
     * Returns the smallest volume to supply until the market gets the closest to the given utilization rate.
     * @param market The market state.
     * @param utilization The target utilization rate (scaled by WAD).
     */
    function getSupplyToUtilization(market, utilization) {
        utilization = BigInt(utilization);
        if (utilization === 0n) {
            if (getUtilization(market) === 0n)
                return 0n;
            return index_js_1.MathLib.MAX_UINT_256;
        }
        return index_js_1.MathLib.zeroFloorSub(index_js_1.MathLib.wDivUp(market.totalBorrowAssets, utilization), market.totalSupplyAssets);
    }
    MarketUtils.getSupplyToUtilization = getSupplyToUtilization;
    /**
     * Returns the liquidity available to withdraw until the market gets the closest to the given utilization rate.
     * @param market The market state.
     * @param utilization The target utilization rate (scaled by WAD).
     */
    function getWithdrawToUtilization({ totalSupplyAssets, totalBorrowAssets, }, utilization) {
        utilization = BigInt(utilization);
        totalSupplyAssets = BigInt(totalSupplyAssets);
        totalBorrowAssets = BigInt(totalBorrowAssets);
        if (utilization === 0n) {
            if (totalBorrowAssets === 0n)
                return totalSupplyAssets;
            return 0n;
        }
        return index_js_1.MathLib.zeroFloorSub(totalSupplyAssets, index_js_1.MathLib.wDivUp(totalBorrowAssets, utilization));
    }
    MarketUtils.getWithdrawToUtilization = getWithdrawToUtilization;
    /**
     * Returns the liquidity available to borrow until the market gets the closest to the given utilization rate.
     * @param market The market state.
     * @param utilization The target utilization rate (scaled by WAD).
     */
    function getBorrowToUtilization({ totalSupplyAssets, totalBorrowAssets, }, utilization) {
        return index_js_1.MathLib.zeroFloorSub(index_js_1.MathLib.wMulDown(totalSupplyAssets, utilization), totalBorrowAssets);
    }
    MarketUtils.getBorrowToUtilization = getBorrowToUtilization;
    /**
     * Returns the smallest volume to repay until the market gets the closest to the given utilization rate.
     * @param market The market state.
     * @param utilization The target utilization rate (scaled by WAD).
     */
    function getRepayToUtilization({ totalSupplyAssets, totalBorrowAssets, }, utilization) {
        return index_js_1.MathLib.zeroFloorSub(totalBorrowAssets, index_js_1.MathLib.wMulDown(totalSupplyAssets, utilization));
    }
    MarketUtils.getRepayToUtilization = getRepayToUtilization;
    function getCollateralPower(collateral, { lltv }) {
        return index_js_1.MathLib.wMulDown(collateral, lltv);
    }
    MarketUtils.getCollateralPower = getCollateralPower;
    /**
     * Returns the value of a given amount of collateral quoted in loan assets.
     * Return `undefined` iff the market's price is undefined.
     */
    function getCollateralValue(collateral, { price }) {
        if (price == null)
            return;
        return index_js_1.MathLib.mulDivDown(collateral, price, constants_js_1.ORACLE_PRICE_SCALE);
    }
    MarketUtils.getCollateralValue = getCollateralValue;
    /**
     * Returns the maximum debt allowed given a certain amount of collateral.
     * Return `undefined` iff the market's price is undefined.
     * To calculate the amount of loan assets that can be borrowed, use `getMaxBorrowableAssets`.
     */
    function getMaxBorrowAssets(collateral, market, { lltv }) {
        const collateralValue = getCollateralValue(collateral, market);
        if (collateralValue == null)
            return;
        return index_js_1.MathLib.wMulDown(collateralValue, lltv);
    }
    MarketUtils.getMaxBorrowAssets = getMaxBorrowAssets;
    /**
     * Returns the maximum amount of loan assets that can be borrowed given a certain borrow position.
     * Return `undefined` iff the market's price is undefined.
     */
    function getMaxBorrowableAssets({ collateral, borrowShares, }, market, marketParams) {
        const maxBorrowAssets = getMaxBorrowAssets(collateral, market, marketParams);
        if (maxBorrowAssets == null)
            return;
        return index_js_1.MathLib.zeroFloorSub(maxBorrowAssets, toBorrowAssets(borrowShares, market));
    }
    MarketUtils.getMaxBorrowableAssets = getMaxBorrowableAssets;
    /**
     * Returns the amount of collateral that would be seized in a liquidation given a certain amount of repaid shares.
     * Return `undefined` iff the market's price is undefined.
     */
    function getLiquidationSeizedAssets(repaidShares, market, config) {
        if (market.price == null)
            return;
        market.price = BigInt(market.price);
        if (market.price === 0n)
            return 0n;
        return index_js_1.MathLib.mulDivDown(index_js_1.MathLib.wMulDown(toBorrowAssets(repaidShares, market, "Down"), getLiquidationIncentiveFactor(config)), constants_js_1.ORACLE_PRICE_SCALE, market.price);
    }
    MarketUtils.getLiquidationSeizedAssets = getLiquidationSeizedAssets;
    /**
     * Returns the amount of borrow shares that would be repaid in a liquidation given a certain amount of seized collateral.
     * Return `undefined` iff the market's price is undefined.
     */
    function getLiquidationRepaidShares(seizedAssets, market, config) {
        if (market.price == null)
            return;
        return toBorrowShares(index_js_1.MathLib.wDivUp(index_js_1.MathLib.mulDivUp(seizedAssets, market.price, constants_js_1.ORACLE_PRICE_SCALE), getLiquidationIncentiveFactor(config)), market, "Up");
    }
    MarketUtils.getLiquidationRepaidShares = getLiquidationRepaidShares;
    /**
     * Returns the maximum amount of collateral that is worth being seized in a liquidation given a certain borrow position.
     * Return `undefined` iff the market's price is undefined.
     */
    function getSeizableCollateral(position, market, config) {
        if (market.price == null)
            return; // Must be checked before calling `isHealthy`.
        market.price = BigInt(market.price);
        if (market.price === 0n || isHealthy(position, market, config))
            return 0n;
        return index_js_1.MathLib.min(position.collateral, getLiquidationSeizedAssets(position.borrowShares, market, config));
    }
    MarketUtils.getSeizableCollateral = getSeizableCollateral;
    /**
     * Returns the amount of collateral that can be withdrawn given a certain borrow position.
     * Return `undefined` iff the market's price is undefined.
     */
    function getWithdrawableCollateral({ collateral, borrowShares, }, market, { lltv }) {
        if (market.price == null)
            return;
        market.price = BigInt(market.price);
        if (market.price === 0n)
            return 0n;
        return index_js_1.MathLib.zeroFloorSub(collateral, index_js_1.MathLib.wDivUp(index_js_1.MathLib.mulDivUp(toBorrowAssets(borrowShares, market), constants_js_1.ORACLE_PRICE_SCALE, market.price), lltv));
    }
    MarketUtils.getWithdrawableCollateral = getWithdrawableCollateral;
    /**
     * Returns whether a given borrow position is healthy.
     * Return `undefined` iff the market's price is undefined.
     * @param position The borrow position to check.
     */
    function isHealthy({ collateral, borrowShares, }, market, marketParams) {
        const maxBorrowAssets = getMaxBorrowAssets(collateral, market, marketParams);
        if (maxBorrowAssets == null)
            return;
        return maxBorrowAssets >= toBorrowAssets(borrowShares, market);
    }
    MarketUtils.isHealthy = isHealthy;
    /**
     * Returns the price of the collateral quoted in the loan token (e.g. ETH/DAI)
     * that set the user's position to be liquidatable.
     * Returns null if the position is not a borrow.
     */
    function getLiquidationPrice({ collateral, borrowShares, }, market, marketParams) {
        borrowShares = BigInt(borrowShares);
        market.totalBorrowShares = BigInt(market.totalBorrowShares);
        if (borrowShares === 0n || market.totalBorrowShares === 0n)
            return null;
        const collateralPower = getCollateralPower(collateral, marketParams);
        if (collateralPower === 0n)
            return index_js_1.MathLib.MAX_UINT_256;
        const borrowAssets = toBorrowAssets(borrowShares, market);
        return index_js_1.MathLib.mulDivUp(borrowAssets, constants_js_1.ORACLE_PRICE_SCALE, collateralPower);
    }
    MarketUtils.getLiquidationPrice = getLiquidationPrice;
    /**
     * Returns the price variation required for the given position to reach its liquidation threshold (scaled by WAD).
     * Negative when healthy (the price needs to drop x%), positive when unhealthy (the price needs to soar x%).
     * Returns `undefined` iff the market's price is undefined.
     * Returns null if the position is not a borrow.
     */
    function getPriceVariationToLiquidationPrice(position, market, marketParams) {
        if (market.price == null)
            return;
        market.price = BigInt(market.price);
        if (market.price === 0n)
            return null;
        const liquidationPrice = getLiquidationPrice(position, market, marketParams);
        if (liquidationPrice == null)
            return null;
        return index_js_1.MathLib.wDivUp(liquidationPrice, market.price) - index_js_1.MathLib.WAD;
    }
    MarketUtils.getPriceVariationToLiquidationPrice = getPriceVariationToLiquidationPrice;
    /**
     * Returns the health factor of a given borrow position (scaled by WAD).
     * If the debt is 0, health factor is `MaxUint256`.
     * Returns `undefined` iff the market's price is undefined.
     */
    function getHealthFactor({ collateral, borrowShares, }, market, marketParams) {
        const borrowAssets = toBorrowAssets(borrowShares, market);
        if (borrowAssets === 0n)
            return index_js_1.MathLib.MAX_UINT_256;
        const maxBorrowAssets = getMaxBorrowAssets(collateral, market, marketParams);
        if (maxBorrowAssets == null)
            return;
        return index_js_1.MathLib.wDivDown(maxBorrowAssets, borrowAssets);
    }
    MarketUtils.getHealthFactor = getHealthFactor;
    /**
     * Returns the loan-to-value ratio of a given borrow position (scaled by WAD).
     * Returns `undefined` iff the market's price is undefined.
     * Returns null if the position is not a borrow.
     */
    function getLtv({ collateral, borrowShares, }, market) {
        borrowShares = BigInt(borrowShares);
        market.totalBorrowShares = BigInt(market.totalBorrowShares);
        if (borrowShares === 0n || market.totalBorrowShares === 0n)
            return null;
        const collateralValue = getCollateralValue(collateral, market);
        if (collateralValue == null)
            return;
        if (collateralValue === 0n)
            return index_js_1.MathLib.MAX_UINT_256;
        return index_js_1.MathLib.wDivUp(toBorrowAssets(borrowShares, market), collateralValue);
    }
    MarketUtils.getLtv = getLtv;
    /**
     * Returns the usage ratio of the maximum borrow capacity given a certain borrow position (scaled by WAD).
     * Returns `undefined` iff the market's price is undefined.
     */
    function getBorrowCapacityUsage(position, market, marketParams) {
        const hf = getHealthFactor(position, market, marketParams);
        if (hf === undefined)
            return;
        if (hf === null)
            return 0n;
        if (hf === 0n)
            return index_js_1.MathLib.MAX_UINT_256;
        return index_js_1.MathLib.wDivUp(index_js_1.MathLib.WAD, hf);
    }
    MarketUtils.getBorrowCapacityUsage = getBorrowCapacityUsage;
    function toSupplyAssets(shares, market, rounding = "Down") {
        return index_js_1.SharesMath.toAssets(shares, market.totalSupplyAssets, market.totalSupplyShares, rounding);
    }
    MarketUtils.toSupplyAssets = toSupplyAssets;
    function toSupplyShares(assets, market, rounding = "Up") {
        return index_js_1.SharesMath.toShares(assets, market.totalSupplyAssets, market.totalSupplyShares, rounding);
    }
    MarketUtils.toSupplyShares = toSupplyShares;
    function toBorrowAssets(shares, market, rounding = "Up") {
        return index_js_1.SharesMath.toAssets(shares, market.totalBorrowAssets, market.totalBorrowShares, rounding);
    }
    MarketUtils.toBorrowAssets = toBorrowAssets;
    function toBorrowShares(assets, market, rounding = "Down") {
        return index_js_1.SharesMath.toShares(assets, market.totalBorrowAssets, market.totalBorrowShares, rounding);
    }
    MarketUtils.toBorrowShares = toBorrowShares;
})(MarketUtils || (exports.MarketUtils = MarketUtils = {}));
