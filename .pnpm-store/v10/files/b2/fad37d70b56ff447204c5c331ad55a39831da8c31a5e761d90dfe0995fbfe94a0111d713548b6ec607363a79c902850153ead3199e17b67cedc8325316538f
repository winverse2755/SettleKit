"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.safeSignTypedData = safeSignTypedData;
exports.verifySignature = verifySignature;
exports.getMessage = getMessage;
const ethers_1 = require("ethers");
const errors_1 = require("../errors");
async function safeSignTypedData(signer, domain, types, 
// biome-ignore lint/suspicious/noExplicitAny: old code
value) {
    const populated = await ethers_1.TypedDataEncoder.resolveNames(domain, types, value, (name) => {
        return signer.resolveName(name);
    });
    // Fix the chainId parsing issue
    // Tracking of https://github.com/ethers-io/ethers.js/issues/4649
    const initialPayload = ethers_1.TypedDataEncoder.getPayload(populated.domain, types, populated.value);
    const provider = signer.provider;
    const unsafeChainId = Number(initialPayload.domain.chainId);
    if (provider && "send" in provider && Number.isSafeInteger(unsafeChainId)) {
        const correctedPayload = {
            ...initialPayload,
            domain: {
                ...initialPayload.domain,
                chainId: unsafeChainId, // that is safe now
            },
        };
        try {
            return ethers_1.Signature.from(
            // @ts-ignore if send is defined in the provider, it accepts raw RPC call args
            await signer.provider.send("eth_signTypedData_v4", [
                // Doing the same thing that inside of the signTypedData function.
                await signer.getAddress().then((r) => r.toLowerCase()),
                JSON.stringify(correctedPayload),
            ]));
            // biome-ignore lint/suspicious/noExplicitAny: old code
        }
        catch (e) {
            if ("reason" in e && e.reason === "rejected")
                throw e;
        }
    }
    return ethers_1.Signature.from(await signer.signTypedData(populated.domain, types, populated.value));
}
function verifySignature(signature, hash, signerAddress) {
    const recoveredAddress = (0, ethers_1.recoverAddress)(hash, signature);
    if (recoveredAddress === ethers_1.ZeroAddress || recoveredAddress !== signerAddress)
        throw new errors_1.InvalidSignatureError(hash, signerAddress, recoveredAddress);
}
function getMessage(domain, types, 
// biome-ignore lint/suspicious/noExplicitAny: old code
value) {
    const hash = ethers_1.TypedDataEncoder.hash(domain, types, value);
    return { data: { domain, types, value }, hash };
}
