"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AdaptiveCurveIrmLib = void 0;
const constants_js_1 = require("../constants.js");
const MathLib_js_1 = require("./MathLib.js");
/**
 * JS implementation of {@link https://github.com/morpho-org/morpho-blue-irm/blob/main/src/libraries/adaptive-curve/ExpLib.sol ExpLib} used by the Adaptive Curve IRM.
 */
var AdaptiveCurveIrmLib;
(function (AdaptiveCurveIrmLib) {
    AdaptiveCurveIrmLib.CURVE_STEEPNESS = 4000000000000000000n;
    AdaptiveCurveIrmLib.TARGET_UTILIZATION = 900000000000000000n;
    AdaptiveCurveIrmLib.INITIAL_RATE_AT_TARGET = 40000000000000000n / constants_js_1.SECONDS_PER_YEAR;
    AdaptiveCurveIrmLib.ADJUSTMENT_SPEED = 50000000000000000000n / constants_js_1.SECONDS_PER_YEAR;
    AdaptiveCurveIrmLib.MIN_RATE_AT_TARGET = 1000000000000000n / constants_js_1.SECONDS_PER_YEAR;
    AdaptiveCurveIrmLib.MAX_RATE_AT_TARGET = 2000000000000000000n / constants_js_1.SECONDS_PER_YEAR;
    /**
     * ln(2), scaled by WAD.
     */
    AdaptiveCurveIrmLib.LN_2_INT = 693147180559945309n;
    /**
     * ln(1e-18), scaled by WAD.
     */
    AdaptiveCurveIrmLib.LN_WEI_INT = -41446531673892822312n;
    /**
     * Above this bound, `wExp` is clipped to avoid overflowing when multiplied with 1 ether.
     * This upper bound corresponds to: ln(type(int256).max / 1e36) (scaled by WAD, floored).
     */
    AdaptiveCurveIrmLib.WEXP_UPPER_BOUND = 93859467695000404319n;
    /**
     * The value of wExp(`WEXP_UPPER_BOUND`).
     */
    AdaptiveCurveIrmLib.WEXP_UPPER_VALUE = 57716089161558943949701069502944508345128422502756744429568n;
    /**
     * Returns an approximation of exp(x) used by the Adaptive Curve IRM.
     * @param x
     */
    function wExp(x) {
        x = BigInt(x);
        // If x < ln(1e-18) then exp(x) < 1e-18 so it is rounded to zero.
        if (x < AdaptiveCurveIrmLib.LN_WEI_INT)
            return 0n;
        // `wExp` is clipped to avoid overflowing when multiplied with 1 ether.
        if (x >= AdaptiveCurveIrmLib.WEXP_UPPER_BOUND)
            return AdaptiveCurveIrmLib.WEXP_UPPER_VALUE;
        // Decompose x as x = q * ln(2) + r with q an integer and -ln(2)/2 <= r <= ln(2)/2.
        // q = x / ln(2) rounded half toward zero.
        const roundingAdjustment = x < 0n ? -(AdaptiveCurveIrmLib.LN_2_INT / 2n) : AdaptiveCurveIrmLib.LN_2_INT / 2n;
        const q = (x + roundingAdjustment) / AdaptiveCurveIrmLib.LN_2_INT;
        const r = x - q * AdaptiveCurveIrmLib.LN_2_INT;
        // Compute e^r with a 2nd-order Taylor polynomial.
        const expR = MathLib_js_1.MathLib.WAD + r + (r * r) / MathLib_js_1.MathLib.WAD / 2n;
        // Return e^x = 2^q * e^r.
        if (q === 0n)
            return expR << q;
        return expR >> -q;
    }
    AdaptiveCurveIrmLib.wExp = wExp;
    function getBorrowRate(startUtilization, startRateAtTarget, elapsed) {
        startUtilization = BigInt(startUtilization);
        startRateAtTarget = BigInt(startRateAtTarget);
        elapsed = BigInt(elapsed);
        const errNormFactor = startUtilization > AdaptiveCurveIrmLib.TARGET_UTILIZATION
            ? MathLib_js_1.MathLib.WAD - AdaptiveCurveIrmLib.TARGET_UTILIZATION
            : AdaptiveCurveIrmLib.TARGET_UTILIZATION;
        const err = MathLib_js_1.MathLib.wDivDown(startUtilization - AdaptiveCurveIrmLib.TARGET_UTILIZATION, errNormFactor);
        let avgRateAtTarget;
        let endRateAtTarget;
        if (startRateAtTarget === 0n) {
            // First interaction.
            avgRateAtTarget = AdaptiveCurveIrmLib.INITIAL_RATE_AT_TARGET;
            endRateAtTarget = AdaptiveCurveIrmLib.INITIAL_RATE_AT_TARGET;
        }
        else {
            // The speed is assumed constant between two updates, but it is in fact not constant because of interest.
            // So the rate is always underestimated.
            const speed = MathLib_js_1.MathLib.wMulDown(AdaptiveCurveIrmLib.ADJUSTMENT_SPEED, err);
            const linearAdaptation = speed * elapsed;
            if (linearAdaptation === 0n) {
                // If linearAdaptation == 0, avgRateAtTarget = endRateAtTarget = startRateAtTarget;
                avgRateAtTarget = startRateAtTarget;
                endRateAtTarget = startRateAtTarget;
            }
            else {
                // Non negative because MIN_RATE_AT_TARGET > 0.
                const _newRateAtTarget = (linearAdaptation) => MathLib_js_1.MathLib.min(MathLib_js_1.MathLib.max(MathLib_js_1.MathLib.wMulDown(startRateAtTarget, wExp(linearAdaptation)), AdaptiveCurveIrmLib.MIN_RATE_AT_TARGET), AdaptiveCurveIrmLib.MAX_RATE_AT_TARGET);
                // Formula of the average rate that should be returned to Morpho Blue:
                // avg = 1/T * ∫_0^T curve(startRateAtTarget*exp(speed*x), err) dx
                // The integral is approximated with the trapezoidal rule:
                // avg ~= 1/T * Σ_i=1^N [curve(f((i-1) * T/N), err) + curve(f(i * T/N), err)] / 2 * T/N
                // Where f(x) = startRateAtTarget*exp(speed*x)
                // avg ~= Σ_i=1^N [curve(f((i-1) * T/N), err) + curve(f(i * T/N), err)] / (2 * N)
                // As curve is linear in its first argument:
                // avg ~= curve([Σ_i=1^N [f((i-1) * T/N) + f(i * T/N)] / (2 * N), err)
                // avg ~= curve([(f(0) + f(T))/2 + Σ_i=1^(N-1) f(i * T/N)] / N, err)
                // avg ~= curve([(startRateAtTarget + endRateAtTarget)/2 + Σ_i=1^(N-1) f(i * T/N)] / N, err)
                // With N = 2:
                // avg ~= curve([(startRateAtTarget + endRateAtTarget)/2 + startRateAtTarget*exp(speed*T/2)] / 2, err)
                // avg ~= curve([startRateAtTarget + endRateAtTarget + 2*startRateAtTarget*exp(speed*T/2)] / 4, err)
                endRateAtTarget = _newRateAtTarget(linearAdaptation);
                avgRateAtTarget =
                    (startRateAtTarget +
                        endRateAtTarget +
                        2n * _newRateAtTarget(linearAdaptation / 2n)) /
                        4n;
            }
        }
        // Non negative because 1 - 1/C >= 0, C - 1 >= 0.
        const coeff = err < 0
            ? MathLib_js_1.MathLib.WAD - MathLib_js_1.MathLib.wDivDown(MathLib_js_1.MathLib.WAD, AdaptiveCurveIrmLib.CURVE_STEEPNESS)
            : AdaptiveCurveIrmLib.CURVE_STEEPNESS - MathLib_js_1.MathLib.WAD;
        const _curve = (rateAtTarget) => MathLib_js_1.MathLib.wMulDown(MathLib_js_1.MathLib.wMulDown(coeff, err) + MathLib_js_1.MathLib.WAD, rateAtTarget);
        // Non negative if avgRateAtTarget >= 0 because if err < 0, coeff <= 1.
        return {
            avgBorrowRate: _curve(avgRateAtTarget),
            endBorrowRate: _curve(endRateAtTarget),
            endRateAtTarget,
        };
    }
    AdaptiveCurveIrmLib.getBorrowRate = getBorrowRate;
    function getUtilizationAtBorrowRate(borrowRate, rateAtTarget) {
        borrowRate = BigInt(borrowRate);
        rateAtTarget = BigInt(rateAtTarget);
        if (borrowRate >= rateAtTarget) {
            const maxBorrowRate = MathLib_js_1.MathLib.wMulDown(rateAtTarget, AdaptiveCurveIrmLib.CURVE_STEEPNESS);
            const diffToMaxBorrowRate = maxBorrowRate - rateAtTarget;
            if (diffToMaxBorrowRate === 0n)
                return MathLib_js_1.MathLib.WAD;
            return MathLib_js_1.MathLib.min(MathLib_js_1.MathLib.WAD, AdaptiveCurveIrmLib.TARGET_UTILIZATION +
                MathLib_js_1.MathLib.mulDivDown(MathLib_js_1.MathLib.WAD - AdaptiveCurveIrmLib.TARGET_UTILIZATION, borrowRate - rateAtTarget, diffToMaxBorrowRate));
        }
        const minBorrowRate = MathLib_js_1.MathLib.wDivDown(rateAtTarget, AdaptiveCurveIrmLib.CURVE_STEEPNESS);
        return MathLib_js_1.MathLib.max(0n, MathLib_js_1.MathLib.mulDivDown(AdaptiveCurveIrmLib.TARGET_UTILIZATION, borrowRate - minBorrowRate, rateAtTarget - minBorrowRate));
    }
    AdaptiveCurveIrmLib.getUtilizationAtBorrowRate = getUtilizationAtBorrowRate;
})(AdaptiveCurveIrmLib || (exports.AdaptiveCurveIrmLib = AdaptiveCurveIrmLib = {}));
