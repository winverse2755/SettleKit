"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MathLib = void 0;
/**
 * Library to manage fixed-point arithmetic.
 * https://github.com/morpho-org/morpho-blue/blob/main/src/libraries/MathLib.sol
 */
var MathLib;
(function (MathLib) {
    MathLib.WAD = 1000000000000000000n;
    MathLib.RAY = 1000000000000000000000000000n;
    MathLib.MAX_UINT_256 = maxUint(256);
    MathLib.MAX_UINT_160 = maxUint(160);
    MathLib.MAX_UINT_128 = maxUint(128);
    MathLib.MAX_UINT_48 = maxUint(48);
    function maxUint(nBits) {
        if (nBits % 4 !== 0)
            throw new Error(`Invalid number of bits: ${nBits}`);
        return BigInt(`0x${"f".repeat(nBits / 4)}`);
    }
    MathLib.maxUint = maxUint;
    /**
     * Returns the absolute value of a number
     * @param a The number
     */
    function abs(a) {
        a = BigInt(a);
        return a >= 0 ? a : -a;
    }
    MathLib.abs = abs;
    /**
     * Returns the smallest number given as param
     * @param x The first number
     * @param y The second number
     */
    function min(...xs) {
        return xs.map(BigInt).reduce((x, y) => (x <= y ? x : y));
    }
    MathLib.min = min;
    /**
     * Returns the greatest number given as param
     * @param x The first number
     * @param y The second number
     */
    function max(...xs) {
        return xs.map(BigInt).reduce((x, y) => (x <= y ? y : x));
    }
    MathLib.max = max;
    /**
     * Returns the subtraction of b from a, floored to zero if negative
     * @param x The first number
     * @param y The second number
     */
    function zeroFloorSub(x, y) {
        x = BigInt(x);
        y = BigInt(y);
        return x <= y ? 0n : x - y;
    }
    MathLib.zeroFloorSub = zeroFloorSub;
    /**
     * Perform the WAD-based multiplication of 2 numbers, rounded down
     * @param x The first number
     * @param y The second number
     */
    function wMulDown(x, y) {
        return MathLib.wMul(x, y, "Down");
    }
    MathLib.wMulDown = wMulDown;
    /**
     * Perform the WAD-based multiplication of 2 numbers, rounded up
     * @param x The first number
     * @param y The second number
     */
    function wMulUp(x, y) {
        return MathLib.wMul(x, y, "Up");
    }
    MathLib.wMulUp = wMulUp;
    /**
     * Perform the WAD-based multiplication of 2 numbers with a provided rounding direction
     * @param x The first number
     * @param y The second number
     */
    function wMul(x, y, rounding) {
        return MathLib.mulDiv(x, y, MathLib.WAD, rounding);
    }
    MathLib.wMul = wMul;
    /**
     * Perform the WAD-based division of 2 numbers, rounded down
     * @param x The first number
     * @param y The second number
     */
    function wDivDown(x, y) {
        return MathLib.wDiv(x, y, "Down");
    }
    MathLib.wDivDown = wDivDown;
    /**
     * Perform the WAD-based multiplication of 2 numbers, rounded up
     * @param x The first number
     * @param y The second number
     */
    function wDivUp(x, y) {
        return MathLib.wDiv(x, y, "Up");
    }
    MathLib.wDivUp = wDivUp;
    /**
     * Perform the WAD-based multiplication of 2 numbers with a provided rounding direction
     * @param x The first number
     * @param y The second number
     */
    function wDiv(x, y, rounding) {
        return MathLib.mulDiv(x, MathLib.WAD, y, rounding);
    }
    MathLib.wDiv = wDiv;
    /**
     * Multiply two numbers and divide by a denominator, rounding down the result
     * @param x The first number
     * @param y The second number
     * @param denominator The denominator
     */
    function mulDivDown(x, y, denominator) {
        x = BigInt(x);
        y = BigInt(y);
        denominator = BigInt(denominator);
        if (denominator === 0n)
            throw Error("MathLib: DIVISION_BY_ZERO");
        return (x * y) / denominator;
    }
    MathLib.mulDivDown = mulDivDown;
    /**
     * Multiply two numbers and divide by a denominator, rounding up the result
     * @param x The first number
     * @param y The second number
     * @param denominator The denominator
     */
    function mulDivUp(x, y, denominator) {
        x = BigInt(x);
        y = BigInt(y);
        denominator = BigInt(denominator);
        if (denominator === 0n)
            throw Error("MathLib: DIVISION_BY_ZERO");
        const roundup = (x * y) % denominator > 0 ? 1n : 0n;
        return (x * y) / denominator + roundup;
    }
    MathLib.mulDivUp = mulDivUp;
    function mulDiv(x, y, denominator, rounding) {
        return MathLib[`mulDiv${rounding}`](x, y, denominator);
    }
    MathLib.mulDiv = mulDiv;
    /**
     * The sum of the first three non-zero terms of a Taylor expansion of e^(nx) - 1,
     * to approximate a continuously compounded interest rate.
     *
     * @param x The base of the exponent
     * @param n The exponent
     */
    function wTaylorCompounded(x, n) {
        const firstTerm = BigInt(x) * BigInt(n);
        const secondTerm = MathLib.mulDivDown(firstTerm, firstTerm, 2n * MathLib.WAD);
        const thirdTerm = MathLib.mulDivDown(secondTerm, firstTerm, 3n * MathLib.WAD);
        return firstTerm + secondTerm + thirdTerm;
    }
    MathLib.wTaylorCompounded = wTaylorCompounded;
    /**
     * Converts a WAD-based quantity to a RAY-based quantity.
     * @param x The WAD-based quantity.
     */
    function wToRay(x) {
        return BigInt(x) * 1000000000n;
    }
    MathLib.wToRay = wToRay;
})(MathLib || (exports.MathLib = MathLib = {}));
